<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jacob2359</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://JacobLei.github.io/"/>
  <updated>2019-05-23T05:13:40.186Z</updated>
  <id>http://JacobLei.github.io/</id>
  
  <author>
    <name>jacob2359</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode答疑+打卡微信群</title>
    <link href="http://JacobLei.github.io/2019/05/23/LeetCode%E7%AD%94%E7%96%91-%E6%89%93%E5%8D%A1%E5%BE%AE%E4%BF%A1%E7%BE%A4/"/>
    <id>http://JacobLei.github.io/2019/05/23/LeetCode答疑-打卡微信群/</id>
    <published>2019-05-23T02:54:51.000Z</published>
    <updated>2019-05-23T05:13:40.186Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode答疑群和LeetCode打卡群进群方式</p><a id="more"></a><h1 id="LeetCode答疑群"><a href="#LeetCode答疑群" class="headerlink" title="LeetCode答疑群"></a>LeetCode答疑群</h1><p>为了方便小伙伴们在刷LeetCode（或其他算法题）时遇到任何疑问时方便答疑，建立一个LeetCode答疑群，有任何关于LeetCode（或其他算法题）的相关问题都可以在答疑群中留言，当博主或其他小伙伴看到问题留言时，如果对问题有思路，则会回复。答疑群目的是为了小伙伴们一起学习，共同进步。</p><ul><li>提问方式：【问题LeetCode编号】+ 问题描述</li><li>回答方式：【回答LeetCode编号】+ 答案描述</li><li>进群方式：扫描下方二维码，添加博主的微信号【申请时请留言：<strong>加入LeetCode答疑群+姓名</strong>】，然后博主将你拉入微信群。</li></ul><img src="/2019/05/23/LeetCode答疑-打卡微信群/博主微信二维码.jpg" title="博主微信二维码"><h1 id="LeetCode打卡群"><a href="#LeetCode打卡群" class="headerlink" title="LeetCode打卡群"></a>LeetCode打卡群</h1><p>如果有小伙伴觉得自己刷题自控能力不够，但又想每周刷三道题，或者想和更多的小伙伴们一起刷题，博主建立了一个LeetCode打卡群。打卡群主要是为了小伙伴们通过打卡机制来提高自己的自控能力，保证一周最少能刷三道LeetCode题。</p><ul><li>打卡方式：<ul><li>打卡周的前一个周日晚上8点群主将在群里中收集小伙伴的打卡目标，小伙伴们回复自己的【打卡目标】。如：打卡第一周目标：LeetCode第5、6、7题；或者按照主题打卡定目标，如打卡第一周目标：栈主题+2道简单题+1道困难题。回复目标可以自定义方式（要突出这一周的刷题个数，最少三道），主要是给自己定一个一周的小目标。</li><li>小伙伴们回复完【打卡目标】开始到打卡周的周日晚上7点30截至，在群里发送：<strong>【打卡第m周第n题+LeetCode编号】+ 解题答案 + 通过报告截图</strong> 即打卡完成</li></ul></li><li>奖励/惩罚方式：<ul><li>加入打卡群前提：入群时本人需要缴纳10元的保证金</li><li>惩罚：当在本周打卡截至时间前未完成打卡目标，则10元的保证金作为惩罚将由博主发到打卡群中，群众的小伙伴抢红包</li><li>奖励：现阶段奖励为能够有机会抢到未完成打卡目标的小伙伴的保证金红包，后续等博主资金充裕后会定相关规则，送获奖者书籍</li></ul></li><li>注意事项：<ul><li>由于打卡群涉及到需要收取保证金问题，必须提前声明一下<strong>打卡的保证金为自愿交纳</strong>。入群时先交给博主管理，博主会统计小伙伴的目标和打卡情况，然后周日7点30后会联系相应<strong>未打卡完成</strong>的小伙伴，告诉其保证金需要作为惩罚红包发送到群里。</li><li>未打卡完成的小伙伴由于其保证金作为惩罚红包发给打卡群中，如果想继续参加打卡活动，则需要重新联系博主交纳保证金；如果不想继续参加，也可联系博主，将其删除打卡群，如果未联系博主，则博主在一天后会将其删除打卡群</li><li>打卡完成的小伙伴如果想继续参加打卡活动，则不需要重新交纳保证金，上次交纳的保证金顺延到本次；如果不想继续参加，则联系博主退还保证金</li><li>由于博主一个人运营打卡群，担心人多管理不过来，设定打卡群的人数上限为30人</li><li>每次打卡活动10人（包含博主）及以上则启动打卡活动，若人数不够10人，则会暂停</li></ul></li><li>进群方式：扫描文下方二维码，添加博主的微信号【申请时请留言：<strong>加入LeetCode打卡群+姓名</strong>】，然后博主将你拉入微信群，进群后需要交纳10保证金，保证金的使用具体参看<strong>注意事项</strong>。</li></ul><img src="/2019/05/23/LeetCode答疑-打卡微信群/博主微信二维码.jpg" title="博主微信二维码">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode答疑群和LeetCode打卡群进群方式&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-9 回文数</title>
    <link href="http://JacobLei.github.io/2019/05/22/LeetCode-9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://JacobLei.github.io/2019/05/22/LeetCode-9-回文数/</id>
    <published>2019-05-22T05:17:40.000Z</published>
    <updated>2019-05-22T08:10:57.605Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：9. 回文数</li><li>难度：简单</li><li>分类：字符串、数学</li><li>解决方案：双指针、整数取余<a id="more"></a></li></ul><p>今天我们学习第9题<strong>回文数</strong>，这是一个关于数学的简单题，这个题目比较简单，最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">题目描述</a></h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><p>进阶:<strong>你能不将整数转为字符串来解决这个问题吗？</strong></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>看完这个题目，对于回文数我们应该不陌生。我们在<a href="https://www.jacob2359.com/2019/05/13/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/#more" target="_blank" rel="noopener">LeetCode-5 最长回文子串</a>中介绍过<strong>回文串</strong>，即从左向右读和从右向左读的结果是一样的字符串。本题是判断一个整数是否为一个回文数，最简单的做法是先将这个整数转化为字符串，然后使用双指针的方式判断这个字符串是否为回文串。<br>具体<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转化为字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[] str = String.valueOf(x).toCharArray();</span><br><span class="line">    <span class="comment">// 创建左右指针</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = str.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历字符串</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="comment">// 如果左指针指向的字符与右指针指向的字符不同时，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (str[left] != str[right])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        left++;<span class="comment">// 左指针向右移动</span></span><br><span class="line">        right--;<span class="comment">// 右指针向左移动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/22/LeetCode-9-回文数/回文字符串提交结果.png" title="图1.回文字符串提交结果"><p>将整数转化为字符串后这个题目的思路就很清晰了。注意看<strong>进阶</strong>部分的提示：<strong>你能不将整数转为字符串来解决这个问题吗？</strong> 因此我们需要换一种思路来解决这个题目。<br>我们想一想整数如果是负数，则直接返回<code>false</code>，因为从示例2中可以知道一个负数不可能为回文数。由于整数不可能为0开头（除整数0外），因此整数的个位数为0也直接返回<code>false</code>，如示例3所示。排除完这两种特殊情况后，我们该如何判断剩下的整数是不是回文数呢？要判断一个数是否为回文数，则需要判断前半段和后半段是否对称，我们将后半段部分的数字翻转一下，然后判断翻转后的数字是否与前半部分的数字是否相等即可。我们可以将整数对10取余得到整数的个位数。由于数字位数为奇数个和偶数个的情况不一样，我们通过两个实例分析，如下图2所示。</p><img src="/2019/05/22/LeetCode-9-回文数/整数翻转实例.png" title="图2.整数翻转实例"><p>通过分析之后，具体代码就不难实现了。<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排除负数和以0结尾的整数（除0以外）</span></span><br><span class="line">    <span class="keyword">if</span> ((x &lt; <span class="number">0</span>) || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span> ))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> reverNum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 翻转整数过程</span></span><br><span class="line">    <span class="keyword">while</span> (x &gt; reverNum)&#123;</span><br><span class="line">        reverNum = reverNum * <span class="number">10</span> + x % <span class="number">10</span>;  <span class="comment">// 计算翻转数字</span></span><br><span class="line">        x /= <span class="number">10</span>;                            <span class="comment">// 计算剩余数字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reverNum == x || reverNum / <span class="number">10</span> == x; <span class="comment">// reverNum == x为整数位数偶数个时的判断条件；reverNum / 10 == x为整数位数奇数个时的判断条件</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/22/LeetCode-9-回文数/回文数提交结果.png" title="图3.回文数提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A9_PalindromeNumber.java" target="_blank" rel="noopener">LeetCode-9 回文数</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9.回文数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：9. 回文数&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：字符串、数学&lt;/li&gt;
&lt;li&gt;解决方案：双指针、整数取余
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-递归</title>
    <link href="http://JacobLei.github.io/2019/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/"/>
    <id>http://JacobLei.github.io/2019/05/21/数据结构与算法-递归/</id>
    <published>2019-05-21T07:37:02.000Z</published>
    <updated>2019-05-21T13:52:50.070Z</updated>
    
    <content type="html"><![CDATA[<p>本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学请点击<a href="https://time.geekbang.org/column/article/6691fa2d3eae08aca313064e97b89941/share?oss_token=4f692522d1570132" target="_blank" rel="noopener">课程链接</a>购买学习。如有侵权请联系作者删除。</p><a id="more"></a><h1 id="如何理解递归？"><a href="#如何理解递归？" class="headerlink" title="如何理解递归？"></a>如何理解递归？</h1><p>在学习数据结构与算法的过程中一般都会遇到一个坎——递归。今天我们就来分析分析递归。<br>首先我们通过一个生活中的例子入手。假如你现在正在排队买票，前面有很多人，怎么才能知道你现在是第几号呢？这个时候就可以用递归了，你知道问你前面的人是多少号，在他的号数上加一即为你的号数。但是，前面的人也不知道自己是多少号啊，所以他再问他前面的人，这样一个一个的向前面问，直到问道队头的人，他说他现在是1号，然后这样就可以一个一个向后把数字传回来，直到你前面的人告诉你他是多少号，这样你就知道了你的位置了。<br>这个例子就是一个标准的递归求解问题的分解过程，一个一个向前问的过程就是”递”，一个一个向后传回来的过程就是”归”。基本上所有的递归问题都可以用公式表示出来。如上述例子的递归推导公式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + 1，其中f(1) = 1</span><br></pre></td></tr></table></figure></p><p><code>f(n)</code>表示你现状所在的位置（多少号），<code>f(n-1)</code>表示你前面一个人所在的位置（多少号），<code>f(1) = 1</code>表示第一个人直到自己为1号。有了这个递推公式，我们就可以很轻松的将它改写为递归代码，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="递归需要满足的条件"><a href="#递归需要满足的条件" class="headerlink" title="递归需要满足的条件"></a>递归需要满足的条件</h1><p>从上述例子可以可以总结如下三个条件：</p><ol><li><p><strong>一个问题的解可以分解为几个子问题的解</strong><br>什么是子问题？子问题就是数据规模更小的问题。如前面介绍的例子，想要直到自己在哪个位置，可以分解为<strong>前面的人知道他在哪个位置</strong>这样一个子问题。</p></li><li><p><strong>子问题除了数据规模不同，求解思路完全一样</strong><br>如前面介绍的例子，你求解自己在哪个位置的思路，和前面一个人求解他自己在哪个位置的思路是完全一样的。</p></li><li><p><strong>必须存在一个递归终止条件</strong><br>把问题分解为子问题，然后把子问题分解为子子问题，一层一层分解下去，需要终止条件结束这种循环。如前面的例子，队头的人不需要问其他人就知道自己为1号，也就是这里的<code>f(1) = 1</code>，这就是终止条件。</p></li></ol><h1 id="如何编写递归代码"><a href="#如何编写递归代码" class="headerlink" title="如何编写递归代码"></a>如何编写递归代码</h1><p>理解递归的过程和递归需要满足的条件后，我们接下来想想如何才能写出递归代码来呢？对于递归代码的编写，最重要的是<strong>写出递归公式，找到递归终止条件</strong>。<br>下面我们看一看LeetCode上一个原题<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70.爬楼梯【题目链接】</a>。对于第一步的走法把所有走法分为两类，一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以对于n个台阶的走法就是等于先走1个台阶后剩下的n-1个台阶的走法+先走2个台阶后剩下的n-2个台阶的走法。递归公式表示如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>接下来我们关心的就是递归终止条件了。当只有一个台阶时，只有一种走法，就不需要递归。因此<code>f(1) = 1</code>。这个递归终止条件足够吗？我们可以使用<code>n=2</code>，和<code>n=3</code>这样比较小的数来试验一下。<br>当<code>n=2</code>时，<code>f(2) = f(1) + f(0)</code>，由于只有<code>f(1) = 1</code>这一个递归终止条件，无法将<code>f(2)</code>求解出来。所以除了<code>f(1) = 1</code>这一个递归终止条件外，我们可以把剩余两个台阶时作为递归终止条件，即<code>f(2) = 2</code>作为递归终止条件。这样知道递归终止条件和递归公式后，我们就可以轻松写出递归代码了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>总结：写递归代码的关键就是<strong>如何将大问题分解为小问题的规律，并基于此规律写出递归公式，并总结处递归终止条件，最后将递归公式和递归终止条件翻译成代码</strong>。</p></blockquote><h1 id="避开思维误区"><a href="#避开思维误区" class="headerlink" title="避开思维误区"></a>避开思维误区</h1><p>对于排队买票的例子，递归调用只有一个分支，也就是说”一个问题只需要分解为一个子问题”，这时我们很容易弄清楚”递”的过程和”归”的过程，所以理解起来难度不大。但是，当我们面临一个问题有多个子问题的情况时，递归就没有那么好理解了。<br>就如爬楼梯的例子，我们人脑几乎没有办法将整个”递”的过程和”归”的过程每一步想得清清楚楚。计算机擅长做重复的事情，所以递归正是这样，而我们人脑更喜欢平铺直叙的思维方式，当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后一层一层返回，试图想弄清楚计算机每一步都是怎么执行的，这样很容易被绕进去。<br>对于递归代码，这种试图想清楚整个递和归过程的做法实际上是进入了一个<strong>思维误区</strong>。我们该如何去思考递归呢？<br>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。因此，<strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</strong>。</p><h1 id="递归代码的注意事项"><a href="#递归代码的注意事项" class="headerlink" title="递归代码的注意事项"></a>递归代码的注意事项</h1><h2 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h2><p>由于在函数调用时会使用栈来保存临时变量，每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。<strong>如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险</strong>。<br>那么该如何避免堆栈溢出呢？<br>我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。对于排队买票的例子，我们可以改造成下面这样子，就可以避免堆栈溢出了。为了代码简洁，有些边界条件没有考虑，比如 x&lt;=0。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示递归的深度</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(depth &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">throw</span> exception;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。</p><h2 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h2><p>我们在分析一下爬楼梯的例子，如果我们把整个递归过程分解一下的话，那就是这样的：<br><img src="/2019/05/21/数据结构与算法-递归/爬楼梯递归过程分解图.jpg" title="爬楼梯递归过程分解图"></p><p>从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。</p><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。<br>我们改写爬楼梯的代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasSolvedList 为一个Map，其中key为n，value为f(n)</span></span><br><span class="line">    <span class="keyword">if</span>(hasSolvedList.containsKey(n))&#123;</span><br><span class="line">    <span class="keyword">return</span> hasSolvedList.get(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    hasSolvedList.put(n, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了堆栈溢出、重复计算这两个常见的问题。递归代码还有很多别的问题。</p><p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是<code>O(1)</code>，而是<code>O(n)</code>。</p><h1 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h1><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。<br>那我们是否可以把递归代码改写为非递归代码呢？比如刚才那个排队买票的例子，我们抛开场景，只看<code>f(x) =f(x-1)+1</code> 这个递推公式。我们这样改写看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    res += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，爬楼梯的例子改为非递归的代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    res = pre + prepre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有的递归代码都可以迭代的方式。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学请点击&lt;a href=&quot;https://time.geekbang.org/column/article/6691fa2d3eae08aca313064e97b89941/share?oss_token=4f692522d1570132&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;课程链接&lt;/a&gt;购买学习。如有侵权请联系作者删除。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://JacobLei.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-8 字符串转换整数</title>
    <link href="http://JacobLei.github.io/2019/05/21/LeetCode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"/>
    <id>http://JacobLei.github.io/2019/05/21/LeetCode-8-字符串转换整数/</id>
    <published>2019-05-21T04:42:29.000Z</published>
    <updated>2019-05-21T10:33:51.804Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：8. 字符串转换整数</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：字符串遍历<a id="more"></a></li></ul><p>今天我们学习第8题<strong>字符串转换整数</strong>，这是一个字符串的中等题，像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">题目描述</a></h1><p>请你来实现一个<code>atoi</code>函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：<br>假设我们的环境只能存储32位大小的有符号整数，那么其数值范围为<code>[−2^31,  2^31 − 1]</code>。如果数值超过这个范围，请返回 <code>INT_MAX(2^31 − 1)</code>或<code>INT_MIN(−2^31)</code> 。</p><p>示例1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure></p><p>示例2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure></p><p>示例3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure></p><p>示例4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure></p><p>示例5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−2^31) 。</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个字符串转换整数的题比较常规，题目和示例中已经详细说明了转换过程及转换的情况，具体归纳如下：</p><ul><li>如果字符串开头为空格，则跳过所有的空格字符，直到寻找到第一个非空格的字符为止，如果全部都是空格，则返回0；</li><li>如果第一个非空格字符为符号字符(<code>+/-</code>)，则使用符号标记<code>sign</code>标记，当为<code>+</code>时，<code>sign=1</code>；当为<code>-</code>时，<code>sign=-1</code>；</li><li>去掉开头的空格字符和符号字符后，如果接下来的字符不为数字字符，则返回0；</li><li>去掉开头的空格字符和符号字符后，如果接下来的字符为数字字符，则将其转化为整数并保存，直到出现不为数字字符或字符串遍历结束；</li><li>特别注意的是，数字转换的时候<strong>需要考虑整数是否溢出</strong>.</li></ul><p>有了上述的分析后，具体<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = ch.length, index = <span class="number">0</span>, sign = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 注意：这里不能为int类型，需要long类型，目的是为了检查结果是否溢出</span></span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 去掉开头的空格部分</span></span><br><span class="line">        <span class="keyword">while</span>(index&lt;len &amp;&amp; ch[index] == <span class="string">' '</span>) index++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否为符号位，当为+时，sign=1；当为-时，sign=-1</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; len &amp;&amp; (ch[index] == <span class="string">'+'</span> || ch[index] == <span class="string">'-'</span>))&#123;</span><br><span class="line">            sign = (ch[index] == <span class="string">'+'</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历字符数组</span></span><br><span class="line">        <span class="keyword">while</span>(index &lt; len)&#123;</span><br><span class="line">            <span class="comment">// 判断是否位数字</span></span><br><span class="line">            <span class="keyword">if</span>(ch[index] &gt;= <span class="string">'0'</span> &amp;&amp; ch[index] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                sum = sum*<span class="number">10</span> + ch[index] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">// 判断结果是否溢出</span></span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="number">1</span> &amp;&amp; sum &gt; Integer.MAX_VALUE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sign == -<span class="number">1</span> &amp;&amp; (-<span class="number">1</span>*sum) &lt; Integer.MIN_VALUE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 如果不是数字，则直接返回</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)sum * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/21/LeetCode-8-字符串转换整数/提交结果.png" title="图1.提交结果"><p>整个算法流程的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>。</p><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A8_StringtoInteger.java" target="_blank" rel="noopener">LeetCode-8 字符串转换整数</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8.字符串转换整数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：8. 字符串转换整数&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：字符串遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-7 整数反转</title>
    <link href="http://JacobLei.github.io/2019/05/20/LeetCode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://JacobLei.github.io/2019/05/20/LeetCode-7-整数反转/</id>
    <published>2019-05-20T11:47:59.000Z</published>
    <updated>2019-05-20T12:38:15.133Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：7. 整数反转</li><li>难度：简单</li><li>分类：数学</li><li>解决方案：整数取模<a id="more"></a></li></ul><p>今天我们学习第7题<strong>整数反转</strong>，这是个简单的数学题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">题目描述</a></h1><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure></p><p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure></p><p>示例3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p><p>注意:<br><strong>假设我们的环境只能存储得下32位的有符号整数，则其数值范围为[−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回0。</strong></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>相信小伙伴们看完这个题目后就会有思路，就是通过取模把最低位取到，然后拼接即可。对于整数<code>-123</code>的转换过程如图1所示：</p><img src="/2019/05/20/LeetCode-7-整数反转/转换过程.png" title="图1.转换过程"><p>值得注意的是如果整数反转后溢出了怎么办？由题意可知，溢出后返回0，因此我们需要判断结果是否溢出。</p><p>具体<code>java</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意这里为long类型，防止int类型的则行数反转后溢出</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反转整数</span></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 获取到最低位</span></span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 在原数字上移除最低位</span></span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断是否溢出，若溢出则返回0</span></span><br><span class="line">            <span class="keyword">if</span>(res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/20/LeetCode-7-整数反转/提交结果.png" title="图2.提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A7_ReverseInteger.java" target="_blank" rel="noopener">LeetCode-7 整数反转</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7.整数反转</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：7. 整数反转&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：数学&lt;/li&gt;
&lt;li&gt;解决方案：整数取模
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-6 Z字形变换</title>
    <link href="http://JacobLei.github.io/2019/05/19/LeetCode-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://JacobLei.github.io/2019/05/19/LeetCode-6-Z字形变换/</id>
    <published>2019-05-19T08:39:24.000Z</published>
    <updated>2019-05-20T12:29:33.922Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：6. Z字形变换</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：字符串遍历<a id="more"></a></li></ul><p>今天我们学习第6题<strong>Z字形变换</strong>，这是一个字符串的中等题，像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">题目描述</a></h1><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为<code>&quot;LEETCODEISHIRING&quot;</code>行数为3时，排列如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure></p><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。<br>请你实现这个将字符串进行指定行数变换的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure></p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题目的难度不太大，主要是对题目的理解，只有理解题目中的<strong>Z字形</strong>是如何生成后才能做出来。注意，这里的Z字形其实是<strong>将Z逆时针旋转90°后形成的</strong>，如图1所示。</p><img src="/2019/05/19/LeetCode-6-Z字形变换/Z字形旋转过程.png" title="图1.Z字形旋转过程"><p>题目中的示例字符串不容易看出规律，我们假设一个字符串为<code>&quot;ABCDEFGHIJKLMN&quot;</code>，然后看看是如何形成Z字形的，具体过程如图2所示。</p><img src="/2019/05/19/LeetCode-6-Z字形变换/解题思路.png" title="图2.解题思路"><p>由图2可知黑色字符表示Z字形垂直部分，红色字符表示Z字形斜右方向部分。不难看出垂直部分字符的个数为<code>numRows</code>，斜右方向部分子数的个数为<code>numRows-2</code>(除首行和最后一行以外，其余的行数个数)。理解这个形成过程后，我们只需要把这个形成过用代码实现即可。</p><p>具体<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="comment">// 构建二维数组（这里使用的StringBuilder是Java面试时的一个考点，可以查看String、StringBuffer和StringBuilder的区别）</span></span><br><span class="line">        StringBuilder[] sb = <span class="keyword">new</span> StringBuilder[numRows];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numRows; i++)&#123;</span><br><span class="line">            sb[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, len = arr.length;</span><br><span class="line">        <span class="comment">// 遍历原始数组，构建Z字形二维数组</span></span><br><span class="line">        <span class="keyword">while</span>(index &lt; len)&#123;</span><br><span class="line">            <span class="comment">// 垂直添加元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numRows &amp;&amp; index &lt; len; i++)&#123;</span><br><span class="line">                sb[i].append(arr[index++]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 斜右向添加元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=numRows-<span class="number">2</span>; i&gt;=<span class="number">1</span> &amp;&amp; index &lt; len; i--)&#123;</span><br><span class="line">                sb[i].append(arr[index++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将除第0行以外的行有序拼接到第0行后面</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;numRows; i++)&#123;</span><br><span class="line">            sb[<span class="number">0</span>].append(sb[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/19/LeetCode-6-Z字形变换/提交结果.png" title="图3.提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A6_ZigZagConversion.java" target="_blank" rel="noopener">LeetCode-6 Z字形变换</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode.com/problems/zigzag-conversion/discuss/3403/Easy-to-understand-Java-solution" target="_blank" rel="noopener">6.Z字形变换</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：6. Z字形变换&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：字符串遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-5 最长回文子串</title>
    <link href="http://JacobLei.github.io/2019/05/13/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://JacobLei.github.io/2019/05/13/LeetCode-5-最长回文子串/</id>
    <published>2019-05-13T13:02:42.000Z</published>
    <updated>2019-05-13T14:55:40.210Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：5. 最长回文子串</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第5题<strong>最长回文子串</strong>，这是一个字符串的中等题，像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。你可以假设<code>s</code>的最大长度为1000。</p><p>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure></p><p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>读完这道题后，我们发现一个新名词<strong>回文子串</strong>，什么是回文子串？首先我们先理解什么是<strong>回文串</strong>，就是从左向右读和从右向左读的结果是一样的字符串，如’abcba’。回文子串就是在给定字符串中寻找回文串。我们想想该如何寻找？</p><p>最简单直观的方法是遍历字符串，遍历的时候以每个字符为中心向左右两侧扩散。如图1所示。<br><img src="/2019/05/13/LeetCode-5-最长回文子串/查找回文子串示意图.png" title="图1.查找回文子串示意图"></p><p>聪明的小伙伴们已经发现了上述解题思路对回文子串长度为偶数就不适用了，如示例2用上图的方法分析出来的结果就不正确。那该怎么办呢？解决办法很简单，对于奇数，我们以该字符为中心向两边扩散；对于偶数，我们以该字符和下一个字符作为中心字符，然后向两边扩散。具体见下面<code>java</code>代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">// 回文子串为奇数时，查找最长回文子串</span></span><br><span class="line">            extendPalindrome(s, i, i);</span><br><span class="line">            <span class="comment">// 回文子串为偶数时，查找最长回文子串</span></span><br><span class="line">            extendPalindrome(s, i, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extendPalindrome</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否为回文子串，若是，则左指针向左移动，右指针向右移动</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回文子串查找完成后，判断刚刚查找的回文子串是否为最长回文子串，若是，则更新起始位置和最长长度</span></span><br><span class="line">        <span class="keyword">if</span>(maxLen &lt; right-left-<span class="number">1</span>)&#123;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">            maxLen = right -left - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/13/LeetCode-5-最长回文子串/提交结果.png" title="图2.提交结果"><p>整个算法流程的时间复杂度为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。</p><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A5_LongestPalindromicSubstring.java" target="_blank" rel="noopener">LeetCode-5 最长回文子串</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode.com/problems/longest-palindromic-substring/discuss/2928/Very-simple-clean-java-solution" target="_blank" rel="noopener">5.最长回文子串</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：5. 最长回文子串&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-4 寻找两个有序数组的中位数</title>
    <link href="http://JacobLei.github.io/2019/05/12/LeetCode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://JacobLei.github.io/2019/05/12/LeetCode-4-寻找两个有序数组的中位数/</id>
    <published>2019-05-12T11:56:22.000Z</published>
    <updated>2019-05-12T15:06:10.015Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：4. 寻找两个有序数组的中位数</li><li>难度：困难</li><li>分类：数组</li><li>解决方案：二分查找、分治算法<a id="more"></a></li></ul><p>今天我们学习第4题<strong>寻找两个有序数组的中位数</strong>，这是我们遇到的第一个困难题。这个题目很新颖，需要打破常规思维去思考。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">题目描述</a></h1><p>给定两个大小为<code>m</code>和<code>n</code>的有序数组<code>nums1</code>和<code>nums2</code>。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为<code>O(log(m + n))</code>。<br>你可以假设<code>nums1</code>和<code>nums2</code>不会同时为空。<br>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure></p><p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>从题目可以知道，需要让我们在两个有序数组中找中位数。我们先分析一个有序数组的中位数，当有序数组的个数为奇数时，如<code>nums=[1, 2, 3, 4, 5]</code>，该数组的中位数为<code>nums[2]=3</code>；当有序数组的个数为偶数时，如<code>nums=[1, 2, 3, 4, 5, 6]</code>，该数组的中位数为<code>(nums[2]+nums[3])/2=3.5</code>。如图1所示，我们用同一公式可求出任意个数有序数组的中位数。<br><img src="/2019/05/12/LeetCode-4-寻找两个有序数组的中位数/中位数求解思路.png" title="图1.中位数求解思路"></p><p>理解一个有序数组中位数求解过程后，对于两个有序数组来说，我们只要找出第<code>(m+n+1)/2</code>大的数和第<code>(m+n+2)/2</code>大的数，然后求平均数即可。注意这里的第<code>(m+n+1)/2</code>大的数中<code>m</code>和<code>n</code>分别指两个数组的大小，<code>m+n</code>如图1中的<code>muns.length</code>，第<code>(m+n+1)/2</code>大的数是指我们假设这两个数组组合成一个有序数组后找出第<code>(m+n+1)/2</code>大的数（这里为什么没有像图1中进行减1？因为我们这里说的第几大的数下标是从1开始的；而图1中需要减1是因为使用的数组，下标是从0开始的）。</p><p>接下来我们在这两个有序数组中找到第<code>(m+n+1)/2</code>大的数和第<code>(m+n+2)/2</code>大的数，抽象后可表述为在两个有序数组中找第k大的数。由于题目要求我们的时间复杂度为<code>O(log(m+n))</code>，我们很容易联想到二分查找。当查找时，我们还需要考虑一些特殊情况：(1) 当某个数组查找的起始位置大于等于该数组长度时，说明这个数组中的所有数已经被淘汰，则只需要在另一个数组找查找即可。(2)如果<code>k=1</code>时，即需要查找第一个数，则找到两个数组起始位置中最小的那个即可。处理完特殊情况后，我们来分析一般情况。这里所说的二分是指对数组的大小进行二分还是指对<code>k</code>进行二分。以前我们对一维数组进行二分查找时，一般都是对数组大小进行二分，而这里需要对<code>k</code>进行二分。意思是，我们需要在两个数组查找第<code>k/2</code>大的数，由于这两个数组的长度不定，有可能存在有一个数组中没有第<code>k/2</code>大的数，如果没有则赋值为整型最大值。对于查找的具体过程，详见<code>java</code>代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length, n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> l = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> r = (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, l) + getKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, r)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在两个有序数组中二分查找第k大元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况(1)，分析见正文部分</span></span><br><span class="line">        <span class="keyword">if</span>(start1 &gt; nums1.length-<span class="number">1</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(start2 &gt; nums2.length-<span class="number">1</span>) <span class="keyword">return</span> nums1[start1 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 特征情况(2)，分析见正文部分</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分别在两个数组中查找第k/2个元素，若存在（即数组没有越界），标记为找到的值；若不存在，标记为整数最大值</span></span><br><span class="line">        <span class="keyword">int</span> nums1Mid = start1 + k/<span class="number">2</span> - <span class="number">1</span> &lt; nums1.length ? nums1[start1 + k/<span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> nums2Mid = start2 + k/<span class="number">2</span> - <span class="number">1</span> &lt; nums2.length ? nums2[start2 + k/<span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确定最终的第k/2个元素，然后递归查找</span></span><br><span class="line">        <span class="keyword">if</span>(nums1Mid &lt; nums2Mid)</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1 + k/<span class="number">2</span>, nums2, start2, k-k/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1, nums2, start2 + k/<span class="number">2</span>, k-k/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/12/LeetCode-4-寻找两个有序数组的中位数/提交结果.png" title="提交结果"><p>整个算法流程的时间复杂度为<code>O(log(m+n))</code>，空间复杂度为<code>O(1)</code>。</p><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A4_MedianofTwoSortedArrays.java" target="_blank" rel="noopener">LeetCode-4 寻找两个有序数组的中位数</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2496/Concise-JAVA-solution-based-on-Binary-Search" target="_blank" rel="noopener">4. 寻找两个有序数组的中位数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：4. 寻找两个有序数组的中位数&lt;/li&gt;
&lt;li&gt;难度：困难&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：二分查找、分治算法
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-3 无重复字符的最长子串</title>
    <link href="http://JacobLei.github.io/2019/05/10/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://JacobLei.github.io/2019/05/10/LeetCode-3-无重复字符的最长子串/</id>
    <published>2019-05-10T11:41:20.000Z</published>
    <updated>2019-05-12T11:53:36.832Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：3. 无重复字符的最长子串</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：双指针、滑动窗口</li></ul><a id="more"></a><p>LeetCode前几道题都是经典题，今天我们学习第3题<strong>无重复字符的最长子串</strong>，这道题在秋招面试中遇见过，再次相遇，如此亲切。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个字符串，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。<br>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure></p><p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure></p><p>示例3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先我们看看这个题的示例3，该示例中提示我们这个题需要求的字符串的<strong>子串</strong>而不是<strong>子序列</strong>，我们具体来看看什么是子串，什么是子序列。</p><blockquote><p>子串：字符串中任意个<strong>连续</strong>的字符组成的子序列称为该串的子串。注意子串强调字符的连续性。<br><img src="/2019/05/10/LeetCode-3-无重复字符的最长子串/子串.png" title="子串"><br>子序列：字符串中去掉任意个元素后得到的结果即为该字符串的子序列。注意子序列中字符出现的次序与原字符串中字符出现的次序要保持一致。<br><img src="/2019/05/10/LeetCode-3-无重复字符的最长子串/子序列.png" title="子序列"></p></blockquote><p>区分子串和子序列后，我们再回过头来看看这个题。我们先动手画一画示例1的解题过程，如下图所示：<br><img src="/2019/05/10/LeetCode-3-无重复字符的最长子串/示例1分析过程.png" title="示例1分析过程"><br>从上图我们可以观察出，可以使用双指针（<code>left</code>指针和<code>right</code>指针）来维护一个滑动窗口，这个窗口内的字符都是没有重复的，遍历一趟字符串后就可以得到最大的子串，因此时间复杂度为<code>O(n)</code>。现在想一个问题：<strong><code>right</code>指针指向的字符怎么确定它在前面是否出现过，若出现过，它出现的位置在哪儿？</strong>对于这个问题，做过<a href="https://www.jacob2359.com/2019/05/04/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/#more" target="_blank" rel="noopener">LeetCode-1 两数之和</a>这道题的小伙伴们应该知道，我们可以使用<code>HashMap</code>记录一个字符是否出现以及出现后的位置。对于重复多次出现的字符，我们是保留所有出现的位置还是只记录一个位置？观察示例1分析过程可以知道，我们只需要保存一个最大位置即可。还有一个关键点，我们如何确定<code>left</code>指针的位置？这一点非常重要，需要分情况讨论。</p><ul><li>当目前<code>right</code>指针指向的字符未出现过，<code>left</code>指针不需要移动；</li><li>当目前<code>right</code>指针指向的字符出现过，如果该字符在窗口中，即该字符出现在当前<code>left</code>指针的右边，则通过<code>HashMap</code>获取字符的位置并向右移动一位即为更新后<code>left</code>的位置；如果该字符在窗口外面，即在当前<code>left</code>指针的左边，则不需要移动<code>left</code>的位置。<br>分析完后，再看看<code>java</code>代码的具体实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 创建HashMap，用来保存字符与位置之间的对应关系</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化左指针和右指针，并遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.length(); right++)&#123;</span><br><span class="line">            <span class="comment">// 判断右指针指向的字符是否出现过</span></span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                <span class="comment">// 确定左指针的位置</span></span><br><span class="line">                left = Math.max(left, hashMap.get(s.charAt(right))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于第一次出现的字符，保存该字符的位置；对于多次出现的字符，更新该字符出现的位置</span></span><br><span class="line">            hashMap.put(s.charAt(right), right);</span><br><span class="line">            <span class="comment">// 更新窗口的大小，保存最大的窗口大小</span></span><br><span class="line">            res = Math.max(res, right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><img src="/2019/05/10/LeetCode-3-无重复字符的最长子串/提交结果.png" title="提交结果"><p>整个算法流程的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>。</p><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A3_LongestSubstringWithoutRepeatingCharacters.java" target="_blank" rel="noopener">LeetCode-3 无重复字符的最长子串</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：3. 无重复字符的最长子串&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：双指针、滑动窗口&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-2 两数相加</title>
    <link href="http://JacobLei.github.io/2019/05/09/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://JacobLei.github.io/2019/05/09/LeetCode-2-两数相加/</id>
    <published>2019-05-09T14:33:36.000Z</published>
    <updated>2019-05-12T11:53:21.944Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：2. 两数相加</li><li>难度：中等</li><li>分类：链表</li><li>解决方案：链表的遍历</li></ul><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">题目描述</a></h1><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>注意：您可以假设除了数字0之外，这两个数都不会以0开头。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题理解起来难度不大，就是将数字从个位数开始将数字放到链表的各个结点上，如下所示：<br><img src="/2019/05/09/LeetCode-2-两数相加/链表表示数字.png" title="链表表示数字"><br>然后两个链表的对应位置上的数字相加，将相加的值保存到结果链表中。这里需要注意两个关键点：一是如果两个值相加大于9该怎么办？二是两个链表长度不一致该怎么办？<br>对于关键点一：我们需要借助一个进位标识<code>carry</code>，当两数之和大于9时将<code>carry</code>标识为1，否则标识为0。<br>对于关键点二：我们以最长链表作为终点，对于较短链表对应位置的数值，我们用0来补齐。<br>下面分析一个具体实例，该实例包含上述两个关键点，如下图所示：<br><img src="/2019/05/09/LeetCode-2-两数相加/两数相加.png" title="两数相加"><br>如上图所示，数字342的链表较短，数字7465的链表较长。当两个数字的第二个结点相加时，它们的和为10，这时就需要进位，即<code>carry=1</code>，且将个位数保留作为结果链表的值。当较短的链表指向为<code>null</code>结点时，较长的链表指向的值为7，这需要将较短链表的值设置为0，即结果为0+7。<br>通过上面分析后，再看看如下<code>java</code>便一目了然。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建结果链表的头节点，默认该节点中的value为-1</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="comment">// 进位标识carry，默认为0</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历链表，当两个链表都为空时，退出</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 判断该节点是否为空，当结点为空时，用0补齐；不为空时，加数即为节点的值</span></span><br><span class="line">            <span class="keyword">int</span> d1 = (l1 == <span class="keyword">null</span>) ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> d2 = (l2 == <span class="keyword">null</span>) ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="comment">// 对结点求和，注意：求和是需要考虑到进位</span></span><br><span class="line">            <span class="keyword">int</span> sum = d1 + d2 + carry;</span><br><span class="line">            <span class="comment">// 更新进位标识</span></span><br><span class="line">            carry = (sum &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// sum%10标识求和的个位数，将其保存到结果链表中</span></span><br><span class="line">            pre.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重点，这是一个特殊情况，当两个链表计算完后，</span></span><br><span class="line">        <span class="comment">// 还需要判断进位标识是否为1，如果为1，如23+81=104，需要创建一个结点保存最高位</span></span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)</span><br><span class="line">            pre.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/09/LeetCode-2-两数相加/两数相加计算结果.png" title="两数相加计算结果"><p>对于时间复杂度和空间复杂度，该题都为O(n)。</p><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A2_AddTwoNumbers.java" target="_blank" rel="noopener">LeetCode-2 两数相加</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/" target="_blank" rel="noopener">2. 两数之和</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：2. 两数相加&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：链表&lt;/li&gt;
&lt;li&gt;解决方案：链表的遍历&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[spring实战]1-自动化装配bean</title>
    <link href="http://JacobLei.github.io/2019/05/04/spring%E5%AE%9E%E6%88%981-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A3%85%E9%85%8Dbean/"/>
    <id>http://JacobLei.github.io/2019/05/04/spring实战1-自动化装配bean/</id>
    <published>2019-05-04T14:16:38.000Z</published>
    <updated>2019-05-04T15:33:28.277Z</updated>
    
    <content type="html"><![CDATA[<p>Spring提供三种主要的装备机制：</p><ul><li>在XML中进行显示配置</li><li>在Java中进行显示配置</li><li>隐式的bean发现机制和自动配置</li></ul><p>本章主要学习<strong>隐式的bean发现机制和自动配置</strong>，通过<strong>音响系统</strong>的各个组件来说明<code>Spring</code>是如何隐式的bean发现机制和自动配置。首先创建一个<code>CD</code>接口，<code>Spring</code>会发现它并将其创建一个<code>bean</code>；然后会创建一个<code>CDPlayer</code>类，让<code>Spring</code>发现它并将<code>CD bean</code>注入进来。</p><a id="more"></a><p><code>Spring</code>从两个角度来实现自动化装备：</p><ul><li>组件扫描(component scanning)：<code>Spring</code>会自动发现<code>ApplicationContext</code>中所创建的<code>bean</code></li><li>自动装配(autowiring)：<code>Spring</code>自动满足<code>bean</code>之间的依赖</li></ul><h1 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean"></a>创建<code>bean</code></h1><h2 id="创建CD接口和PianoCD类"><a href="#创建CD接口和PianoCD类" class="headerlink" title="创建CD接口和PianoCD类"></a>创建<code>CD</code>接口和<code>PianoCD</code>类</h2><p>首先创建<code>CD</code>接口，具体代码如下所示：<br><code>CD.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jacob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CD</code>中不需要具体实现，它只需要定义所能进行的操作，其具体实现类根据具体需求创建。如现在有个钢琴CD的具体实现<code>PianoCD</code>，其代码如下所示：<br><code>PianoCD.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jacob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PianoCD</span> <span class="keyword">implements</span> <span class="title">CD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"this is PianoCD!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建<code>PianoCD</code>类是，使用了<code>@Component</code>注解，该注解表明<code>PianoCD</code>类会作为<strong>组件类</strong>，并告知<code>Spring</code>为这个类创建<code>bean</code>，因此不需要显示配置<code>bean</code>。</p><h2 id="开启组件扫描"><a href="#开启组件扫描" class="headerlink" title="开启组件扫描"></a>开启组件扫描</h2><p>组件扫描(ComponentScan)默认是关闭的，需要显示的配置<code>Spring</code>，命令它去寻找带有了<code>@Component</code>注解的类，并为其创建<code>bean</code>。具体代码如下所示：<br><code>CDPlayerConfig.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jacob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CDPlayerConfig</code>类通过<code>java</code>代码定义了<code>Spring</code>的装配规则。该类中没有任何显示地声明任何<code>bean</code>，通过使用<code>@ComponentScan</code>注解来开启组件扫描。<code>@ComponentScan</code>注解默认会扫描与配置类相同的包。因为<code>CDPlayerConfig</code>在<code>com.jacob</code>包中，因此<code>Spring</code>将扫描该包以及该包下所有子包，查找带有<code>@Component</code>的类，然后为该类在<code>Spring</code>中自动创建一个<code>bean</code>。</p><h2 id="测试组件扫描功能"><a href="#测试组件扫描功能" class="headerlink" title="测试组件扫描功能"></a>测试组件扫描功能</h2><p>创建<code>JUnit</code>测试，它会创建<code>Spring</code>的<code>Context</code>，并判断<code>CD</code>是不是真的创建出来。具体代码如下所示：<br><code>CDPlayerTest.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jacob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertNotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = CDPlayerConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CD cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotBeNull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CDPlayerTest</code>使用<code>Spring</code>的<code>SpringJUnit4ClassRunner</code>，以便在测试开始的时候自动创建<code>Spring</code>的<code>ApplicationContext</code>。<code>@ContextConfiguration</code>会告诉<code>CDPlayerTest</code>在需要在<code>CDPlayerConfig</code>中加载配置。因为<code>CDPlayerConfig</code>中包含<code>@ComponentScan</code>，因此最终的<code>ApplicationContext</code>包含<code>CD bean</code>。</p><p>为了证明<code>ApplicationContext</code>包含<code>CD bean</code>， 在测试代码中使用<code>CD</code>类型的属性，且在这个属性中添加<code>@Autowired</code>注解，以便将<code>CD</code>注入到测试代码中。最后通过断言判断<code>cd</code>属性不为<code>null</code>。</p><blockquote><p>注意：在创建测试代码过程中，出现如图问题：<img src="/2019/05/04/spring实战1-自动化装配bean/CDPlayerTest错误.png" title="CDPlayerTest错误示意图"><br>图中的主要原因是<code>junit</code>的版本过低，在<code>pom.xml</code>文件中<code>junit</code>依赖的改为4.12及其以上即可。</p></blockquote><img src="/2019/05/04/spring实战1-自动化装配bean/CDPlayerTest测试通过.png" title="CDPlayerTest测试通过示意图"><h1 id="为组件扫描的bean命名"><a href="#为组件扫描的bean命名" class="headerlink" title="为组件扫描的bean命名"></a>为组件扫描的bean命名</h1><p><code>Spring</code>中的<code>ApplicationContext</code>所有的<code>bean</code>都会有一个<code>ID</code>。如<code>PianoCD</code>中我们没有设置其对应<code>bean</code>的<code>ID</code>，这时<code>Spring</code>会默认指定其<code>ID</code>为<code>pianoCD</code>。有些情况，我们需要自定义<code>bean</code>的<code>ID</code>，可以通过<code>@Component</code>注解来实现，具体如下代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"myLoveCD"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PianoCD</span> <span class="keyword">implements</span> <span class="title">CD</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="设置组件扫描-ComponentScan-的基础包"><a href="#设置组件扫描-ComponentScan-的基础包" class="headerlink" title="设置组件扫描(@ComponentScan)的基础包"></a>设置组件扫描(<code>@ComponentScan</code>)的基础包</h1><p><code>@ComponentScan</code>默认情况下扫描配置类所在的包（基础包，base package）中的组件，有时需要扫描不同的包，有时需要扫描多个包，该如何处理？<br>为了将配置代码与应用代码分离开，一般配置类单独放<code>config</code>包中，这时需要我们明确设置基础包，可以通过指定<code>@ComponentScan</code>中的<code>value</code>属性值来设置需要扫描的基础包。具体代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value=<span class="string">"com.jacob"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果需要扫描多个包，具体代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages=&#123;<span class="string">"package1"</span>, <span class="string">"package2"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="通过为bean添加注解实现自动装配"><a href="#通过为bean添加注解实现自动装配" class="headerlink" title="通过为bean添加注解实现自动装配"></a>通过为<code>bean</code>添加注解实现自动装配</h1><p>自动装配是让<code>Spring</code>自动满足<code>bean</code>依赖的一种方法，在满足依赖的过程中，会在<code>ApplicationContext</code>中寻找匹配某个<code>bean</code>需要的其他<code>bean</code>。一般是通过<code>@Autowired</code>注解来实现自动装配。如下代码所示：<br><code>CDPlayer.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jacob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CD cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CD cd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cd = cd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cd.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CDPlayer</code>中在构造器上添加<code>@Autowired</code>注解，表明当<code>Spring</code>创建<code>CDPlayer bean</code>时，会通过这个构造器来进行实例化并且会传入<code>CD</code>类型的<code>bean</code>。<br><code>@Autowired</code>注解类可以在任何方法上使用。例如<code>CDPlayer</code>有一个<code>setCD()</code>方法，那么可以采用如下的注解形式进行自动装配：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@`<span class="meta">@Autowired</span>`</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCD</span><span class="params">(CD cd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cd = cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在自动装配时，如果没有匹配的<code>bean</code>，那么在创建<code>ApplicationContext</code>时会抛异常。可以通过<code>@Autowired(required=false)</code>来避免抛异常，这时<code>Spring</code>将这个<code>bean</code>置为未装配状态。在代码中需要进行<code>null</code>检查来判断<code>bean</code>是否装配成功。如果没有<code>null</code>检查，未装配的<code>bean</code>会抛出<code>NullPointerException</code>。</p><h1 id="验证自动装配"><a href="#验证自动装配" class="headerlink" title="验证自动装配"></a>验证自动装配</h1><p>我们在<code>CDPlayer</code>中在构造器上添加<code>@Autowired</code>注解，<code>Spring</code>会将一个可分配的<code>CD</code>类型的<code>bean</code>自动注入进来（该实验项目中为<code>PianoCD bean</code>）。接下来测试是否注入成功，修改<code>CDPlayerTest</code>如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jacob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.junit.contrib.java.lang.system.StandardOutputStreamLog;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertNotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = CDPlayerConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> StandardOutputStreamLog log = <span class="keyword">new</span> StandardOutputStreamLog();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer player;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CD cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotBeNull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        player.play();</span><br><span class="line">        assertEquals(</span><br><span class="line">                <span class="string">"this is PianoCD!!!"</span>,</span><br><span class="line">                log.getLog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/04/spring实战1-自动化装配bean/验证自动装配测试结果.png" title="验证自动装配测试结果示意图"><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://item.jd.com/11899370.html" target="_blank" rel="noopener">Spring实战（第四版）</a></p><blockquote><p>声明：本文为学习《Spring实战（第四版）》所作学习笔记，一切版权归该书所有。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring提供三种主要的装备机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在XML中进行显示配置&lt;/li&gt;
&lt;li&gt;在Java中进行显示配置&lt;/li&gt;
&lt;li&gt;隐式的bean发现机制和自动配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本章主要学习&lt;strong&gt;隐式的bean发现机制和自动配置&lt;/strong&gt;，通过&lt;strong&gt;音响系统&lt;/strong&gt;的各个组件来说明&lt;code&gt;Spring&lt;/code&gt;是如何隐式的bean发现机制和自动配置。首先创建一个&lt;code&gt;CD&lt;/code&gt;接口，&lt;code&gt;Spring&lt;/code&gt;会发现它并将其创建一个&lt;code&gt;bean&lt;/code&gt;；然后会创建一个&lt;code&gt;CDPlayer&lt;/code&gt;类，让&lt;code&gt;Spring&lt;/code&gt;发现它并将&lt;code&gt;CD bean&lt;/code&gt;注入进来。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://JacobLei.github.io/categories/Spring/"/>
    
      <category term="Spring in action" scheme="http://JacobLei.github.io/categories/Spring/Spring-in-action/"/>
    
    
      <category term="Spring" scheme="http://JacobLei.github.io/tags/Spring/"/>
    
      <category term="Spring in action" scheme="http://JacobLei.github.io/tags/Spring-in-action/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1 两数之和</title>
    <link href="http://JacobLei.github.io/2019/05/04/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://JacobLei.github.io/2019/05/04/LeetCode-1-两数之和/</id>
    <published>2019-05-04T04:09:36.000Z</published>
    <updated>2019-05-11T08:53:30.832Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：1. 两数之和</li><li>难度：简单</li><li>分类：数组，哈希表</li><li>解决方案：暴力求解、<code>HashMap</code></li></ul><a id="more"></a><p>从今天开始开启《LeetCode解题报告》系列文章，希望能够坚持下来。今天我们来学习第1题两数之和，既然放在首位，可见该题的重要性。这个在笔试中出现的概率非常大，希望大家在面试前能够手写出来。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个整数数组<code>nums</code>和一个目标值<code>target</code>，请你在该数组中找出和为目标值的那 两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><strong>两数之和</strong>可称为经典的面试题，曾经百度实习面试时手写过该代码，也在秋招电话面试时面到该题。这个题最基本的思路是使用两次<code>for</code>循环，但时间复杂度为<code>O(n^2)</code>，<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = target - nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == tmp &amp;&amp; j != i)&#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i;</span><br><span class="line">                    res[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/04/LeetCode-1-两数之和/两次for循环提交结果.jpg" title="两次for循环提交结果"><p>虽然在LeetCode或面试中能够解答出来，但是该方法的时间复杂度过高，需要进一步优化。我们发现题目中的数组是无序的（虽然示例中的数组有序的，但这只是一个特列，测试用例中并不是所有的数组都是有序的），当数组如果是<strong>有序</strong>的，然后再去查找是否能更加方便？一个很重要的问题，<strong>该题中需要返回的是数组下标，因此不能破坏数组中的位置关系</strong>。如果将数组进行排序，则会破坏数组的位置关系，不能满足题目要求。如何<strong>将数组的值与数组的位置关系进行绑定</strong>，是这个题目的解题关键。这样很容易想到<code>k-v</code>结构，在<code>java</code>中可以通过<code>HashMap</code>来实现。具体思路如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 遍历数组建立HashMap映射，其中HashMap中的key为数组的值，value为数组的位置，即&lt;nums[i], i&gt;;</span><br><span class="line">2. 查找是否存在两个数之和等于target：</span><br><span class="line">2.1 遍历数组，得到第一个数字nums[i]，记为num1，该数字在数组中的位置为i</span><br><span class="line">2.2 计算target-nums[i]，计算结果为另一个需要的数字num2，若该数字存在，该数字在数组中的位置为hasmMap.get(num2)</span><br><span class="line">2.3 在HashMap中判断num2是否存在：</span><br><span class="line">若不存在，则跳转至2.1</span><br><span class="line">若存在，则判断num1与num2对应的value是否相等：</span><br><span class="line">若相等，则跳转至2.1</span><br><span class="line">若不相等，则找到这两个数num1+num2==target，返回对应的数组位置</span><br></pre></td></tr></table></figure></p><p><code>java</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 建立HashMap映射</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 查找是否存在两个数之和等于target</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tmp) &amp;&amp; map.get(tmp) != i)&#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                res[<span class="number">1</span>] = map.get(tmp);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/04/LeetCode-1-两数之和/HashMap方法提交结果.jpg" title="HashMap方法提交结果"><p>整个算法流程是时间复杂度为<code>O(n)</code>，由于使用了<code>HashMap</code>申请了内存空间，其空间复杂度为<code>O(n)</code>。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：1. 两数之和&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：数组，哈希表&lt;/li&gt;
&lt;li&gt;解决方案：暴力求解、&lt;code&gt;HashMap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题宝典</title>
    <link href="http://JacobLei.github.io/2019/05/03/LeetCode%E5%88%B7%E9%A2%98%E5%AE%9D%E5%85%B8/"/>
    <id>http://JacobLei.github.io/2019/05/03/LeetCode刷题宝典/</id>
    <published>2019-05-03T09:46:31.000Z</published>
    <updated>2019-05-21T04:39:45.985Z</updated>
    
    <content type="html"><![CDATA[<p>聊聊如何刷LeetCode</p><a id="more"></a><p>对于LeetCode，我相信计算机专业或相关专业的同学都有所耳闻。在找工作时，常常听到某某大神刷了2遍LeetCode最后拿到9个offer等等传说。可见LeetCode的重要性。下面我们聊一聊该怎么去刷LeetCode。</p><p>首先简单了解一下传说中的<a href="https://leetcode.com" target="_blank" rel="noopener">LeetCode</a>，它其实就是美国在线编程网站，上面收集了各大IT公司的笔试题和面试题，对于要找工作的小伙伴来说，LeetCode是一个不可多得的好帮手。Wait~~<strong>美国在线编程网站</strong>？？？全英文？？？其实不是这样的，LeetCode也有相应的中文网站——<a href="https://leetcode-cn.com" target="_blank" rel="noopener">力扣</a>，对英文刷题吃力的小伙伴们赶紧收藏。对于哪些人适合刷LeetCode？我认为从事编程工作的人员都应该去刷，不论是已经工作的”程序猿”还是在校学生，特别是将要找工作或找实习的在校学生是最需要刷LeetCode，如果想进大厂，必须得刷LeetCode。</p><p>那么，该如何去刷呢？我们先来看一看LeetCode网站，如下图1所示。<br><img src="/2019/05/03/LeetCode刷题宝典/力扣首页.png" title="图1.力扣首页"></p><p>注册并登陆后我们进入题库界面，如图2所示，选择标签和难度。<br><img src="/2019/05/03/LeetCode刷题宝典/力扣问题页.png" title="图2.力扣问题页"><br>到目前为止，总共右39个标签，我们可以按标签来刷题，比如我们今天做<strong>栈</strong>，我们先在标签页中选择栈，然后再选择适当难度，就可以开始做题了。</p><p>一般建议对于一个标签，我们先做2~3到简单题，熟悉其基本的算法思路后，然后做中等题，做了5~8道中等题后再去挑战困难题。读于刚刚开始接触某一个标签题型时，很难自己想出题目的求解答案，这时候一定不要灰心。<strong>对于一道题思考5分钟后如果还没有解题思路，我们可以去看该题目相关博客（如公众号：jacob2359 或 <a href="https://www.jacob2359.com/categories/LeetCode/" target="_blank" rel="noopener">jacob2359的博客</a>）或者查看该题目的讨论部分（讨论部分建议看英文网站上的）</strong>。查看该题的讨论部分具体方法如图3-4所示。<br><img src="/2019/05/03/LeetCode刷题宝典/leetcode讨论页.png" title="图3.leetcode讨论页"><br><img src="/2019/05/03/LeetCode刷题宝典/leetcode讨论页2.png" title="图4.leetcode讨论页"></p><p>通过查看博客和讨论部分后对该题有基本思路，我们再去做这道题。对于同一类标签的题做多后，我们对这一类标签的题就会熟悉，下次遇到同样主题的题目就不会完全没有思路。</p><p>对于有些小伙伴没有数据结构基础，推荐先看陈越老师和何钦铭老师的《数据结构》课程，也可以查看《算法 ：LeetCode刷题》，相关课程的资源，可扫一扫下方二维码，关注公众号，发送『 算法资源』即可获取。</p><p>对于有些小伙伴纠结使用什么语言的问题，其实完全不用纠结，使用一门你熟悉的语言即可。如果一门都不熟悉，推荐使用Java来刷题。</p><p>最后也是最重要的，一定要坚持，坚持每天都刷题，遇到难题后不要灰心，静下心来看看别人的解题思路，看懂后自己再总结，要相信自己一定可以把它弄懂的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;聊聊如何刷LeetCode&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="学习方法" scheme="http://JacobLei.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
</feed>
