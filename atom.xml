<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jacob2359</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://JacobLei.github.io/"/>
  <updated>2019-06-11T07:27:46.603Z</updated>
  <id>http://JacobLei.github.io/</id>
  
  <author>
    <name>jacob2359</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-79 单词搜索</title>
    <link href="http://JacobLei.github.io/2019/10/11/LeetCode-79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <id>http://JacobLei.github.io/2019/10/11/LeetCode-79-单词搜索/</id>
    <published>2019-10-11T04:44:17.000Z</published>
    <updated>2019-06-11T07:27:46.603Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：79. 单词搜索</li><li>难度：中等</li><li>分类：数组</li><li>解决方案：DFS、回溯算法<a id="more"></a></li></ul><p>今天我们学习第79题<strong>单词搜索</strong>，这个题目是一个典型的DFS，经常出现笔试中，最好要熟练掌握。我们先看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = &quot;ABCCED&quot;, 返回 true.</span><br><span class="line">给定 word = &quot;SEE&quot;, 返回 true.</span><br><span class="line">给定 word = &quot;ABCB&quot;, 返回 false.</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题目是让我们在一个二维网格中通过给定的规则进行搜索word是否存在，是一个典型的深度优先遍历（DFS）的应用。</p><p>对于二维网格中的每一个字符，如果该字符是word对应查找的字符，我们接下来继续判断网格中的该字符的上下左右字符是否为word对应的下一个字符，直到匹配完成。对于示例的详细分析过程如下：<br><img src="/2019/10/11/LeetCode-79-单词搜索/示例详细分析过程.png" title="示例详细分析过程"></p><p>对于上述分析不难，难点在于如何实现对搜索过程中的判断，这里涉及到DFS和回溯算法，对这个知识点不太清楚的小伙伴可以扫描文章下方的二维码，关注『 算法半岛』回复『 数据结构目录』，即可获得相关学习资料。</p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 申请并初始化visited数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从二维网格的左上角开始于word的首字符进行判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, <span class="number">0</span>, i, j, visited))  <span class="comment">// 判断函数</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> idx, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当单词判断结束后，直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(idx == word.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 边界条件处理</span></span><br><span class="line">        <span class="comment">// 或字符已经访问处理</span></span><br><span class="line">        <span class="comment">// 或word中的字符与二维网格中的字符不相等 直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols </span><br><span class="line">           || visited[i][j]</span><br><span class="line">           || word.toCharArray()[idx] != board[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// word中的字符与二维网格中的字符相等即修改visited对应位置为true</span></span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断word下一个字符与二维网格中已判断的字符的上下左右四个相邻字符是否有一个相等的字符</span></span><br><span class="line">        <span class="comment">// 如果相等，则继续进入深度遍历进行判断</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board, word, idx+<span class="number">1</span>, i-<span class="number">1</span>, j, visited)</span><br><span class="line">                    || dfs(board, word, idx+<span class="number">1</span>, i+<span class="number">1</span>, j, visited)</span><br><span class="line">                    || dfs(board, word, idx+<span class="number">1</span>, i, j-<span class="number">1</span>, visited)</span><br><span class="line">                    || dfs(board, word, idx+<span class="number">1</span>, i, j+<span class="number">1</span>, visited);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果不相等，回溯</span></span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/10/11/LeetCode-79-单词搜索/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A79_WordSearch.java" target="_blank" rel="noopener">LeetCode-79 单词搜索</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">单词搜索</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：79. 单词搜索&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：DFS、回溯算法
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="DFS" scheme="http://JacobLei.github.io/tags/DFS/"/>
    
      <category term="回溯算法" scheme="http://JacobLei.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-平衡二叉查找树</title>
    <link href="http://JacobLei.github.io/2019/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://JacobLei.github.io/2019/09/07/数据结构与算法-红黑树/</id>
    <published>2019-09-07T10:14:13.000Z</published>
    <updated>2019-09-07T11:14:48.204Z</updated>
    
    <content type="html"><![CDATA[<p>本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。</p><a id="more"></a><p>在学习完二叉查找树后我们了解到它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度为<code>O(logn)</code>。但是随着对二叉查找树的不断更新，树的高度可能远大于<code>O(logn)</code>从而导致操作效率的下降。当二叉查找树只有左子树或只有右子树时，二叉查找树退化成为链表，时间复杂度为<code>O(n)</code>。为了避免解决上述问题，我们学习<strong>平衡二叉查找树</strong>。</p><h1 id="什么是平衡二叉查找树"><a href="#什么是平衡二叉查找树" class="headerlink" title="什么是平衡二叉查找树"></a>什么是平衡二叉查找树</h1><p>一颗平衡二叉树要求二叉树中的每个节点的左子树和右子树的高度最多相差1。如完全二叉树、满二叉树都是平衡二叉树。如下图左边的树即为平衡二叉树，右边的树不为平衡二叉树。<br><img src="平衡二叉树与非平衡二叉树.png" alt="平衡二叉树与非平衡二叉树"></p><p>平衡二叉查找树不仅需要满足平衡的条件，而且需要满足二叉查找树的条件。最经典的平衡二叉查找树为AVL树。</p><h1 id="平衡二叉查找树的性质"><a href="#平衡二叉查找树的性质" class="headerlink" title="平衡二叉查找树的性质"></a>平衡二叉查找树的性质</h1><ul><li>左子树与右子树高度之差绝对值不超过1</li><li>树的每个左子树和右子树都是平衡二叉查找树</li><li>每个节点都有一个平衡因子，任何一个节点的平衡因子为-1、0或者1（每一个节点的平衡因子 = 右子树高度 - 左子树高度）</li></ul><h1 id="平衡二叉查找树的生成"><a href="#平衡二叉查找树的生成" class="headerlink" title="平衡二叉查找树的生成"></a>平衡二叉查找树的生成</h1><p>由于平衡二叉查找树既要保证平衡性质又要保证查找的性质，那么该如何生成一颗平衡二叉查找树呢？</p><p>由于平衡二叉查找树首先一颗二叉查找树，我们需要根据二叉查找树的规则进行插入</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="平衡二叉查找树" scheme="http://JacobLei.github.io/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>netty[1]--Java网络编程</title>
    <link href="http://JacobLei.github.io/2019/08/25/netty-1-Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://JacobLei.github.io/2019/08/25/netty-1-Java网络编程/</id>
    <published>2019-08-25T10:27:12.000Z</published>
    <updated>2019-08-25T15:39:04.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-五种IO模型"><a href="#1-五种IO模型" class="headerlink" title="1 五种IO模型"></a>1 五种IO模型</h1><p>把内存中的数据写到外部设备（硬盘、终端、网络等）上这个动作称为输出（写）<code>Output</code>操作，把外部设备的数据读取到内存中的这个动作称为输入（读）<code>Input</code>操作，我们把这种输入和输出动作称为IO操作。IO操作是操作系统的底层功能实现，一般是通过调用IO指令完成。在本系列文章中，所有的IO都是网络IO。</p><p>常见的IO模型有：阻塞式IO（blocking IO）、非阻塞式IO（nonblocking IO）、IO复用（IO multiplexing）、信号驱动式IO（signal driven IO）和异步IO（asynchronous IO）。其中前四种IO模型为同步IO，最后一种为异步IO。</p><p>对于每一种模型，一个输入操作通常包含两个不同的阶段：</p><ul><li>第一阶段：等待数据准备好；</li><li>第二阶段：将数据从内核拷贝到进程中。<br>对于一个套接字上的输入操作，第一阶段通常需要等待数据从网络中到达，当所等待的分组到达时，它被复制到内核中的某个缓冲区。第二阶段把数据从内核缓冲区复制到应用进程缓冲区。具体如下图所示：</li></ul><p><img src="数据读入.png" alt="数据读入"></p><h2 id="1-1-阻塞式IO"><a href="#1-1-阻塞式IO" class="headerlink" title="1.1 阻塞式IO"></a>1.1 阻塞式IO</h2><p>以在食堂就餐为例，当自己点了一份盖饭，然后原地等着厨师把盖饭做好，接着自己端到餐桌上就餐。这样的流程就为阻塞式IO，即当厨师给你做饭时，你需要在原地等待，而不能做其他的事情。</p><p>在网络编程中，读取客户端的数据需要调用<code>recvfrom</code>，在默认情况下，这个调用会阻塞到数据接收完成。具体流程如下图所示：<br><img src="阻塞式IO.png" alt="阻塞式IO"><br>这是最简单的IO模型，当文件描述符（fd）较少、就绪很快的情况下可以使用。</p><h2 id="1-2-非阻塞式IO"><a href="#1-2-非阻塞式IO" class="headerlink" title="1.2 非阻塞式IO"></a>1.2 非阻塞式IO</h2><p>以在食堂就餐为例，当自己点了一份盖饭，点完之后先回到桌上看一会书，然后厨师差不多将要做好盖饭后，再去问问盖饭做完了没有，如果做好了就去端了回到餐桌上就餐，如果没有没有做好再等一会在过去问，依次循环直到饭做好为止。这样的流程就是非阻塞式IO。</p><p>对于非阻塞IO，需要设置<code>socket</code>为<code>non-blocking</code>。具体流程如下图所示：<br><img src="非阻塞式IO.png" alt="非阻塞式IO"></p><h2 id="1-3-IO复用"><a href="#1-3-IO复用" class="headerlink" title="1.3 IO复用"></a>1.3 IO复用</h2><p>以在食堂就餐为例，当进入食堂后，你将你需要点的盖饭告诉服务员，服务员通知厨师去做，等盖饭做好后，服务员再过来通知你饭已经做好了，然后你再去窗口将饭端到自己的餐桌上就餐。</p><p>在网络编程中，我们一般调用<code>select</code>、<code>poll</code>或者<code>epoll</code>来等待数据报套接字变为可读，当套接字为可读时，再调用<code>recvfrom</code>把所读数据复制到应用进程缓冲区中。具体流程图如下图所示：<br><img src="IO复用.png" alt="IO复用"></p><h2 id="1-4-信号驱动式IO"><a href="#1-4-信号驱动式IO" class="headerlink" title="1.4 信号驱动式IO"></a>1.4 信号驱动式IO</h2><p>以在食堂就餐为例，当你想吃中饭时，先给食堂厨师发个短信，告诉需要一份盖饭，厨师收到短信后回复“收到，马上为你准备”；当厨师将盖饭做好后，发送一个短信告诉你盖饭已经做好了，这时你再去窗口取盖饭到餐桌上就餐。</p><p>在网络编程中，信号驱动式IO使用的比较少。具体流程图如下图所示：<br><img src="信号驱动式IO.png" alt="信号驱动式IO"></p><h2 id="1-5-异步IO"><a href="#1-5-异步IO" class="headerlink" title="1.5 异步IO"></a>1.5 异步IO</h2><p>以在食堂就餐为例，当进入食堂后，你将你需要点的盖饭告诉服务员，然后你就取餐桌等待即可；服务员通知厨师去做，等盖饭做好后，服务员将盖饭端到你餐桌。</p><p>在网络编程中，其具体流程图如下图所示：<br><img src="异步IO.png" alt="异步IO"></p><h1 id="2-网络编程模型"><a href="#2-网络编程模型" class="headerlink" title="2 网络编程模型"></a>2 网络编程模型</h1><p>基于上述五种模型，在Java中，随着NIO和NIO2.0(AIO)的引入，有BIO、NIO和AIO网络编程模型。</p><h2 id="2-1-BIO"><a href="#2-1-BIO" class="headerlink" title="2.1 BIO"></a>2.1 BIO</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-五种IO模型&quot;&gt;&lt;a href=&quot;#1-五种IO模型&quot; class=&quot;headerlink&quot; title=&quot;1 五种IO模型&quot;&gt;&lt;/a&gt;1 五种IO模型&lt;/h1&gt;&lt;p&gt;把内存中的数据写到外部设备（硬盘、终端、网络等）上这个动作称为输出（写）&lt;code&gt;Outp
      
    
    </summary>
    
      <category term="netty" scheme="http://JacobLei.github.io/categories/netty/"/>
    
    
      <category term="netty" scheme="http://JacobLei.github.io/tags/netty/"/>
    
      <category term="Java网络编程" scheme="http://JacobLei.github.io/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-散列表</title>
    <link href="http://JacobLei.github.io/2019/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>http://JacobLei.github.io/2019/06/24/数据结构与算法-散列表/</id>
    <published>2019-06-24T08:53:55.000Z</published>
    <updated>2019-08-25T09:12:52.956Z</updated>
    
    <content type="html"><![CDATA[<p>本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。</p><a id="more"></a><h1 id="散列表的理解"><a href="#散列表的理解" class="headerlink" title="散列表的理解"></a>散列表的理解</h1><p>散列表也叫<code>Hash</code>表，具有像数组那样根据随机访问的特性，可以根据<code>key</code>来获得<code>value</code>。</p><p>接下来举一个具体实例来理解散列表。当学校举办校运动会，每个运动员都有一个号码牌，这个号码牌的是根据“年级+班级+序号”组成，比如初一三班的小岛的号码牌为<code>070311</code>，其中<code>07</code>表示七年级即初一，<code>03</code>表示三班,<code>11</code>表示班上第11个班上参加运动会的序号。这个时候我们如何存储运动员的信息，来实现通过号码牌来查找运动员的信息？</p><p>按照以往的经验，我们可以通过使用数组来存储，其中号码牌即为数组的下标，数组的值为运动员的信息。但是这里有一个问题，运动员的号码牌不是连续的，而申请数组的时候内存空间是连续的，因此会有很多内存空间浪费。</p><p>这个时候就可以使用散列表，处理过程如下所示：</p><p><img src="号码牌散列.png" alt="号码牌散列"></p><p>从上图可以观察到，我们在存储运动员信息的时候，不是将整个号码牌作为数组的下标，而是将号码牌先进行<code>hash</code>函数（对100取余）处理后得到的数作为数组的下标，这样就可以数组的大小大大减小，并且在查找到时候也可以通过号码牌来查找对应的运动员的信息。细心的小伙伴观察到，如果<code>hash</code>函数处理后的余数一样该怎么办？比如，号码牌为<code>080211</code>的运动员就会和<code>070311</code>运动员在<code>hash</code>函数处理后得到的数是一样，因此会发生冲突，这个就是<strong>散列冲突的问题</strong>，在后续的讲解中会有相应的解决方案。这里先讲解<code>Hash</code>函数。</p><h1 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a><code>Hash</code>函数</h1><p>从上面的图可以观察到，中间的部分的部分为<code>Hash</code>函数，也称为散列函数。它在散列表中起着关键作用。<br><code>Hash</code>函数一般使用<code>hash(key)</code>表示，其中<code>key</code>表示元素的键值部分，<code>hash(key)</code>的表示经过<code>Hash</code>函数计算得到的<code>Hash</code>值（散列值）。<br>对于上面运动会的问题，我们的<code>Hash</code>函数是将号码牌转为整型后对<code>100</code>取余。不同的应用实例的<code>Hash</code>函数不同，该怎么去构造<code>Hash</code>函数，一般遵循一下三条：</p><ul><li><code>Hash</code>函数计算得到的散列值是一个<strong>非负整数</strong>；</li><li>如果<code>key1 == key2</code>，那么<code>hash(key1) == hash(key2)</code>;</li><li>如果<code>key1 != key2</code>，那么<code>hash(key1) != hash(key2)</code>.</li></ul><p>对于第一条很好理解，因为数组的下标是从0开始，所以<code>Hash</code>函数生成的<code>Hash</code>值也需要是非负整数。<br>对于第二条，相同的<code>key</code>经过<code>Hash</code>函数处理后得到的<code>Hash</code>值应该也是相同的。<br>对于第三条，逻辑上应该是这样的，不同的<code>key</code>经过<code>Hash</code>函数处理后得到的<code>Hash</code>值应该是不相同的，但是想要找到一条不同的<code>key</code>对应的<code>Hash</code>值都不一样几乎为不可能的，数组的存储空间是有限的，会加大散列冲突的概率。对于散列冲突，我们需要通过其他的方式来解决。</p><h1 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h1><p>上一小节已经分析了散列冲突产生的原因，我们一般使用<strong>开放寻址法</strong>和<strong>链表法</strong>来解决。</p><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p>开放寻址法的主要思想是当出现散列冲突时，我们去重新寻找下一个位置，直到找到空闲位置为止，将数据放置到找到的空闲位置。那么如何去寻找空闲位置呢？一般有线性探测法、二次探测法和双重散列法。</p><h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p><img src="线性探测.png" alt="线性探测"><br>如上图所示，就是使用线性探测法进行寻址。<code>table</code>部分红色区域表示该部分已经存储数据，当号码牌<code>060702</code>通过<code>Hash</code>函数进行散列后，得到的区域已经存储了数据，因此需要从当前为止开始依次向后查找，遇到空闲的位置即为找到存储数据的位置。</p><p><img src="散列表中查找元素.png" alt="散列表中查找元素"><br>在<code>Hash</code>表中进行查找元素的过程与插入的过程相似。首先通过<code>Hash</code>函数进行散列后求出对应的散列值，然后比较数组中的该位置的元素是否与要查找的元素相等，若相等，则找到对应的元素；若不想等，则依次向后查找。如果遍历数组时，遇到空闲位置还没找到，则说明散列表中没有对应的元素。</p><p>通过插入和查找过程可以发现，当散列表中的数据越来越多时，散列冲突会越来越大，数组中的空闲位置会越来越少，线性探测的时间会越来越久。最坏的时间复杂度为<code>O(n)</code>。</p><h3 id="二次探测法"><a href="#二次探测法" class="headerlink" title="二次探测法"></a>二次探测法</h3><p>将线性探测的寻址方法表示出来即为：<code>hash(key)+0</code>，<code>hash(key)+1</code>，<code>hash(key)+2</code>……</p><p>二次探测法与线性探测法很类似，只是步长由原来的1变为二次方即<code>hash(key)+0</code>，<code>hash(key)+1^2</code>，<code>hash(key)+2^2</code>……</p><h3 id="双重散列法"><a href="#双重散列法" class="headerlink" title="双重散列法"></a>双重散列法</h3><p>双重散列是指我们不仅仅使用一个散列函数，而是使用一组散列函数。如<code>hash1(key)</code>，<code>hash2(key)</code>，<code>hash3(key)</code>……我们先用第一个散列函数计算，如果存储位置已经被占用，则使用第二个散列函数，以此类推直到找到空余的存储位置即可。</p><h2 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h2><p>链表法比开放寻址法更为常用，在<code>JDK8</code>以前的<code>HashMap</code>底层源码就是使用链表法进行实现的。其结构图如下所示：</p><p><img src="链表法.png" alt="链表法"><br>如上图所示，在散列表中每个桶或者槽会对应一条链表，所有散列相同的元素会在存储在同一槽中对应的链表中。</p><p>在插入时，通过<code>Hash</code>函数计算出对应的槽位，然后将其插入到对应的链表中即可；当查找时，也是通过<code>Hash</code>函数计算出相应的槽位，然后查找相应的元素即可。</p><h1 id="Hash函数的确定"><a href="#Hash函数的确定" class="headerlink" title="Hash函数的确定"></a><code>Hash</code>函数的确定</h1><p>通过前面学习到，<code>Hash</code>表的查询效率并不是<code>O(1)</code>，它与<code>Hash</code>函数、散列冲突等因素有关。如果<code>Hash</code>函数确定得不好，可能导致散列冲突概率升高，查询效率下降。那么，该如何设计<code>Hash</code>函数呢？</p><p>首先，<code>Hash</code>函数的设计一般设计得不要过于复杂，过于复杂的<code>Hash</code>函数会导致计算时间过多，从而影响散列表的性能；</p><p>其次，<code>Hash</code>函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突，而且即使出现冲突，散列到每个槽中的数据也会比较平均，不会导致某些槽中的数据过多，而另一部分槽中的数据过少的情况。</p><p>传统的<code>Hash</code>函数的设计方法有直接寻址法、平方取中法、折叠法、随机数法等，也可以根据实际情况自己设计<code>Hash</code>函数。</p><h1 id="装载因子的确定"><a href="#装载因子的确定" class="headerlink" title="装载因子的确定"></a>装载因子的确定</h1><p>为了定量的表示<code>Hash</code>表中空位的多少，定义<strong>装载因子</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash表的装载因子 = 填入表中的元素个数 / Hash表的长度</span><br></pre></td></tr></table></figure></p><p>由公式可知，装载因子越大，说明<code>Hash</code>表中的元素越多，空闲位置越少，散列冲突的概率越大，散列表的性能就会下降。</p><p>对于没有频繁插入和删除的静态数据结合来说，可以根据数据的特点和分布情况设计出符合这些数据的<code>Hash</code>函数，从而减少了散列冲突。</p><p>但是大部分情况下是动态数据，数据集合是频繁变动的，我们无法事先知道数据的个数，因此也无法事先申请一个足够大的<code>Hash</code>表。随着数据加入，填入表中的元素个数增多，装载因子增大，当装载因子达到一定程度时，散列冲突便不可接受，因此我们无法根据数据的特征和分布情况设计出符合这些数据的<code>Hash</code>函数，而是需要<strong>动态扩容</strong>，重新申请一个更大的<code>Hash</code>表，将数据重新存储到新的<code>Hash</code>表中。</p><p>如下图中的散列表，当装载因子达到0.8时进行扩容，装载因子变为0.4，原来的数据就会存储在新的<code>Hash</code>表中。<br><img src="装载因子的确定.png" alt="装载因子的确定"></p><p>当数据插入到<code>Hash</code>表时，如果装载因子还未达到临界值，此时还不需要扩容，插入的数据非常快，但如果装载因子达到了临界值，这是就需要先进行扩容，然后再插入数据，这个时候就会变得很慢。</p><p>当数据需要从<code>Hash</code>表中删除时，如果<code>Hash</code>表已经经历过扩容，随着数据的删除，空闲空间会越来越多。当程序对内存空间非常敏感时，可以设置当装载因子小于某个临界值时，启动动态缩容，让内容空间得到充分利用；当程序对内存空间不太敏感时，就不需要进行动态缩容处理。</p><h1 id="动态扩容策略"><a href="#动态扩容策略" class="headerlink" title="动态扩容策略"></a>动态扩容策略</h1><p>为了减少动态扩容耗时，我们可以将扩容的操作穿插在插入操作过程中。具体如下图所示：<br><img src="动态扩容策略.png" alt="动态扩容策略"><br>这样每次插入时迁移一个数据，没有集中一次性迁移数据那样耗时，不会形成明显的阻塞。由于迁移过程中，有新旧两个<code>Hash</code>表，查找数据时，先在新的<code>Hash</code>表中进行查找，如果没有，再去旧的<code>Hash</code>表中进行查找。</p><h1 id="合理的选择Hash冲突解决办法"><a href="#合理的选择Hash冲突解决办法" class="headerlink" title="合理的选择Hash冲突解决办法"></a>合理的选择<code>Hash</code>冲突解决办法</h1><p>常用的解决<code>Hash</code>冲突的方法有开放寻址法和链表法。在<code>Java</code>中<code>ThreadLocalMap</code>采用线性探测的开放寻址法来解决冲突，<code>LinkedHashMap</code>采用了链表法解决<code>Hash</code>冲突。</p><h2 id="开放寻址法-1"><a href="#开放寻址法-1" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><ul><li>优点：将数据存储在数组中；利用CPU缓存加快查询速度；并且序列化简单。</li><li>缺点：删除数据麻烦，需要特殊标记已删除的数据；需要将所有数据存储在一个连续的存储空间中，比起链表来说，冲突的代价更高。</li><li>适用场景：当数据量较小、装载因子小的时候可以采用开放寻址法。</li></ul><h2 id="链表法-1"><a href="#链表法-1" class="headerlink" title="链表法"></a>链表法</h2><ul><li>优点：对内存利用率高；对装载因子的容忍度高（开放寻址法只适用在装载因子小于1的情况，接近1时，就可能会有大量散列冲突，导致大量的探测、再散列，性能下降很多。但对于链表法，只要散列函数的值随机均匀，当装载因子大于1时，只是对应的链表长度增加，这里也可以通过将链表改造为跳表或者红黑树的方式加快查找速度）</li><li>缺点：由于链表需要存储指针，存储较小的对象时，指针占用的内容消耗比较大；链表不支持随机查找，查找效率较低。</li><li>适用场景：适合于存储大对象、数据量大的散列表；比开放寻址法更加灵活，支持更多的优化策略，如使用红黑树替代链表。</li><li>优化：我们可将链表法中的链表替换成更加高效的动态的数据结构，如跳表、红黑树等。<br><img src="链表法-红黑树.png" alt="链表法-红黑树"></li></ul><h1 id="Java中的HashMap分析"><a href="#Java中的HashMap分析" class="headerlink" title="Java中的HashMap分析"></a><code>Java</code>中的<code>HashMap</code>分析</h1><p><code>HashMap</code>是一个成熟的散列表，在Java中得到了广泛应用，下面来具体分析。</p><h2 id="初始大小"><a href="#初始大小" class="headerlink" title="初始大小"></a>初始大小</h2><p>如下图所示，<code>HashMap</code>默认的初始大小为16。<br><img src="HashMap初始化大小.png" alt="HashMap初始化大小"><br>如果事先知道数据量的大小，可以通过修改初始大小，减少动态扩容次数，来提升<code>HashMap</code>性能。</p><h2 id="装载因子和动态扩容"><a href="#装载因子和动态扩容" class="headerlink" title="装载因子和动态扩容"></a>装载因子和动态扩容</h2><p>如下图所示，<code>HashMap</code>默认的装载因子为0.75。<br><img src="HashMap装载因子.png" alt="HashMap装载因子"><br>当<code>HashMap</code>中元素个数超过<code>0.75*capacity</code>（<code>capacity</code>表示<code>HashMap</code>实际的容量），就会启动动态扩容，每次扩容的大小为原来的两倍。</p><h2 id="Hash冲突的解决办法"><a href="#Hash冲突的解决办法" class="headerlink" title="Hash冲突的解决办法"></a><code>Hash</code>冲突的解决办法</h2><p>在<code>JDK1.8</code>之前，<code>HashMap</code>底层采用的链表法来解决冲突。即使装载因子和<code>Hash</code>函数设计的再合理，随着数据量的增加也会出现链表过长的情况，一旦链表过长，严重影响了<code>HashMap</code>的性能。<br>在<code>JDK1.8</code>中对<code>HashMap</code>底层做了优化。当链表长度大于8时，链表就转化为红黑树，当链表小于8时，将红黑树转化为链表。因为当链表过长的时候，查找的效率将会变慢，利用红黑树快速增删改查的特性，可以提高<code>HashMap</code>的性能，而链表不长时，红黑树的快速增删改查的特性就不太明显，并且红黑树的还有维护成本，因此不需要将链表转化为红黑树。</p><h2 id="Hash函数-1"><a href="#Hash函数-1" class="headerlink" title="Hash函数"></a><code>Hash</code>函数</h2><p><code>HashMap</code>中的<code>Hash</code>函数如下图所示，追求简单高效且分布均匀。<br><img src="HashMap中的Hash函数.png" alt="HashMap中的Hash函数"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="散列表" scheme="http://JacobLei.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-二叉查找树</title>
    <link href="http://JacobLei.github.io/2019/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://JacobLei.github.io/2019/06/24/数据结构与算法-二叉查找树/</id>
    <published>2019-06-24T03:21:07.000Z</published>
    <updated>2019-07-02T12:23:26.626Z</updated>
    
    <content type="html"><![CDATA[<p>本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。</p><a id="more"></a><h1 id="二叉查找树的理解"><a href="#二叉查找树的理解" class="headerlink" title="二叉查找树的理解"></a>二叉查找树的理解</h1><p>二叉查找树是一种特殊的二叉树，它支持动态的数据集合的快速插入、删除和查找操作。二叉查找树的一般结构如下图所示：<br><img src="二叉查找树.png" alt="二叉查找树"><br>从上图可以观察到二叉查找树的一个重要特性<strong>树中的任意一个节点，其左子树中的每个节点的值都小于该节点的值，右子树中的每个节点的值都大于该节点的值</strong>。</p><h1 id="二叉查找树的查找操作"><a href="#二叉查找树的查找操作" class="headerlink" title="二叉查找树的查找操作"></a>二叉查找树的查找操作</h1><p><img src="二叉查找树的查找操作.png" alt="二叉查找树的查找操作"></p><p>对于二叉查找树的查找操作主要步骤如下：</p><ul><li>先获取根节点，如果根节点的值等于需要查找的值，则返回；</li><li>如果根节点的值小于需要查找的值，则在右子树中递归查找；</li><li>如果根节点的值大于需要查找的值，则在左子树中递归查找。</li></ul><p>查找的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearchTree &#123;</span><br><span class="line">  public static class Node &#123;</span><br><span class="line">    private int data;</span><br><span class="line">    private Node left;</span><br><span class="line">    private Node right;</span><br><span class="line"></span><br><span class="line">    public Node(int data) &#123;</span><br><span class="line">      this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Node tree;</span><br><span class="line"></span><br><span class="line">  public Node find(int data) &#123;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">      if(p.data &lt; data)</span><br><span class="line">        p = p.right;</span><br><span class="line">      else if(p.data &gt; data)</span><br><span class="line">        p = p.left;</span><br><span class="line">      else</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="二叉查找树的插入操作"><a href="#二叉查找树的插入操作" class="headerlink" title="二叉查找树的插入操作"></a>二叉查找树的插入操作</h1><p><img src="二叉查找树的插入操作.png" alt="二叉查找树的插入操作"></p><p>对于二叉查找树的插入操作时，新插入节点一般都是插入到叶子节点，从根节点开始依次比较新插入节点的值与当前节点值的大小关系，具体步骤如下：</p><ul><li>如果新插入节点的值<strong>大于</strong>当前节点的值，并且当前节点的右子树为空，则将新插入的节点插入到右子节点的位置；如果当前节点的右子树不可空，则递归遍历右子树，查找插入的位置；</li><li>如果新插入节点的值<strong>小于</strong>当前节点的值，并且当前节点的左子树为空，则将新插入的节点插入到左子节点的位置；如果当前节点的左子树不为空，则递归遍历左子树，查找插入的位置。</li></ul><p>插入的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearchTree &#123;</span><br><span class="line">  </span><br><span class="line">  public static class Node &#123;</span><br><span class="line">    private int data;</span><br><span class="line">    private Node left;</span><br><span class="line">    private Node right;</span><br><span class="line"></span><br><span class="line">    public Node(int data) &#123;</span><br><span class="line">      this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Node tree;</span><br><span class="line"></span><br><span class="line">  public void insert(int data) &#123;</span><br><span class="line">    if (tree == null) &#123;</span><br><span class="line">      tree = new Node(data);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node p = tree;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">      if (data &gt; p.data) &#123;</span><br><span class="line">        if (p.right == null) &#123;</span><br><span class="line">          p.right = new Node(data);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.right;</span><br><span class="line">      &#125; else &#123; // data &lt; p.data</span><br><span class="line">        if (p.left == null) &#123;</span><br><span class="line">          p.left = new Node(data);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.left;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="二叉查找树的删除操作"><a href="#二叉查找树的删除操作" class="headerlink" title="二叉查找树的删除操作"></a>二叉查找树的删除操作</h1><p>对于二叉查找树的删除操作主要分为三种情况，下面分别讨论：</p><ul><li><p>当删除的节点中没有子节点，只需要将父节点中指向该节点的指针设为空即可；<br><img src="二叉查找树的删除操作1.png" alt="二叉查找树的删除操作1"></p></li><li><p>当删除的节点只有一个子节点（只有左子节点或者右子节点），只需要更新父节点中指向删除节点的指针，让该指针指向删除节点的子节点即可；<br><img src="二叉查找树的删除操作2.png" alt="二叉查找树的删除操作2"></p></li><li><p>当删除的节点有两个节点时，需要找到<strong>该节点右子树中值最小的节点，把它替换到删除节点上，然后删除找到的右子树中值最小的节点</strong>。<br><img src="二叉查找树的删除操作3.png" alt="二叉查找树的删除操作3"></p></li></ul><p>删除的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearchTree &#123;</span><br><span class="line">  </span><br><span class="line">  public static class Node &#123;</span><br><span class="line">    private int data;</span><br><span class="line">    private Node left;</span><br><span class="line">    private Node right;</span><br><span class="line"></span><br><span class="line">    public Node(int data) &#123;</span><br><span class="line">      this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Node tree;</span><br><span class="line"></span><br><span class="line">  public void delete(int data) &#123;</span><br><span class="line">    Node p = tree; // p 指向要删除的节点，初始化指向根节点</span><br><span class="line">    Node pp = null; // pp 记录的是 p 的父节点</span><br><span class="line">    while (p != null &amp;&amp; p.data != data) &#123;</span><br><span class="line">      pp = p;</span><br><span class="line">      if (data &gt; p.data) </span><br><span class="line">      p = p.right;</span><br><span class="line">      else p = p.left;</span><br><span class="line">  &#125;</span><br><span class="line">    if (p == null) return; // 没有找到</span><br><span class="line"></span><br><span class="line">    // 要删除的节点有两个子节点</span><br><span class="line">    if (p.left != null &amp;&amp; p.right != null) &#123; // 查找右子树中最小节点</span><br><span class="line">      Node minP = p.right;</span><br><span class="line">      Node minPP = p; // minPP 表示 minP 的父节点</span><br><span class="line">      while (minP.left != null) &#123;</span><br><span class="line">        minPP = minP;</span><br><span class="line">        minP = minP.left;</span><br><span class="line">      &#125;</span><br><span class="line">      p.data = minP.data; // 将 minP 的数据替换到 p 中</span><br><span class="line">      p = minP; // 下面就变成了删除 minP 了</span><br><span class="line">      pp = minPP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 删除节点是叶子节点或者仅有一个子节点</span><br><span class="line">    Node child; // p 的子节点</span><br><span class="line">    if (p.left != null) </span><br><span class="line">      child = p.left;</span><br><span class="line">    else if (p.right != null) </span><br><span class="line">      child = p.right;</span><br><span class="line">    else </span><br><span class="line">      child = null;</span><br><span class="line"></span><br><span class="line">    // 删除的是根节点</span><br><span class="line">    if (pp == null) </span><br><span class="line">      tree = child; </span><br><span class="line">    else if (pp.left == p) </span><br><span class="line">      pp.left = child;</span><br><span class="line">    else </span><br><span class="line">      pp.right = child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉查找树" scheme="http://JacobLei.github.io/tags/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-二叉树</title>
    <link href="http://JacobLei.github.io/2019/06/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://JacobLei.github.io/2019/06/23/数据结构与算法-二叉树/</id>
    <published>2019-06-23T06:48:58.000Z</published>
    <updated>2019-06-23T11:10:33.561Z</updated>
    
    <content type="html"><![CDATA[<p>本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。</p><a id="more"></a><h1 id="二叉树的理解"><a href="#二叉树的理解" class="headerlink" title="二叉树的理解"></a>二叉树的理解</h1><p>在理解树的基本概念和结构后接下来我们学习最常用的一种树——二叉树，如下图所示：</p><p><img src="常见的二叉树.png" alt="常见的二叉树"></p><p>从图中可以观察到，每个节点<strong>最多</strong>有两个分支，也就是两个节点，一般称为<strong>左子节点</strong>和<strong>右子节点</strong>。注意，是最多有两个节点，而不是必须有两个节点。像上图中的C节点只有一个节点（右子节点）。</p><h1 id="完全二叉树和满二叉树"><a href="#完全二叉树和满二叉树" class="headerlink" title="完全二叉树和满二叉树"></a>完全二叉树和满二叉树</h1><p>在二叉树中有两种特殊的二叉树，分别是完全二叉树和满二叉树。</p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p><img src="完全二叉树.png" alt="完全二叉树"></p><p>如上图所示，节点F、G、H、I和J是叶子节点，这些叶子节点都在最后的两层，最后一层的叶子节点靠左排列，并且除最后一层外，其他层的节点个数达到最大，这样的二叉树即为<strong>完全二叉树</strong>。</p><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p><img src="满二叉树.png" alt="满二叉树"></p><p>如上图所示，节点D、E、F和G是叶子节点，这些叶子节点都在最后一层，且除了叶子节点外其他的节点都有左右两个子节点，这样的二叉树即为<strong>满二叉树</strong>。</p><h1 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h1><p>对于二叉树的存储，可以通过<strong>链式存储法</strong>和<strong>顺序存储法</strong>分别存储。</p><h2 id="链式存储法"><a href="#链式存储法" class="headerlink" title="链式存储法"></a>链式存储法</h2><p><img src="链式存储法.png" alt="链式存储法"></p><p>观察上图可以知道，对于每个节点有三个字段，其中<code>data</code>表示存储数据，<code>left</code>表示指向左子节点的指针，<code>right</code>表示指向右子节点的指针。如果我们知道了一颗二叉树的根节点，则我们可以通过左右子节点的指针进行查找。大部分的二叉树的代码都是通过链式存储法来实现的。</p><h2 id="顺序存储法"><a href="#顺序存储法" class="headerlink" title="顺序存储法"></a>顺序存储法</h2><p><img src="顺序存储法.png" alt="顺序存储法"></p><p>观察上图可以知道，当二叉树中的某一个节点<code>index</code>为i，则它的左子节点的<code>index</code>为<code>2*i+1</code>，它的右子节点的<code>index</code>为<code>2*i+2</code>，它的父节点的<code>index</code>为<code>i/2</code>。因此，我们只要知道根节点的<code>index</code>，则可以通过上述表达式进行查找。对于使用顺序存储法时，需要申请连续的内存空间，因此对于节点个数不多完全二叉树和满二叉树比较合适，但是对于不完全二叉树就会造成大量的空间浪费。</p><h1 id="二叉树的前序遍历、中序遍历和后序遍历"><a href="#二叉树的前序遍历、中序遍历和后序遍历" class="headerlink" title="二叉树的前序遍历、中序遍历和后序遍历"></a>二叉树的前序遍历、中序遍历和后序遍历</h1><p>在对二叉树遍历时，前序、中序和后序是指<strong>当前节点与它的左右子节点的打印现后顺序</strong>。</p><ul><li>前序遍历：先打印当前节点，然后打印左子树，最后打印右子树。当前节点 -&gt; 左子树 -&gt; 右子树；</li><li>中序遍历：先打印左子树，然后打印当前节点，最后打印右子树。左子树 -&gt; 当前节点 -&gt; 右子树；</li><li>后序遍历：先打印左子树，然后打印右子树，最后打印当前节点。左子树 -&gt; 右子树 -&gt; 当前节点。</li></ul><p><img src="满二叉树.png" alt="满二叉树"><br>对上面二叉树的打印顺序分别为：</p><ul><li>前序遍历：A -&gt; B -&gt; D -&gt; E -&gt; C -&gt; F -&gt; G</li><li>中序遍历：D -&gt; B -&gt; E -&gt; A -&gt; F -&gt; C -&gt; G</li><li>后序遍历：D -&gt; E -&gt; B -&gt; F -&gt; G -&gt; C -&gt; A</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://JacobLei.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-跳表</title>
    <link href="http://JacobLei.github.io/2019/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8/"/>
    <id>http://JacobLei.github.io/2019/06/17/数据结构与算法-跳表/</id>
    <published>2019-06-17T02:40:36.000Z</published>
    <updated>2019-06-17T08:50:20.685Z</updated>
    
    <content type="html"><![CDATA[<p>本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。</p><a id="more"></a><p>在学习二分查找时，我们知道二分查找需要依赖数组的随机访问的特性进行查找，而链表不具有随访问的特性，因此不能使用传统上的二分查找方法了。为了使得链表支持类似二分查找的算法，对原始的链表进行修改，修改后的链表就是<strong>跳跃表</strong>，简称<strong>跳表</strong>。跳表支持快速的插入、删除、查找操作，是一种动态的数据结构。</p><h1 id="跳表的理解"><a href="#跳表的理解" class="headerlink" title="跳表的理解"></a>跳表的理解</h1><p>我们知道对于链表中存储的数据有序的单链表，我们需要查找链表中的某个数据，需要从头到尾遍历，查找的时间复杂度位<code>O(n)</code>，如下所示：<br><img src="/2019/06/17/数据结构与算法-跳表/原始链表.png" title="原始链表"></p><p>我们对原始链表加一级索引，如下所示：<br><img src="/2019/06/17/数据结构与算法-跳表/一级索引.png" title="一级索引"></p><p>如下图所示，对于查找值为6的节点，在原始节点上查找需要6次，而通过第一级索引进行查找，如下图所示，只需要5次，减少了查找次数。<br><img src="/2019/06/17/数据结构与算法-跳表/一级索引查找值为6的节点.png" title="一级索引查找值为6的节点"></p><p>我们再到第一级索引上在再加索引，如下图所示：<br><img src="/2019/06/17/数据结构与算法-跳表/第二级索引.png" title="第二级索引"></p><p>对于查找值为6的节点如下所示，查找次数为6次。<br><img src="/2019/06/17/数据结构与算法-跳表/第二级索引查找值为6的节点.png" title="第二级索引查找值为6的节点"></p><p>由于这个数据量不大，查找效率提升的不明显，对于数据量较大的时候，查找效率提高很快。</p><h1 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h1><p>首先来分析对于有<code>n</code>个节点的链表，需要建立多少级索引。根据上面的例子可以得到，如果我们每两个节点会提取一个节点作为一个索引节点，那么第一级索引节点的个数为<code>n/2</code>，第二级索引节点的个数为<code>n/4</code>，依此类推，则<strong>第K级的索引节点的个数为<code>n/(2^k)</code></strong>。</p><p>假设索引有<code>h</code>级，且第<code>h</code>级的索引节点个数为2，如下图所示。则我们可以得出<code>n/(2^h)=2</code>,这样可以得到<code>h=logn-1</code>（这里的<code>log</code>是指以2为底）,加上链表本身的一层，则整个跳表的高度为<code>logn</code>。我们在跳表中查询某个数据时，如果每一层都需要遍历<code>m</code>个节点，那么在跳表中查询某个数的时间复杂度为<code>O(m*log(n))</code>。<br><img src="/2019/06/17/数据结构与算法-跳表/跳表高度.png" title="跳表高度"></p><h1 id="跳表空间复杂度分析"><a href="#跳表空间复杂度分析" class="headerlink" title="跳表空间复杂度分析"></a>跳表空间复杂度分析</h1><p>跳表查找效率的提高是通过建立多级索引实现的，而建立索引肯定需要消耗内存空间。对于跳表的内存空间分析并不难，对于有<code>n</code>个节点的链表，第一级索引节点的个数为<code>n/2</code>，第二级索引节点的个数为<code>n/4</code>，最后一级的索引节点的个数为2，我们可以得出一个等比数列：<code>n/2 + n/4 + n/8 + ... + 4 + 2 = n-2</code>,因此跳表的空间复杂度为<code>O(n)</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="跳表" scheme="http://JacobLei.github.io/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-33 搜索旋转排序数组</title>
    <link href="http://JacobLei.github.io/2019/06/15/LeetCode-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://JacobLei.github.io/2019/06/15/LeetCode-33-搜索旋转排序数组/</id>
    <published>2019-06-15T09:10:17.000Z</published>
    <updated>2019-06-16T11:44:12.394Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：33. 搜索旋转排序数组</li><li>难度：中等</li><li>分类：数组</li><li>解决方案：二分查找<a id="more"></a></li></ul><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">题目描述</a></h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组<code>[0,1,2,4,5,6,7]</code>可能变为<code>[4,5,6,7,0,1,2]</code> )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回<code>-1</code>。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是<code>O(log n)</code>级别。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这是一个二分查找的变形题，对于二分查找不太熟悉的小伙伴可以扫描文章下方的二维码，关注『 算法半岛』回复『 数据结构目录』，即可获得相关学习资料。</p><p>这道题与传统的二分查找不同的是，给定的数组是一个旋转排序数组。我们先分析一下什么是旋转排序数组，如下图所示：<br><img src="/2019/06/15/LeetCode-33-搜索旋转排序数组/旋转数组.png" title="旋转数组"></p><p>我们称红色部分的7和绿色部分的0为旋转区域，即排序数组分割区域。我们对上面任意一个旋转数组进行查找给定值，如示例1为对上面的旋转数组4查找给定值0，查找过程如下所示：<br><img src="/2019/06/15/LeetCode-33-搜索旋转排序数组/示例1详细分析过程.png" title="示例1详细分析过程"></p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[high])&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; nums[high]&gt;=target)&#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; target &amp;&amp; nums[low] &lt;= target)&#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/15/LeetCode-33-搜索旋转排序数组/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A33_SearchinRotatedSortedArray.java" target="_blank" rel="noopener">LeetCode-33 搜索旋转排序数组</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：33. 搜索旋转排序数组&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：二分查找
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="二分查找" scheme="http://JacobLei.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-二分查找</title>
    <link href="http://JacobLei.github.io/2019/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://JacobLei.github.io/2019/06/14/数据结构与算法-二分查找/</id>
    <published>2019-06-14T08:59:02.000Z</published>
    <updated>2019-06-15T10:59:32.985Z</updated>
    
    <content type="html"><![CDATA[<p>本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。</p><a id="more"></a><h1 id="二分查找理解"><a href="#二分查找理解" class="headerlink" title="二分查找理解"></a>二分查找理解</h1><p>二分查找也称为折半查找，主要用在<strong>有序集合</strong>中进行查找。我们先通过一个猜数字的小游戏来分析。首先我随机写一个0~99的数字，然后你再猜我写的哪一个数字，在猜数字过程中如果你猜大了，我会提示你猜的数字大于我写的数字；如果你猜小了，我会提示你猜的数字小于我写的数字，直到猜中为止。那么如何快速猜中呢？</p><p>这里就可以用到二分查找的思想了，假设我写下的数字为16，那么可以通过如下步骤进行猜测：<br><img src="/2019/06/14/数据结构与算法-二分查找/猜数字.png" title="猜数字"><br>通过很少的次数（6次）就可以猜到数字。</p><p>为了方便用图形表示，我们假设在11~20之间找到16，如下图所示为查找过程，其中<code>low</code>和<code>high</code>表示待查找区间的下标，<code>mid</code>表示待查找区间的中间元素下标。<br><img src="/2019/06/14/数据结构与算法-二分查找/二分查找示意图.png" title="二分查找示意图"></p><p>二分查找是针对的一个有序的数据结合，查找思想有点类似分治思想，<strong>每次通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0</strong>。</p><p>二分查找的效率是非常高的，时间复杂度为<code>O(logn)</code>。</p><h1 id="二分查找代码实现"><a href="#二分查找代码实现" class="headerlink" title="二分查找代码实现"></a>二分查找代码实现</h1><p>这里讨论的是在有序数组中<strong>不存在重复元素</strong>的二分查找代码实现，我们实现递归版本与非递归版。</p><h2 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;        <span class="comment">// low表示待查找区间的起始位置的下标</span></span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;   <span class="comment">// high表示待查找区间的终止位置的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;   <span class="comment">// mid表示待查找区间的中间位置的下标</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; val)&#123;               <span class="comment">// 如上图第2步情况</span></span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; val)&#123;          <span class="comment">// 如上图第3步情况</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                              <span class="comment">// 当找到该数时，直接返回mid即可</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 当数字中没有需要查找的数，返回-1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意如下几点：</p><ul><li>循环退出条件为：<code>low&lt;=high</code>而不是<code>low&lt;high</code></li><li><code>mid</code>的取值：不能将<code>mid</code>写成<code>mid = (low + high)/2</code>。因为如果在<code>int</code>类型情况下，当<code>low</code>和<code>high</code>之和大于<code>int</code>类型的最大值，就会溢出，导致结果错误。因此需要写成<code>mid = low + (high - low) / 2</code>。更进一步，如果要将性能优化到极致，可以使用位运算进行计算，<code>mid = low + ((high - low) &gt;&gt; 1)</code>。</li></ul><h2 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> help(nums, <span class="number">0</span>, n-<span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> low 待查找区间的起始位置的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> high 待查找区间的终止位置的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val 待查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 查找到的值的下标，如果没有这个数，则返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当数字中没有需要查找的数，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(low &gt; high)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;   <span class="comment">// mid表示待查找区间的中间位置的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &lt; val)&#123;               <span class="comment">// 如上图第2步情况</span></span><br><span class="line">        <span class="keyword">return</span> help(nums, mid+<span class="number">1</span>, high, val);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; val)&#123;          <span class="comment">// 如上图第3步情况</span></span><br><span class="line">        <span class="keyword">return</span> help(nums, low, mid-<span class="number">1</span>, val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                              <span class="comment">// 当找到该数时，直接返回mid即可</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h1><p>二分查找有着查找效率高的优点，但是并不是所有的情况都可以进行二分查找。</p><ul><li>二分查找依赖的是<strong>顺序表结构</strong>，一般是以<strong>数组</strong>的形式使用，因为二分查找需要按照下标<strong>随机访问</strong>，因此对于链表结构不能使用二分查找。</li><li>二分查找针对的是<strong>有序数据</strong>。对于在没有序的情况下，需要对数据进行排序。如果对一组数据没有频繁的插入删除操作，我们可以通过一次排序后进行多次二分查找，这时的成本是比较可观的。但是对于数据需要多次的插入删除操作，我们使用二分查找前需要对这组数据进行排序，这时维护数组有序的成本比较高，这时就不适合使用二分查找。</li><li><strong>数据量太小不适合二分查找</strong>。如果数据量太小时，我们可以通过一次遍历即可查找，而不需要使用二分查找，只有当<strong>数据量较大</strong>的时候二分查找的优势才能体现出来。</li><li><strong>数据量特别大时也不适合二分查找</strong>。因为二分查找需要依赖数组，在申请数组时对内存空间要求比较苛刻。如我们有1GB的数据，使用二分查找的时就需要连续的1GB的内存空间。</li></ul><h1 id="二分查找的变形问题"><a href="#二分查找的变形问题" class="headerlink" title="二分查找的变形问题"></a>二分查找的变形问题</h1><p>下面主要分析四种二分查找变形问题，对于每个问题分析时，我们都将数据从小到大排好序，如果数据从大到小排序，其解决思路是一致的。对于本次分析的从小到大排好序且有重复数组如下所示：<br><img src="/2019/06/14/数据结构与算法-二分查找/数组中有重复数字.png" title="数组中有重复数字"></p><h2 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h2><p>当我们使用原来二分查找的方法查找第一个值等于给定值(18)的元素分析过程如下图所示：<br><img src="/2019/06/14/数据结构与算法-二分查找/查找第一个值等于给定值的元素—原始方法.png" title="查找第一个值等于给定值的元素—原始方法"></p><p>从上图可以观察到，我们查找到的<code>nums[mid]=18</code>却不是我们需要的第一个等于18的元素，因此使用原来的方法是无法处理这样的情况。<br>下面我们分析下如何在有重复值的数组中查找第一个值等于给定值的元素，如下图所示：<br><img src="/2019/06/14/数据结构与算法-二分查找/查找第一个值等于给定值的元素—修改方法.png" title="查找第一个值等于给定值的元素—修改方法"></p><p>相应的<code>java</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">first</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;        <span class="comment">// low表示待查找区间的起始位置的下标</span></span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;   <span class="comment">// high表示待查找区间的终止位置的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;   <span class="comment">// mid表示待查找区间的中间位置的下标</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; val)&#123;              </span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; val)&#123;          </span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                              <span class="comment">// 当找到该数时，但需要判断是否为第一个</span></span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid-<span class="number">1</span>] != val) <span class="comment">// 当mid为0时，说明元素已经是第一个，则返回；当nums[mid]的前一个数不为需要查找到数，则说明找到，则返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span>                            <span class="comment">// 不是第一个，则继续查找</span></span><br><span class="line">                high = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 当数字中没有需要查找的数，返回-1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h2><p>分析了查找第一个值等于给定值的元素后再来分析查找最后一个值等于给定值的元素就简单了，基本思路差不多，下面来看看具体分析过程：<br><img src="/2019/06/14/数据结构与算法-二分查找/查找最后一个值等于给定值的元素.png" title="查找最后一个值等于给定值的元素"></p><p>相应的<code>java</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">second</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;        <span class="comment">// low表示待查找区间的起始位置的下标</span></span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;   <span class="comment">// high表示待查找区间的终止位置的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;   <span class="comment">// mid表示待查找区间的中间位置的下标</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; val)&#123;</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; val)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                              <span class="comment">// 当找到该数时，但需要判断是否为最后一个</span></span><br><span class="line">            <span class="keyword">if</span> (mid == n-<span class="number">1</span> || nums[mid+<span class="number">1</span>] != val) <span class="comment">// 当mid为n-1时，说明元素已经最后一个，则返回；当nums[mid]的后一个数不为需要查找到数，则说明找到，则返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span>                            <span class="comment">// 不是最后一个，则继续查找</span></span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 当数字中没有需要查找的数，返回-1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h2><p>分析完上两个后，对于查找第一个大于等于给定值的元素的分析过程也差不多，这里就不画图，其代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">third</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;        <span class="comment">// low表示待查找区间的起始位置的下标</span></span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;   <span class="comment">// high表示待查找区间的终止位置的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;   <span class="comment">// mid表示待查找区间的中间位置的下标</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; val)&#123;</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;= val)&#123;    <span class="comment">// 当找到符合条件的数时，但需要判断是否为第一个</span></span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid-<span class="number">1</span>] &lt; val) <span class="comment">// 当mid为0时，说明已经是第一个，则返回；当nums[mid]的前一个数不符合查找条件时，则说明找到，则返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span>                            <span class="comment">// 不是第一个，则继续查找</span></span><br><span class="line">                high = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 当数字中没有需要查找的数，返回-1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h2><p>对于查找最后一个小于等于给定值的元素的分析过程也差不多，直接给出代码，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">four</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;        <span class="comment">// low表示待查找区间的起始位置的下标</span></span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;   <span class="comment">// high表示待查找区间的终止位置的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;   <span class="comment">// mid表示待查找区间的中间位置的下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= val)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == n-<span class="number">1</span> || nums[mid+<span class="number">1</span>] &gt; val) <span class="comment">// 当mid为n-1时，说明元素已经最后一个，则返回；当nums[mid]的后一个数不为需要查找到数，则说明找到，则返回</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span>                            <span class="comment">// 不是最后一个，则继续查找</span></span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; val)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 当数字中没有需要查找的数，返回-1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二分查找" scheme="http://JacobLei.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-深度优先搜索</title>
    <link href="http://JacobLei.github.io/2019/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <id>http://JacobLei.github.io/2019/06/11/数据结构与算法-深度优先搜索/</id>
    <published>2019-06-11T07:26:29.000Z</published>
    <updated>2019-06-17T07:46:01.867Z</updated>
    
    <content type="html"><![CDATA[<p>本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。</p><a id="more"></a><h1 id="DFS理解"><a href="#DFS理解" class="headerlink" title="DFS理解"></a>DFS理解</h1><p><strong>深度优先搜索</strong>(Depth First Search, DFS)可以理解为走迷宫，假设当一个人走迷宫的时候，会遇到岔路口，面对多条路选择时，可以先随便选择一条，走着走着发现如果走不通了，可以退回到上一个岔路口，然后重新选择一条，用同样的方法继续走，直到直到出口为止。这样的策略即为DFS。</p><h1 id="DFS示意图"><a href="#DFS示意图" class="headerlink" title="DFS示意图"></a>DFS示意图</h1><p>接下来我们将DFS应用到图的搜索中，如下图所示：<br><img src="/2019/06/11/数据结构与算法-深度优先搜索/深度优先遍历示意图.png" title="深度优先遍历示意图"></p><h1 id="DFS代码"><a href="#DFS代码" class="headerlink" title="DFS代码"></a>DFS代码</h1><p>在完成相应的<code>java</code>代码前，我们先解释相关函数及参数的含义：</p><ul><li><code>HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph</code>：我们使用一个<code>HashMap</code>来存储图，其中<code>HashMap</code>中的<code>key</code>为图的顶点，<code>LinkedList&lt;Integer&gt;&gt;</code>为与该顶点相连的顶点；</li><li><code>HashMap&lt;Integer, Boolean&gt; visited</code>：我们使用一个<code>visited</code>用来记录顶点是否被访问，用来避免顶点被重复访问；</li><li><code>visit(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, HashMap&lt;Integer, Boolean&gt; visited, Integer start)</code>：该函数为DFS的主体部分，用来遍历各个顶点。</li></ul><p>具体<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, HashMap&lt;Integer, Boolean&gt; visited)</span></span>&#123;</span><br><span class="line">        visit(graph, visited, <span class="number">1</span>);</span><br><span class="line">        visit(graph, visited, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph, HashMap&lt;Integer, Boolean&gt; visited, Integer start)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果该顶点没有被访问，则访问该顶点</span></span><br><span class="line">        <span class="keyword">if</span> (!visited.containsKey(start))&#123;</span><br><span class="line">            System.out.println(<span class="string">"当前进入节点为："</span> + start);</span><br><span class="line">            visited.put(start, <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 访问该顶点的相连顶点</span></span><br><span class="line">            <span class="keyword">for</span> (Integer i : graph.get(start))&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.containsKey(i))&#123;</span><br><span class="line">                    visit(graph,visited, i);    <span class="comment">// 递归访问相连顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"当前离开节点为："</span> + start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造各个顶点</span></span><br><span class="line">        LinkedList&lt;Integer&gt; v1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        v1.add(<span class="number">2</span>);</span><br><span class="line">        v1.add(<span class="number">3</span>);</span><br><span class="line">        v1.add(<span class="number">4</span>);</span><br><span class="line">        LinkedList&lt;Integer&gt; v2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        v2.add(<span class="number">1</span>);</span><br><span class="line">        v2.add(<span class="number">3</span>);</span><br><span class="line">        LinkedList&lt;Integer&gt; v3 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        v3.add(<span class="number">1</span>);</span><br><span class="line">        v3.add(<span class="number">2</span>);</span><br><span class="line">        LinkedList&lt;Integer&gt; v4 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        v4.add(<span class="number">1</span>);</span><br><span class="line">        v4.add(<span class="number">5</span>);</span><br><span class="line">        v4.add(<span class="number">6</span>);</span><br><span class="line">        LinkedList&lt;Integer&gt; v5 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        v5.add(<span class="number">4</span>);</span><br><span class="line">        LinkedList&lt;Integer&gt; v6 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        v6.add(<span class="number">4</span>);</span><br><span class="line">        v6.add(<span class="number">7</span>);</span><br><span class="line">        LinkedList&lt;Integer&gt; v7 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        v7.add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造图</span></span><br><span class="line">        HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        graph.put(<span class="number">1</span>, v1);</span><br><span class="line">        graph.put(<span class="number">2</span>, v2);</span><br><span class="line">        graph.put(<span class="number">3</span>, v3);</span><br><span class="line">        graph.put(<span class="number">4</span>, v4);</span><br><span class="line">        graph.put(<span class="number">5</span>, v5);</span><br><span class="line">        graph.put(<span class="number">6</span>, v6);</span><br><span class="line">        graph.put(<span class="number">7</span>, v7);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// visited数组记录被访问的节点</span></span><br><span class="line">        HashMap&lt;Integer, Boolean&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        dfs(graph, visited);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">当前进入节点为：<span class="number">1</span></span><br><span class="line">当前进入节点为：<span class="number">2</span></span><br><span class="line">当前进入节点为：<span class="number">3</span></span><br><span class="line">当前离开节点为：<span class="number">3</span></span><br><span class="line">当前离开节点为：<span class="number">2</span></span><br><span class="line">当前进入节点为：<span class="number">4</span></span><br><span class="line">当前进入节点为：<span class="number">5</span></span><br><span class="line">当前离开节点为：<span class="number">5</span></span><br><span class="line">当前进入节点为：<span class="number">6</span></span><br><span class="line">当前进入节点为：<span class="number">7</span></span><br><span class="line">当前离开节点为：<span class="number">7</span></span><br><span class="line">当前离开节点为：<span class="number">6</span></span><br><span class="line">当前离开节点为：<span class="number">4</span></span><br><span class="line">当前离开节点为：<span class="number">1</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="深度优先搜索" scheme="http://JacobLei.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-31 下一个排列</title>
    <link href="http://JacobLei.github.io/2019/06/10/LeetCode-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>http://JacobLei.github.io/2019/06/10/LeetCode-31-下一个排列/</id>
    <published>2019-06-10T07:57:44.000Z</published>
    <updated>2019-06-13T14:46:35.851Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：31. 下一个排列</li><li>难度：中等</li><li>分类：数组</li><li>解决方案：数组遍历<a id="more"></a></li></ul><p>今天我们学习第31题<strong>下一个排列</strong>，这是一个中等的数组题。我们先看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">题目描述</a></h1><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。<br>必须原地修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这是一个数组排列的题，首先我们需要弄明白什么是数组的下一个排列。我们可以对数字1、2和3这三个数进行排列，如下图所示：<br><img src="/2019/06/10/LeetCode-31-下一个排列/123排列.png" title="123排列"></p><p>对具体排列方法分析如下图所示：<br><img src="/2019/06/10/LeetCode-31-下一个排列/下一个排列详细分析过程.png" title="下一个排列详细分析过程"></p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从右向左遍历，存储第一个下降的数的坐标</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从右向左遍历，存储第一个大于nums[i]的数的坐标</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从右向左找到第一个降序的数，坐标为i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=nums.length -<span class="number">2</span>; k&gt;=<span class="number">0</span>; k--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k] &lt; nums[k+<span class="number">1</span>])&#123;</span><br><span class="line">                i = k;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从右向左找到第一个大于nums[i]的数，坐标为j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=nums.length-<span class="number">1</span>; k&gt;=<span class="number">0</span>; k--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k] &gt; nums[i])&#123;</span><br><span class="line">                j = k;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换 nums[i] 和 nums[j]</span></span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转置从i+1(0)到nums.length-1的数 </span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            n = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &lt; m)&#123;</span><br><span class="line">            swap(nums, n, m);</span><br><span class="line">            ++n;</span><br><span class="line">            --m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组中两个数字交换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/10/LeetCode-31-下一个排列/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A28_ImplementstrStr.java" target="_blank" rel="noopener">LeetCode-31 下一个排列</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：31. 下一个排列&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：数组遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-28 实现strStr()</title>
    <link href="http://JacobLei.github.io/2019/06/09/LeetCode-28-%E5%AE%9E%E7%8E%B0strStr/"/>
    <id>http://JacobLei.github.io/2019/06/09/LeetCode-28-实现strStr/</id>
    <published>2019-06-09T04:57:12.000Z</published>
    <updated>2019-06-13T07:24:24.935Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：28. 实现strStr()</li><li>难度：简单</li><li>分类：字符串</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第28题<strong>实现strStr()</strong>，这个题目是一个典型的字符串匹配题目。我们先看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">题目描述</a></h1><p>实现<code>strStr()</code>函数。</p><p>给定一个<code>haystack</code>字符串和一个<code>needle</code>字符串，在<code>haystack</code>字符串中找出<code>needle</code> 字符串出现的第一个位置 (从0开始)。如果不存在，则返回<code>-1</code>。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure></p><p>说明:</p><p><strong>当<code>needle</code>是空字符串时，我们应当返回什么值呢</strong>？这是一个在面试中很好的问题。</p><p>对于本题而言，当<code>needle</code>是空字符串时我们应当返回 0 。这与C语言的<code>strstr()</code>以及 Java的<code>indexOf()</code>定义相符。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我们可以称<code>haystack</code>字符串为母字符串，<code>needle</code>字符串为子字符串，这个题目是让我们在母字符串中寻找子字符串，如果存在，返回子字符串在母字符串中是第一个字符出现的位置，如果不存在，则返回<code>-1</code>。在题目的<strong>说明</strong>部分指出，子字符串为空字符串时，返回<code>0</code>。对于这样的题目，我们首先想到是暴力求解，一个一个字符去查找。对示例1的具体分析过程如下图所示：<br><img src="/2019/06/09/LeetCode-28-实现strStr/示例1详细分析过程.png" title="示例1详细分析过程"></p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lenHaystack = haystack.length();    <span class="comment">// 母字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> lenNeedle = needle.length();        <span class="comment">// 子字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> leftHaystack = <span class="number">0</span>;       <span class="comment">// 母字符串的左指针，用来标识子字符串在母字符串中的第一个字符</span></span><br><span class="line">        <span class="keyword">int</span> rightHaystack = <span class="number">0</span>;      <span class="comment">// 母字符串的右指针，用来标识子字符串在母字符串中的当前字符</span></span><br><span class="line">        <span class="keyword">int</span> curNeedle = <span class="number">0</span>;          <span class="comment">// 子字符串的当前字符指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当子字符串为空字符串时，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(lenNeedle == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(leftHaystack &lt;= lenHaystack - lenNeedle) &#123;</span><br><span class="line">            <span class="comment">// 如果母字符串中rightHaystack指向的字符与子字符串curNeedle指向的字符相等，移动母字符串中的rightHaystack指针和子字符串中的rightHaystack指针</span></span><br><span class="line">            <span class="keyword">while</span> (haystack.charAt(rightHaystack) == needle.charAt(curNeedle)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curNeedle == lenNeedle - <span class="number">1</span>) &#123;   <span class="comment">// 如果子字符串遍历结束，则直接返回leftHaystack即可</span></span><br><span class="line">                    <span class="keyword">return</span> leftHaystack;</span><br><span class="line">                &#125;</span><br><span class="line">                rightHaystack++;</span><br><span class="line">                curNeedle++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果母字符串中rightHaystack指向的字符与子字符串curNeedle指向的字符不相等</span></span><br><span class="line">            <span class="comment">// 移动母字符串中的leftHaystack指针和rightHaystack指针</span></span><br><span class="line">            <span class="comment">// 并将子字符串中的curNeedle指针初始化</span></span><br><span class="line">            leftHaystack++;</span><br><span class="line">            rightHaystack = leftHaystack;</span><br><span class="line">            curNeedle = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/09/LeetCode-28-实现strStr/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A28_ImplementstrStr.java" target="_blank" rel="noopener">LeetCode-28 实现strStr()</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">实现strStr()</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：28. 实现strStr()&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="字符串" scheme="http://JacobLei.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-27 移除元素</title>
    <link href="http://JacobLei.github.io/2019/06/08/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>http://JacobLei.github.io/2019/06/08/LeetCode-27-移除元素/</id>
    <published>2019-06-08T14:11:04.000Z</published>
    <updated>2019-06-09T02:36:16.704Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：27. 移除元素</li><li>难度：简单</li><li>分类：数组</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第27题<strong>移除元素</strong>，这个题目和昨天的<a href="https://www.jacob2359.com/2019/06/07/LeetCode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" target="_blank" rel="noopener">LeetCode-26 删除排序数组中的重复项</a>原理一样。我们先看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个数组<code>nums</code>和一个值 <code>val</code>，你需要原地移除所有数值等于<code>val</code>的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组并在使用<code>O(1)</code> 额外空间</strong>的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我相信小伙伴们看完这个后都会有思路，这个题目和<a href="https://www.jacob2359.com/2019/06/07/LeetCode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" target="_blank" rel="noopener">LeetCode-26 删除排序数组中的重复项</a>原理一样，也是使用双指针方法去解决，需要说明一下我们这里说的<strong>指针</strong>的含义，它不是狭义上C语言中的指针，而是一种思想，它是<strong>利用一个值去寻找另一个值</strong>的方法，如下图所示：<br><img src="/2019/06/08/LeetCode-27-移除元素/指针理解.png" title="指针理解"></p><p>因此指针一个值的地址(C语言中的指针)，也可以是数组中的下标(index)。在这个题目中双指针就是两个数组的下标，通过维护数组的下标来改变原来的数组。对示例1的详细分析过程如下所示：<br><img src="/2019/06/08/LeetCode-27-移除元素/示例1详细分析过程.png" title="示例1详细分析过程"></p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化slow指针</span></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始fast指针，并遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fast=<span class="number">0</span>; fast&lt;nums.length; fast++)&#123;</span><br><span class="line">            <span class="comment">// 当前数不为val时，才把该保存在数组中</span></span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val )&#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/08/LeetCode-27-移除元素/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A27_RemoveElement.java" target="_blank" rel="noopener">LeetCode-27 移除元素</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">删除排序数组中的重复项</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：27. 移除元素&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-26 删除排序数组中的重复项</title>
    <link href="http://JacobLei.github.io/2019/06/07/LeetCode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://JacobLei.github.io/2019/06/07/LeetCode-26-删除排序数组中的重复项/</id>
    <published>2019-06-07T12:16:20.000Z</published>
    <updated>2019-06-08T14:32:51.500Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：26. 删除排序数组中的重复项</li><li>难度：简单</li><li>分类：数组</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第26题<strong>删除排序数组中的重复项</strong>，这是一道简单题。像这样数组的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p><strong>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成</strong>。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题目的是删除已经排好序的数组的重复项，题目中的示例已经进行了详细说明。对这个题目的题意理解不难，就是返回数组中不重复项的个数，并在原数组上去掉重复项。细心的小伙伴可能观察到，在测试用例中输入<code>[1,1,2]</code>，返回的是<code>[1,2]</code>，而不是数组中不重复项的个数。这一点在题目中的<strong>说明部分</strong>已经解释了，简单点理解就是<strong>在测试的时候返回的是修改后的没有重复项的数组</strong>。</p><p>对于示例1的详细分析过程如下所示：<br><img src="/2019/06/07/LeetCode-26-删除排序数组中的重复项/示例1详细分析过程.png" title="示例1详细分析过程"></p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">1</span>;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(slow &lt; fast &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当出现重复项的时候，移动fast指针</span></span><br><span class="line">            <span class="keyword">while</span>(nums[slow] == nums[fast])&#123;</span><br><span class="line">                fast++;</span><br><span class="line">                <span class="keyword">if</span>(fast == nums.length)</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 当不是重复项是，原地删除重复项（即将后面的数移动到前面来）</span></span><br><span class="line">            <span class="comment">// ++slow;</span></span><br><span class="line">            <span class="comment">// nums[slow] = nums[fast];</span></span><br><span class="line">            <span class="comment">// fast++;</span></span><br><span class="line">            <span class="comment">// 可以写出下面的表达形式，这里注意++i与i++的区别</span></span><br><span class="line">            nums[++slow] = nums[fast++];</span><br><span class="line">            </span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/07/LeetCode-26-删除排序数组中的重复项/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A26_RemoveDuplicatesfromSortedArray.java" target="_blank" rel="noopener">LeetCode-26 删除排序数组中的重复项</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除排序数组中的重复项</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：26. 删除排序数组中的重复项&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-24 两两交换链表中的节点</title>
    <link href="http://JacobLei.github.io/2019/06/06/LeetCode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://JacobLei.github.io/2019/06/06/LeetCode-24-两两交换链表中的节点/</id>
    <published>2019-06-06T07:20:16.000Z</published>
    <updated>2019-06-06T08:50:27.890Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：24. 两两交换链表中的节点</li><li>难度：中等</li><li>分类：链表</li><li>解决方案：节点的交换<a id="more"></a></li></ul><p>今天我们学习第24题<strong>两两交换链表中的节点</strong>，这是一道中等题。像这样链表的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换</strong>。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题为基础的链表节点操作题，是将链表的节点两两进行交换，而且必须是交换节点不能仅仅只改变链表的值。像这样的题，需要画一个图，来弄清楚指针的位置。对示例的详细分析过程如下图所示：<br><img src="/2019/06/06/LeetCode-24-两两交换链表中的节点/示例详细分析过程.png" title="示例详细分析过程"></p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 申请res结点和pre</span></span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), pre = res;</span><br><span class="line">        res.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 具体分析详见示意图</span></span><br><span class="line">            ListNode node = pre.next.next;</span><br><span class="line">            pre.next.next = node.next;</span><br><span class="line">            node.next = pre.next;</span><br><span class="line">            pre.next = node;</span><br><span class="line">            pre = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/06/LeetCode-24-两两交换链表中的节点/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A24_SwapNodesinPairs.java" target="_blank" rel="noopener">LeetCode-24 两两交换链表中的节点</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表中的节点</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：24. 两两交换链表中的节点&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：链表&lt;/li&gt;
&lt;li&gt;解决方案：节点的交换
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="链表" scheme="http://JacobLei.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-分治算法</title>
    <link href="http://JacobLei.github.io/2019/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://JacobLei.github.io/2019/06/05/数据结构与算法-分治算法/</id>
    <published>2019-06-05T08:42:38.000Z</published>
    <updated>2019-06-11T07:25:35.120Z</updated>
    
    <content type="html"><![CDATA[<p>本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。</p><a id="more"></a><h1 id="如何理解分治算法？"><a href="#如何理解分治算法？" class="headerlink" title="如何理解分治算法？"></a>如何理解分治算法？</h1><p><strong>分治算法</strong>主要理解<strong>分而治之</strong>四个字，即<strong>将大问题划分成n个规模较小，并且结构与原问题相似的子问题，然后递归地解决这些子问题，最后结合子问题的结果，得到原问题的解</strong>。具体的步骤为：</p><ul><li>“分”——将一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题</li><li>“治”——将最后子问题可以简单的直接求解</li><li>“合”——将所有子问题的解合并起来就是原问题的解</li></ul><h2 id="分治算法能解决的问题满足的几个条件："><a href="#分治算法能解决的问题满足的几个条件：" class="headerlink" title="分治算法能解决的问题满足的几个条件："></a>分治算法能解决的问题满足的几个条件：</h2><ul><li><p>原问题与分解成的小问题具有相同的模式</p></li><li><p>原问题分解成的子问题可以独立求解，子问题之间没有相关性（这里注意与<a href="https://www.jacob2359.com/2019/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="noopener">动态规划</a>的区别）</p></li><li><p>具有分解终止条件，也就是说，当问题足够小时，可以直接求解</p></li><li><p>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果</p></li></ul><h2 id="分治算法与递归"><a href="#分治算法与递归" class="headerlink" title="分治算法与递归"></a>分治算法与递归</h2><p>分治算法与递归区别<strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及以下三个操作：</p><ul><li>分解：将原问题分解成一系列子问题</li><li>解决：递归地求解各个子问题，若子问题足够小，则直接求解</li><li>合并：将子问题的结果合并成原问题</li></ul><h1 id="分治算法应用分析"><a href="#分治算法应用分析" class="headerlink" title="分治算法应用分析"></a>分治算法应用分析</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是利用<strong>归并</strong>的思想实现的排序方法，主要采用的是<strong>分治</strong>策略进行排序。其详细过程如图所示：</p><img src="/2019/06/05/数据结构与算法-分治算法/归并排序.png" title="归并排序"><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a><br><a href="https://time.geekbang.org/column/article/73503" target="_blank" rel="noopener">分治算法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="分治算法" scheme="http://JacobLei.github.io/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-22 括号生成</title>
    <link href="http://JacobLei.github.io/2019/06/04/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>http://JacobLei.github.io/2019/06/04/LeetCode-22-括号生成/</id>
    <published>2019-06-04T07:15:14.000Z</published>
    <updated>2019-06-04T08:15:51.014Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：22. 括号生成</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：链表的遍历<a id="more"></a></li></ul><p>今天我们学习第22题<strong>括号生成</strong>，这是一道中等题。像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">题目描述</a></h1><p>给出<code>n</code>代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出<code>n = 3</code>，生成结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题是<strong>递归</strong>方面的题，对于递归不太熟悉的小伙伴可以扫描文章下方的二维码，关注『 算法半岛』回复『 数据结构目录』，即可获得相关学习资料。</p><p>对于递归的问题，我们需要明白以下三点：</p><ul><li><strong>一个问题的解可以分解为几个子问题的解</strong>：对于这个括号生成的题，当<code>n=3</code>时问题的解可以分成<code>n=2</code>时问题的解；</li><li><strong>子问题除了数据规模不同，求解思路完全一样</strong>：对于这个括号生成的题，当<code>n=3</code>时问题的解的解思路和<code>n=2</code>时问题的解的解思路完全一样，只是问题规模减小了；</li><li><strong>必须存在递归终止条件</strong>：对于这个括号生成的题，我们需要使用两个变量<code>left</code>和<code>right</code>来记录可使用的左括号数和右括号数，如当<code>n=3</code>时，初始化<code>left=3</code>和<code>right=3</code>，当<code>left&gt;right</code>时说明可以使用的左括号数大于可以使用的右括号数，即已经使用的右括号数比左括号数多，则会出现无效的括号对数，因此<code>left&gt;right</code>可作为本题的递归终止条件。还有当<code>left&lt;0</code>或则<code>right&lt;0</code>也是递归终止条件。</li></ul><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        helper(n, n, <span class="string">""</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归辅助函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String out, List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span> || left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 当left和right都为0时，保存有效的括号组</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(out);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减小问题的规模</span></span><br><span class="line">        helper(left-<span class="number">1</span>, right, out + <span class="string">"("</span>, res);</span><br><span class="line">        helper(left, right-<span class="number">1</span>, out + <span class="string">")"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/04/LeetCode-22-括号生成/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A22_GenerateParentheses.java" target="_blank" rel="noopener">LeetCode-22 括号生成</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：22. 括号生成&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：链表的遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="字符串" scheme="http://JacobLei.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="递归" scheme="http://JacobLei.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-21 合并两个有序链表</title>
    <link href="http://JacobLei.github.io/2019/06/03/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://JacobLei.github.io/2019/06/03/LeetCode-21-合并两个有序链表/</id>
    <published>2019-06-03T12:56:37.000Z</published>
    <updated>2019-06-04T08:15:23.126Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：21. 合并两个有序链表</li><li>难度：简单</li><li>分类：链表</li><li>解决方案：链表的遍历<a id="more"></a></li></ul><p>今天我们学习第21题<strong>合并两个有序链表</strong>，这是一道简单题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">题目描述</a></h1><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这是一个链表题，这个比较简单，用下面的示意图表示示例的分析过程：<br><img src="/2019/06/03/LeetCode-21-合并两个有序链表/示例详细分析过程.png" title="示例详细分析过程"></p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建head节点和cur指针</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历两个链表，将较小值的节点连接cur节点后</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断哪个链表不为空，如不为空，则直接连接到cur节点后</span></span><br><span class="line">        cur.next = (l1 != <span class="keyword">null</span>) ? l1 : l2;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回head的下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/03/LeetCode-21-合并两个有序链表/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A21_MergeTwoSortedLists.java" target="_blank" rel="noopener">LeetCode-21 合并两个有序链表</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：21. 合并两个有序链表&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：链表&lt;/li&gt;
&lt;li&gt;解决方案：链表的遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="链表" scheme="http://JacobLei.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-20 有效的括号</title>
    <link href="http://JacobLei.github.io/2019/06/02/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://JacobLei.github.io/2019/06/02/LeetCode-20-有效的括号/</id>
    <published>2019-06-02T10:40:15.000Z</published>
    <updated>2019-06-02T13:03:08.892Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：20. 有效的括号</li><li>难度：简单</li><li>分类：栈</li><li>解决方案：入栈出栈</li></ul><a id="more"></a><p>今天我们学习第20题<strong>有效的括号</strong>，这是一道关于栈的简单题，对熟悉栈的基本使用很有帮助。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个只包括 <code>(</code>，<code>)</code>，<code>{</code>，<code>}</code>，<code>[</code>，<code>]</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><p>注意空字符串可被认为是有效字符串。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题是目前为止遇到的第一个<strong>栈</strong>相关题目，对于栈不太熟悉的小伙伴可以扫描文章下方的二维码，关注『 算法半岛』回复『 数据结构目录』，即可获得相关学习资料。</p><p>对于这个题，我们借助一个栈，遍历字符串时，当遇到<code>(</code>、<code>{</code>或<code>[</code>时，将字符入栈；当遇到<code>)</code>、<code>}</code>或<code>]</code>时，判断栈顶是否为其对应的左括号，如果对应得上，弹出栈顶元素，如果栈顶为空或则对应不上，则返回<code>false</code>。对示例5的详细示意图如下所示：</p><img src="/2019/06/02/LeetCode-20-有效的括号/示例5详细示意图.png" title="示例5详细示意图"><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 申请栈</span></span><br><span class="line">         Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将字符串转化为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;chars.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 判断当前字符是否为 '(' 、'[' 或 '&#123;'</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">'('</span> || chars[i] == <span class="string">'['</span> || chars[i] == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果时，则入栈</span></span><br><span class="line">                stack.push(chars[i]);   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果不是，则为')'、']'或'&#125;''，判断栈中是否有对应的左括号</span></span><br><span class="line">                <span class="keyword">if</span> (stack.empty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">char</span> c = stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> ((chars[i] == <span class="string">')'</span> &amp;&amp; c != <span class="string">'('</span>) || (chars[i] == <span class="string">']'</span> &amp;&amp; c != <span class="string">'['</span>) || (chars[i] == <span class="string">'&#125;'</span> &amp;&amp; c != <span class="string">'&#123;'</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只有当栈为空时，才为true</span></span><br><span class="line">        <span class="keyword">return</span> stack.empty() ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/02/LeetCode-20-有效的括号/提交结果.png" title="快慢提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A20_ValidParentheses.java" target="_blank" rel="noopener">LeetCode-20 有效的括号</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：20. 有效的括号&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：栈&lt;/li&gt;
&lt;li&gt;解决方案：入栈出栈&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="栈" scheme="http://JacobLei.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-19 删除链表中的倒数第N个节点</title>
    <link href="http://JacobLei.github.io/2019/05/31/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://JacobLei.github.io/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/</id>
    <published>2019-05-31T08:50:22.000Z</published>
    <updated>2019-06-09T02:54:29.455Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：19. 删除链表中的倒数第N个节点</li><li>难度：中等</li><li>分类：链表</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第19题<strong>删除链表中的倒数第N个节点</strong>，这是一道中等题。这个题属于面试中的高频题，一定要能手写出来。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个链表，删除链表的倒数第<code>n</code>个节点，并且返回链表的头结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure></p><p>说明：<strong>给定的<code>n</code>保证是有效的。</strong></p><p>进阶：<strong>你能尝试使用一趟扫描实现吗？</strong></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题是目前为止遇到的第一个链表题，对于链表不太熟悉的小伙伴可以扫描文章下方的二维码，关注『 算法半岛』回复『 数据结构目录』，即可获得相关学习资料。</p><p>这个题让我们删除链表中的倒数第<code>n</code>个节点，并且返回头节点。题目中说明部分提到<strong>给定的<code>n</code>保证是有效的</strong>，因此<code>n</code>的值小于等于链表的长度。最基本的方法，我们可以先遍历一次链表，统计链表的长度<code>len</code>，则删除的节点位置为<code>len-n+1</code>。然后找到删除节点位置的前一个节点(位置为<code>len-n</code>)对节点进行删除即可。注意<strong>如果删除的节点为第一个节点，则直接返回<code>head.next</code>即可</strong>。对示例分析如下图所示：</p><img src="/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/两次遍历方法.png"><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计链表节点的个数</span></span><br><span class="line">        <span class="keyword">while</span>(p.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算删除节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = len - n + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除节点如果为第一个节点，则直接返回head.next</span></span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重置p指针的位置</span></span><br><span class="line">        p = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找需要删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;pos-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除该节点</span></span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/两次遍历提交结果.png" title="两次遍历提交结果"><p>进阶部分提示我们<strong>尝试使用一趟扫描实现</strong>，对于这样的题，我们可以使用双指针(快慢指针)来实现。具体分析过程如下图所示：</p><img src="/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/快慢指针法.png"><p>值得注意的是，<strong>当删除的结点为第一个节点，则<code>fast==null</code>，因此在<code>fast</code>走<code>n</code>步后需要判断<code>fast</code>是否为<code>null</code>，如果为<code>null</code>则直接返回<code>fast.next</code></strong>。</p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 声明快慢指针</span></span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fast指针走n步</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;          </span><br><span class="line">            fast = fast.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断需要删除的节点是否为第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同时移动快慢指针</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/提交结果.png" title="快慢提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A19_RemoveNthNodeFromEndofList.java" target="_blank" rel="noopener">LeetCode-19 删除链表中的倒数第N个节点</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表中的倒数第N个节点</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：19. 删除链表中的倒数第N个节点&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：链表&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="链表" scheme="http://JacobLei.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
