<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jacob2359</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://JacobLei.github.io/"/>
  <updated>2019-05-19T08:43:18.771Z</updated>
  <id>http://JacobLei.github.io/</id>
  
  <author>
    <name>jacob2359</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-6 Z字形变换</title>
    <link href="http://JacobLei.github.io/2019/05/19/LeetCode-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://JacobLei.github.io/2019/05/19/LeetCode-6-Z字形变换/</id>
    <published>2019-05-19T08:39:24.000Z</published>
    <updated>2019-05-19T08:43:18.771Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：6. Z字形变换</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：字符串遍历<a id="more"></a></li></ul><p>今天我们学习第5题<strong>Z字形变换</strong>，这是一个字符串的中等题，像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">题目描述</a></h1><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为<code>&quot;LEETCODEISHIRING&quot;</code>行数为3时，排列如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：6. Z字形变换&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：字符串遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-5 最长回文子串</title>
    <link href="http://JacobLei.github.io/2019/05/13/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://JacobLei.github.io/2019/05/13/LeetCode-5-最长回文子串/</id>
    <published>2019-05-13T13:02:42.000Z</published>
    <updated>2019-05-13T14:55:40.210Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：5. 最长回文子串</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第5题<strong>最长回文子串</strong>，这是一个字符串的中等题，像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。你可以假设<code>s</code>的最大长度为1000。</p><p>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure></p><p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>读完这道题后，我们发现一个新名词<strong>回文子串</strong>，什么是回文子串？首先我们先理解什么是<strong>回文串</strong>，就是从左向右读和从右向左读的结果是一样的字符串，如’abcba’。回文子串就是在给定字符串中寻找回文串。我们想想该如何寻找？</p><p>最简单直观的方法是遍历字符串，遍历的时候以每个字符为中心向左右两侧扩散。如图1所示。<br><img src="/2019/05/13/LeetCode-5-最长回文子串/查找回文子串示意图.png" title="图1.查找回文子串示意图"></p><p>聪明的小伙伴们已经发现了上述解题思路对回文子串长度为偶数就不适用了，如示例2用上图的方法分析出来的结果就不正确。那该怎么办呢？解决办法很简单，对于奇数，我们以该字符为中心向两边扩散；对于偶数，我们以该字符和下一个字符作为中心字符，然后向两边扩散。具体见下面<code>java</code>代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">// 回文子串为奇数时，查找最长回文子串</span></span><br><span class="line">            extendPalindrome(s, i, i);</span><br><span class="line">            <span class="comment">// 回文子串为偶数时，查找最长回文子串</span></span><br><span class="line">            extendPalindrome(s, i, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extendPalindrome</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否为回文子串，若是，则左指针向左移动，右指针向右移动</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回文子串查找完成后，判断刚刚查找的回文子串是否为最长回文子串，若是，则更新起始位置和最长长度</span></span><br><span class="line">        <span class="keyword">if</span>(maxLen &lt; right-left-<span class="number">1</span>)&#123;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">            maxLen = right -left - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/13/LeetCode-5-最长回文子串/提交结果.png" title="图2.提交结果"><p>整个算法流程的时间复杂度为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>。</p><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A5_LongestPalindromicSubstring.java" target="_blank" rel="noopener">LeetCode-5 最长回文子串</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode.com/problems/longest-palindromic-substring/discuss/2928/Very-simple-clean-java-solution" target="_blank" rel="noopener">5.最长回文子串</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：5. 最长回文子串&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题宝典</title>
    <link href="http://JacobLei.github.io/2019/05/13/LeetCode%E5%88%B7%E9%A2%98%E5%AE%9D%E5%85%B8/"/>
    <id>http://JacobLei.github.io/2019/05/13/LeetCode刷题宝典/</id>
    <published>2019-05-13T09:46:31.000Z</published>
    <updated>2019-05-14T02:28:51.169Z</updated>
    
    <content type="html"><![CDATA[<p>聊聊如何刷LeetCode</p><a id="more"></a><p>对于LeetCode，我相信计算机专业或相关专业的同学都有所耳闻。在找工作时，常常听到某某大神刷了2遍LeetCode最后拿到9个offer等等传说。可见LeetCode的重要性。下面我们聊一聊该怎么去刷LeetCode。</p><p>首先简单了解一下传说中的<a href="https://leetcode.com" target="_blank" rel="noopener">LeetCode</a>，它其实就是美国在线编程网站，上面收集了各大IT公司的笔试题和面试题，对于要找工作的小伙伴来说，LeetCode是一个不可多得的好帮手。Wait~~<strong>美国在线编程网站</strong>？？？全英文？？？其实不是这样的，LeetCode也有相应的中文网站——<a href="https://leetcode-cn.com" target="_blank" rel="noopener">力扣</a>，对英文刷题吃力的小伙伴们赶紧收藏。对于哪些人适合刷LeetCode？我认为从事编程工作的人员都应该去刷，不论是已经工作的”程序猿”还是在校学生，特别是将要找工作或找实习的在校学生是最需要刷LeetCode，如果想进大厂，必须得刷LeetCode。</p><p>那么，该如何去刷呢？我们先来看一看LeetCode网站，如下图1所示。<br><img src="/2019/05/13/LeetCode刷题宝典/力扣首页.png" title="图1.力扣首页"></p><p>注册并登陆后我们进入题库界面，如图2所示，选择标签和难度。<br><img src="/2019/05/13/LeetCode刷题宝典/力扣问题页.png" title="图2.力扣问题页"><br>到目前为止，总共右39个标签，我们可以按标签来刷题，比如我们今天做<strong>栈</strong>，我们先在标签页中选择栈，然后再选择适当难度，就可以开始做题了。</p><p>一般建议对于一个标签，我们先做2~3到简单题，熟悉其基本的算法思路后，然后做中等题，做了5~8道中等题后再去挑战困难题。读于刚刚开始接触某一个标签题型时，很难自己想出题目的求解答案，这时候一定不要灰心。<strong>对于一道题思考5分钟后如果还没有解题思路，我们可以去看该题目相关博客（如公众号：jacob2359 或 <a href="https://www.jacob2359.com/categories/LeetCode/" target="_blank" rel="noopener">jacob2359的博客</a>）或者查看该题目的讨论部分（讨论部分建议看英文网站上的）</strong>。查看该题的讨论部分具体方法如图3-4所示。<br><img src="/2019/05/13/LeetCode刷题宝典/leetcode讨论页.png" title="图3.leetcode讨论页"><br><img src="/2019/05/13/LeetCode刷题宝典/leetcode讨论页2.png" title="图4.leetcode讨论页"></p><p>通过查看博客和讨论部分后对该题有基本思路，我们再去做这道题。对于同一类标签的题做多后，我们对这一类标签的题就会熟悉，下次遇到同样主题的题目就不会完全没有思路。</p><p>对于有些小伙伴没有数据结构基础，推荐先看陈越老师和何钦铭老师的《数据结构》课程，也可以查看《算法 ：LeetCode刷题》，相关课程的资源，可扫一扫下方二维码，关注公众号，发送『 算法资源』即可获取。</p><p>对于有些小伙伴纠结使用什么语言的问题，其实完全不用纠结，使用一门你熟悉的语言即可。如果一门都不熟悉，推荐使用Java来刷题。</p><p>最后也是最重要的，一定要坚持，坚持每天都刷题，遇到难题后不要灰心，静下心来看看别人的解题思路，看懂后自己再总结，要相信自己一定可以把它弄懂的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;聊聊如何刷LeetCode&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="学习方法" scheme="http://JacobLei.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-4 寻找两个有序数组的中位数</title>
    <link href="http://JacobLei.github.io/2019/05/12/LeetCode-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://JacobLei.github.io/2019/05/12/LeetCode-4-寻找两个有序数组的中位数/</id>
    <published>2019-05-12T11:56:22.000Z</published>
    <updated>2019-05-12T15:06:10.015Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：4. 寻找两个有序数组的中位数</li><li>难度：困难</li><li>分类：数组</li><li>解决方案：二分查找、分治算法<a id="more"></a></li></ul><p>今天我们学习第4题<strong>寻找两个有序数组的中位数</strong>，这是我们遇到的第一个困难题。这个题目很新颖，需要打破常规思维去思考。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">题目描述</a></h1><p>给定两个大小为<code>m</code>和<code>n</code>的有序数组<code>nums1</code>和<code>nums2</code>。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为<code>O(log(m + n))</code>。<br>你可以假设<code>nums1</code>和<code>nums2</code>不会同时为空。<br>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure></p><p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>从题目可以知道，需要让我们在两个有序数组中找中位数。我们先分析一个有序数组的中位数，当有序数组的个数为奇数时，如<code>nums=[1, 2, 3, 4, 5]</code>，该数组的中位数为<code>nums[2]=3</code>；当有序数组的个数为偶数时，如<code>nums=[1, 2, 3, 4, 5, 6]</code>，该数组的中位数为<code>(nums[2]+nums[3])/2=3.5</code>。如图1所示，我们用同一公式可求出任意个数有序数组的中位数。<br><img src="/2019/05/12/LeetCode-4-寻找两个有序数组的中位数/中位数求解思路.png" title="图1.中位数求解思路"></p><p>理解一个有序数组中位数求解过程后，对于两个有序数组来说，我们只要找出第<code>(m+n+1)/2</code>大的数和第<code>(m+n+2)/2</code>大的数，然后求平均数即可。注意这里的第<code>(m+n+1)/2</code>大的数中<code>m</code>和<code>n</code>分别指两个数组的大小，<code>m+n</code>如图1中的<code>muns.length</code>，第<code>(m+n+1)/2</code>大的数是指我们假设这两个数组组合成一个有序数组后找出第<code>(m+n+1)/2</code>大的数（这里为什么没有像图1中进行减1？因为我们这里说的第几大的数下标是从1开始的；而图1中需要减1是因为使用的数组，下标是从0开始的）。</p><p>接下来我们在这两个有序数组中找到第<code>(m+n+1)/2</code>大的数和第<code>(m+n+2)/2</code>大的数，抽象后可表述为在两个有序数组中找第k大的数。由于题目要求我们的时间复杂度为<code>O(log(m+n))</code>，我们很容易联想到二分查找。当查找时，我们还需要考虑一些特殊情况：(1) 当某个数组查找的起始位置大于等于该数组长度时，说明这个数组中的所有数已经被淘汰，则只需要在另一个数组找查找即可。(2)如果<code>k=1</code>时，即需要查找第一个数，则找到两个数组起始位置中最小的那个即可。处理完特殊情况后，我们来分析一般情况。这里所说的二分是指对数组的大小进行二分还是指对<code>k</code>进行二分。以前我们对一维数组进行二分查找时，一般都是对数组大小进行二分，而这里需要对<code>k</code>进行二分。意思是，我们需要在两个数组查找第<code>k/2</code>大的数，由于这两个数组的长度不定，有可能存在有一个数组中没有第<code>k/2</code>大的数，如果没有则赋值为整型最大值。对于查找的具体过程，详见<code>java</code>代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length, n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> l = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> r = (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, l) + getKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, r)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在两个有序数组中二分查找第k大元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况(1)，分析见正文部分</span></span><br><span class="line">        <span class="keyword">if</span>(start1 &gt; nums1.length-<span class="number">1</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(start2 &gt; nums2.length-<span class="number">1</span>) <span class="keyword">return</span> nums1[start1 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 特征情况(2)，分析见正文部分</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分别在两个数组中查找第k/2个元素，若存在（即数组没有越界），标记为找到的值；若不存在，标记为整数最大值</span></span><br><span class="line">        <span class="keyword">int</span> nums1Mid = start1 + k/<span class="number">2</span> - <span class="number">1</span> &lt; nums1.length ? nums1[start1 + k/<span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> nums2Mid = start2 + k/<span class="number">2</span> - <span class="number">1</span> &lt; nums2.length ? nums2[start2 + k/<span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确定最终的第k/2个元素，然后递归查找</span></span><br><span class="line">        <span class="keyword">if</span>(nums1Mid &lt; nums2Mid)</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1 + k/<span class="number">2</span>, nums2, start2, k-k/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1, nums2, start2 + k/<span class="number">2</span>, k-k/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/12/LeetCode-4-寻找两个有序数组的中位数/提交结果.png" title="提交结果"><p>整个算法流程的时间复杂度为<code>O(log(m+n))</code>，空间复杂度为<code>O(1)</code>。</p><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A4_MedianofTwoSortedArrays.java" target="_blank" rel="noopener">LeetCode-4 寻找两个有序数组的中位数</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2496/Concise-JAVA-solution-based-on-Binary-Search" target="_blank" rel="noopener">4. 寻找两个有序数组的中位数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：4. 寻找两个有序数组的中位数&lt;/li&gt;
&lt;li&gt;难度：困难&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：二分查找、分治算法
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-3 无重复字符的最长子串</title>
    <link href="http://JacobLei.github.io/2019/05/10/LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://JacobLei.github.io/2019/05/10/LeetCode-3-无重复字符的最长子串/</id>
    <published>2019-05-10T11:41:20.000Z</published>
    <updated>2019-05-12T11:53:36.832Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：3. 无重复字符的最长子串</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：双指针、滑动窗口</li></ul><a id="more"></a><p>LeetCode前几道题都是经典题，今天我们学习第3题<strong>无重复字符的最长子串</strong>，这道题在秋招面试中遇见过，再次相遇，如此亲切。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个字符串，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。<br>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure></p><p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure></p><p>示例3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先我们看看这个题的示例3，该示例中提示我们这个题需要求的字符串的<strong>子串</strong>而不是<strong>子序列</strong>，我们具体来看看什么是子串，什么是子序列。</p><blockquote><p>子串：字符串中任意个<strong>连续</strong>的字符组成的子序列称为该串的子串。注意子串强调字符的连续性。<br><img src="/2019/05/10/LeetCode-3-无重复字符的最长子串/子串.png" title="子串"><br>子序列：字符串中去掉任意个元素后得到的结果即为该字符串的子序列。注意子序列中字符出现的次序与原字符串中字符出现的次序要保持一致。<br><img src="/2019/05/10/LeetCode-3-无重复字符的最长子串/子序列.png" title="子序列"></p></blockquote><p>区分子串和子序列后，我们再回过头来看看这个题。我们先动手画一画示例1的解题过程，如下图所示：<br><img src="/2019/05/10/LeetCode-3-无重复字符的最长子串/示例1分析过程.png" title="示例1分析过程"><br>从上图我们可以观察出，可以使用双指针（<code>left</code>指针和<code>right</code>指针）来维护一个滑动窗口，这个窗口内的字符都是没有重复的，遍历一趟字符串后就可以得到最大的子串，因此时间复杂度为<code>O(n)</code>。现在想一个问题：<strong><code>right</code>指针指向的字符怎么确定它在前面是否出现过，若出现过，它出现的位置在哪儿？</strong>对于这个问题，做过<a href="https://www.jacob2359.com/2019/05/04/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/#more" target="_blank" rel="noopener">LeetCode-1 两数之和</a>这道题的小伙伴们应该知道，我们可以使用<code>HashMap</code>记录一个字符是否出现以及出现后的位置。对于重复多次出现的字符，我们是保留所有出现的位置还是只记录一个位置？观察示例1分析过程可以知道，我们只需要保存一个最大位置即可。还有一个关键点，我们如何确定<code>left</code>指针的位置？这一点非常重要，需要分情况讨论。</p><ul><li>当目前<code>right</code>指针指向的字符未出现过，<code>left</code>指针不需要移动；</li><li>当目前<code>right</code>指针指向的字符出现过，如果该字符在窗口中，即该字符出现在当前<code>left</code>指针的右边，则通过<code>HashMap</code>获取字符的位置并向右移动一位即为更新后<code>left</code>的位置；如果该字符在窗口外面，即在当前<code>left</code>指针的左边，则不需要移动<code>left</code>的位置。<br>分析完后，再看看<code>java</code>代码的具体实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 创建HashMap，用来保存字符与位置之间的对应关系</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化左指针和右指针，并遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.length(); right++)&#123;</span><br><span class="line">            <span class="comment">// 判断右指针指向的字符是否出现过</span></span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                <span class="comment">// 确定左指针的位置</span></span><br><span class="line">                left = Math.max(left, hashMap.get(s.charAt(right))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于第一次出现的字符，保存该字符的位置；对于多次出现的字符，更新该字符出现的位置</span></span><br><span class="line">            hashMap.put(s.charAt(right), right);</span><br><span class="line">            <span class="comment">// 更新窗口的大小，保存最大的窗口大小</span></span><br><span class="line">            res = Math.max(res, right-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><img src="/2019/05/10/LeetCode-3-无重复字符的最长子串/提交结果.png" title="提交结果"><p>整个算法流程的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>。</p><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A3_LongestSubstringWithoutRepeatingCharacters.java" target="_blank" rel="noopener">LeetCode-3 无重复字符的最长子串</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：3. 无重复字符的最长子串&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：双指针、滑动窗口&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-2 两数相加</title>
    <link href="http://JacobLei.github.io/2019/05/09/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://JacobLei.github.io/2019/05/09/LeetCode-2-两数相加/</id>
    <published>2019-05-09T14:33:36.000Z</published>
    <updated>2019-05-12T11:53:21.944Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：2. 两数相加</li><li>难度：中等</li><li>分类：链表</li><li>解决方案：链表的遍历</li></ul><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">题目描述</a></h1><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>注意：您可以假设除了数字0之外，这两个数都不会以0开头。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题理解起来难度不大，就是将数字从个位数开始将数字放到链表的各个结点上，如下所示：<br><img src="/2019/05/09/LeetCode-2-两数相加/链表表示数字.png" title="链表表示数字"><br>然后两个链表的对应位置上的数字相加，将相加的值保存到结果链表中。这里需要注意两个关键点：一是如果两个值相加大于9该怎么办？二是两个链表长度不一致该怎么办？<br>对于关键点一：我们需要借助一个进位标识<code>carry</code>，当两数之和大于9时将<code>carry</code>标识为1，否则标识为0。<br>对于关键点二：我们以最长链表作为终点，对于较短链表对应位置的数值，我们用0来补齐。<br>下面分析一个具体实例，该实例包含上述两个关键点，如下图所示：<br><img src="/2019/05/09/LeetCode-2-两数相加/两数相加.png" title="两数相加"><br>如上图所示，数字342的链表较短，数字7465的链表较长。当两个数字的第二个结点相加时，它们的和为10，这时就需要进位，即<code>carry=1</code>，且将个位数保留作为结果链表的值。当较短的链表指向为<code>null</code>结点时，较长的链表指向的值为7，这需要将较短链表的值设置为0，即结果为0+7。<br>通过上面分析后，再看看如下<code>java</code>便一目了然。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建结果链表的头节点，默认该节点中的value为-1</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="comment">// 进位标识carry，默认为0</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历链表，当两个链表都为空时，退出</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 判断该节点是否为空，当结点为空时，用0补齐；不为空时，加数即为节点的值</span></span><br><span class="line">            <span class="keyword">int</span> d1 = (l1 == <span class="keyword">null</span>) ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> d2 = (l2 == <span class="keyword">null</span>) ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="comment">// 对结点求和，注意：求和是需要考虑到进位</span></span><br><span class="line">            <span class="keyword">int</span> sum = d1 + d2 + carry;</span><br><span class="line">            <span class="comment">// 更新进位标识</span></span><br><span class="line">            carry = (sum &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// sum%10标识求和的个位数，将其保存到结果链表中</span></span><br><span class="line">            pre.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重点，这是一个特殊情况，当两个链表计算完后，</span></span><br><span class="line">        <span class="comment">// 还需要判断进位标识是否为1，如果为1，如23+81=104，需要创建一个结点保存最高位</span></span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)</span><br><span class="line">            pre.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/09/LeetCode-2-两数相加/两数相加计算结果.png" title="两数相加计算结果"><p>对于时间复杂度和空间复杂度，该题都为O(n)。</p><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A2_AddTwoNumbers.java" target="_blank" rel="noopener">LeetCode-2 两数相加</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/" target="_blank" rel="noopener">2. 两数之和</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：2. 两数相加&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：链表&lt;/li&gt;
&lt;li&gt;解决方案：链表的遍历&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>[spring实战]1-自动化装配bean</title>
    <link href="http://JacobLei.github.io/2019/05/04/spring%E5%AE%9E%E6%88%981-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A3%85%E9%85%8Dbean/"/>
    <id>http://JacobLei.github.io/2019/05/04/spring实战1-自动化装配bean/</id>
    <published>2019-05-04T14:16:38.000Z</published>
    <updated>2019-05-04T15:33:28.277Z</updated>
    
    <content type="html"><![CDATA[<p>Spring提供三种主要的装备机制：</p><ul><li>在XML中进行显示配置</li><li>在Java中进行显示配置</li><li>隐式的bean发现机制和自动配置</li></ul><p>本章主要学习<strong>隐式的bean发现机制和自动配置</strong>，通过<strong>音响系统</strong>的各个组件来说明<code>Spring</code>是如何隐式的bean发现机制和自动配置。首先创建一个<code>CD</code>接口，<code>Spring</code>会发现它并将其创建一个<code>bean</code>；然后会创建一个<code>CDPlayer</code>类，让<code>Spring</code>发现它并将<code>CD bean</code>注入进来。</p><a id="more"></a><p><code>Spring</code>从两个角度来实现自动化装备：</p><ul><li>组件扫描(component scanning)：<code>Spring</code>会自动发现<code>ApplicationContext</code>中所创建的<code>bean</code></li><li>自动装配(autowiring)：<code>Spring</code>自动满足<code>bean</code>之间的依赖</li></ul><h1 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean"></a>创建<code>bean</code></h1><h2 id="创建CD接口和PianoCD类"><a href="#创建CD接口和PianoCD类" class="headerlink" title="创建CD接口和PianoCD类"></a>创建<code>CD</code>接口和<code>PianoCD</code>类</h2><p>首先创建<code>CD</code>接口，具体代码如下所示：<br><code>CD.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jacob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CD</code>中不需要具体实现，它只需要定义所能进行的操作，其具体实现类根据具体需求创建。如现在有个钢琴CD的具体实现<code>PianoCD</code>，其代码如下所示：<br><code>PianoCD.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jacob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PianoCD</span> <span class="keyword">implements</span> <span class="title">CD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"this is PianoCD!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建<code>PianoCD</code>类是，使用了<code>@Component</code>注解，该注解表明<code>PianoCD</code>类会作为<strong>组件类</strong>，并告知<code>Spring</code>为这个类创建<code>bean</code>，因此不需要显示配置<code>bean</code>。</p><h2 id="开启组件扫描"><a href="#开启组件扫描" class="headerlink" title="开启组件扫描"></a>开启组件扫描</h2><p>组件扫描(ComponentScan)默认是关闭的，需要显示的配置<code>Spring</code>，命令它去寻找带有了<code>@Component</code>注解的类，并为其创建<code>bean</code>。具体代码如下所示：<br><code>CDPlayerConfig.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jacob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CDPlayerConfig</code>类通过<code>java</code>代码定义了<code>Spring</code>的装配规则。该类中没有任何显示地声明任何<code>bean</code>，通过使用<code>@ComponentScan</code>注解来开启组件扫描。<code>@ComponentScan</code>注解默认会扫描与配置类相同的包。因为<code>CDPlayerConfig</code>在<code>com.jacob</code>包中，因此<code>Spring</code>将扫描该包以及该包下所有子包，查找带有<code>@Component</code>的类，然后为该类在<code>Spring</code>中自动创建一个<code>bean</code>。</p><h2 id="测试组件扫描功能"><a href="#测试组件扫描功能" class="headerlink" title="测试组件扫描功能"></a>测试组件扫描功能</h2><p>创建<code>JUnit</code>测试，它会创建<code>Spring</code>的<code>Context</code>，并判断<code>CD</code>是不是真的创建出来。具体代码如下所示：<br><code>CDPlayerTest.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jacob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertNotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = CDPlayerConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CD cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotBeNull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CDPlayerTest</code>使用<code>Spring</code>的<code>SpringJUnit4ClassRunner</code>，以便在测试开始的时候自动创建<code>Spring</code>的<code>ApplicationContext</code>。<code>@ContextConfiguration</code>会告诉<code>CDPlayerTest</code>在需要在<code>CDPlayerConfig</code>中加载配置。因为<code>CDPlayerConfig</code>中包含<code>@ComponentScan</code>，因此最终的<code>ApplicationContext</code>包含<code>CD bean</code>。</p><p>为了证明<code>ApplicationContext</code>包含<code>CD bean</code>， 在测试代码中使用<code>CD</code>类型的属性，且在这个属性中添加<code>@Autowired</code>注解，以便将<code>CD</code>注入到测试代码中。最后通过断言判断<code>cd</code>属性不为<code>null</code>。</p><blockquote><p>注意：在创建测试代码过程中，出现如图问题：<img src="/2019/05/04/spring实战1-自动化装配bean/CDPlayerTest错误.png" title="CDPlayerTest错误示意图"><br>图中的主要原因是<code>junit</code>的版本过低，在<code>pom.xml</code>文件中<code>junit</code>依赖的改为4.12及其以上即可。</p></blockquote><img src="/2019/05/04/spring实战1-自动化装配bean/CDPlayerTest测试通过.png" title="CDPlayerTest测试通过示意图"><h1 id="为组件扫描的bean命名"><a href="#为组件扫描的bean命名" class="headerlink" title="为组件扫描的bean命名"></a>为组件扫描的bean命名</h1><p><code>Spring</code>中的<code>ApplicationContext</code>所有的<code>bean</code>都会有一个<code>ID</code>。如<code>PianoCD</code>中我们没有设置其对应<code>bean</code>的<code>ID</code>，这时<code>Spring</code>会默认指定其<code>ID</code>为<code>pianoCD</code>。有些情况，我们需要自定义<code>bean</code>的<code>ID</code>，可以通过<code>@Component</code>注解来实现，具体如下代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"myLoveCD"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PianoCD</span> <span class="keyword">implements</span> <span class="title">CD</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="设置组件扫描-ComponentScan-的基础包"><a href="#设置组件扫描-ComponentScan-的基础包" class="headerlink" title="设置组件扫描(@ComponentScan)的基础包"></a>设置组件扫描(<code>@ComponentScan</code>)的基础包</h1><p><code>@ComponentScan</code>默认情况下扫描配置类所在的包（基础包，base package）中的组件，有时需要扫描不同的包，有时需要扫描多个包，该如何处理？<br>为了将配置代码与应用代码分离开，一般配置类单独放<code>config</code>包中，这时需要我们明确设置基础包，可以通过指定<code>@ComponentScan</code>中的<code>value</code>属性值来设置需要扫描的基础包。具体代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value=<span class="string">"com.jacob"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果需要扫描多个包，具体代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages=&#123;<span class="string">"package1"</span>, <span class="string">"package2"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="通过为bean添加注解实现自动装配"><a href="#通过为bean添加注解实现自动装配" class="headerlink" title="通过为bean添加注解实现自动装配"></a>通过为<code>bean</code>添加注解实现自动装配</h1><p>自动装配是让<code>Spring</code>自动满足<code>bean</code>依赖的一种方法，在满足依赖的过程中，会在<code>ApplicationContext</code>中寻找匹配某个<code>bean</code>需要的其他<code>bean</code>。一般是通过<code>@Autowired</code>注解来实现自动装配。如下代码所示：<br><code>CDPlayer.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jacob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CD cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CD cd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cd = cd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cd.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>CDPlayer</code>中在构造器上添加<code>@Autowired</code>注解，表明当<code>Spring</code>创建<code>CDPlayer bean</code>时，会通过这个构造器来进行实例化并且会传入<code>CD</code>类型的<code>bean</code>。<br><code>@Autowired</code>注解类可以在任何方法上使用。例如<code>CDPlayer</code>有一个<code>setCD()</code>方法，那么可以采用如下的注解形式进行自动装配：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@`<span class="meta">@Autowired</span>`</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCD</span><span class="params">(CD cd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cd = cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在自动装配时，如果没有匹配的<code>bean</code>，那么在创建<code>ApplicationContext</code>时会抛异常。可以通过<code>@Autowired(required=false)</code>来避免抛异常，这时<code>Spring</code>将这个<code>bean</code>置为未装配状态。在代码中需要进行<code>null</code>检查来判断<code>bean</code>是否装配成功。如果没有<code>null</code>检查，未装配的<code>bean</code>会抛出<code>NullPointerException</code>。</p><h1 id="验证自动装配"><a href="#验证自动装配" class="headerlink" title="验证自动装配"></a>验证自动装配</h1><p>我们在<code>CDPlayer</code>中在构造器上添加<code>@Autowired</code>注解，<code>Spring</code>会将一个可分配的<code>CD</code>类型的<code>bean</code>自动注入进来（该实验项目中为<code>PianoCD bean</code>）。接下来测试是否注入成功，修改<code>CDPlayerTest</code>如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jacob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.junit.contrib.java.lang.system.StandardOutputStreamLog;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertNotNull;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = CDPlayerConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> StandardOutputStreamLog log = <span class="keyword">new</span> StandardOutputStreamLog();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer player;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CD cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotBeNull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        player.play();</span><br><span class="line">        assertEquals(</span><br><span class="line">                <span class="string">"this is PianoCD!!!"</span>,</span><br><span class="line">                log.getLog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/04/spring实战1-自动化装配bean/验证自动装配测试结果.png" title="验证自动装配测试结果示意图"><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://item.jd.com/11899370.html" target="_blank" rel="noopener">Spring实战（第四版）</a></p><blockquote><p>声明：本文为学习《Spring实战（第四版）》所作学习笔记，一切版权归该书所有。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring提供三种主要的装备机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在XML中进行显示配置&lt;/li&gt;
&lt;li&gt;在Java中进行显示配置&lt;/li&gt;
&lt;li&gt;隐式的bean发现机制和自动配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本章主要学习&lt;strong&gt;隐式的bean发现机制和自动配置&lt;/strong&gt;，通过&lt;strong&gt;音响系统&lt;/strong&gt;的各个组件来说明&lt;code&gt;Spring&lt;/code&gt;是如何隐式的bean发现机制和自动配置。首先创建一个&lt;code&gt;CD&lt;/code&gt;接口，&lt;code&gt;Spring&lt;/code&gt;会发现它并将其创建一个&lt;code&gt;bean&lt;/code&gt;；然后会创建一个&lt;code&gt;CDPlayer&lt;/code&gt;类，让&lt;code&gt;Spring&lt;/code&gt;发现它并将&lt;code&gt;CD bean&lt;/code&gt;注入进来。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://JacobLei.github.io/categories/Spring/"/>
    
      <category term="Spring in action" scheme="http://JacobLei.github.io/categories/Spring/Spring-in-action/"/>
    
    
      <category term="Spring" scheme="http://JacobLei.github.io/tags/Spring/"/>
    
      <category term="Spring in action" scheme="http://JacobLei.github.io/tags/Spring-in-action/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1 两数之和</title>
    <link href="http://JacobLei.github.io/2019/05/04/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://JacobLei.github.io/2019/05/04/LeetCode-1-两数之和/</id>
    <published>2019-05-04T04:09:36.000Z</published>
    <updated>2019-05-11T08:53:30.832Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：1. 两数之和</li><li>难度：简单</li><li>分类：数组，哈希表</li><li>解决方案：暴力求解、<code>HashMap</code></li></ul><a id="more"></a><p>从今天开始开启《LeetCode解题报告》系列文章，希望能够坚持下来。今天我们来学习第1题两数之和，既然放在首位，可见该题的重要性。这个在笔试中出现的概率非常大，希望大家在面试前能够手写出来。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个整数数组<code>nums</code>和一个目标值<code>target</code>，请你在该数组中找出和为目标值的那 两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><strong>两数之和</strong>可称为经典的面试题，曾经百度实习面试时手写过该代码，也在秋招电话面试时面到该题。这个题最基本的思路是使用两次<code>for</code>循环，但时间复杂度为<code>O(n^2)</code>，<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = target - nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == tmp &amp;&amp; j != i)&#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i;</span><br><span class="line">                    res[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/04/LeetCode-1-两数之和/两次for循环提交结果.jpg" title="两次for循环提交结果"><p>虽然在LeetCode或面试中能够解答出来，但是该方法的时间复杂度过高，需要进一步优化。我们发现题目中的数组是无序的（虽然示例中的数组有序的，但这只是一个特列，测试用例中并不是所有的数组都是有序的），当数组如果是<strong>有序</strong>的，然后再去查找是否能更加方便？一个很重要的问题，<strong>该题中需要返回的是数组下标，因此不能破坏数组中的位置关系</strong>。如果将数组进行排序，则会破坏数组的位置关系，不能满足题目要求。如何<strong>将数组的值与数组的位置关系进行绑定</strong>，是这个题目的解题关键。这样很容易想到<code>k-v</code>结构，在<code>java</code>中可以通过<code>HashMap</code>来实现。具体思路如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 遍历数组建立HashMap映射，其中HashMap中的key为数组的值，value为数组的位置，即&lt;nums[i], i&gt;;</span><br><span class="line">2. 查找是否存在两个数之和等于target：</span><br><span class="line">2.1 遍历数组，得到第一个数字nums[i]，记为num1，该数字在数组中的位置为i</span><br><span class="line">2.2 计算target-nums[i]，计算结果为另一个需要的数字num2，若该数字存在，该数字在数组中的位置为hasmMap.get(num2)</span><br><span class="line">2.3 在HashMap中判断num2是否存在：</span><br><span class="line">若不存在，则跳转至2.1</span><br><span class="line">若存在，则判断num1与num2对应的value是否相等：</span><br><span class="line">若相等，则跳转至2.1</span><br><span class="line">若不相等，则找到这两个数num1+num2==target，返回对应的数组位置</span><br></pre></td></tr></table></figure></p><p><code>java</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 建立HashMap映射</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 查找是否存在两个数之和等于target</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tmp) &amp;&amp; map.get(tmp) != i)&#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                res[<span class="number">1</span>] = map.get(tmp);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/04/LeetCode-1-两数之和/HashMap方法提交结果.jpg" title="HashMap方法提交结果"><p>整个算法流程是时间复杂度为<code>O(n)</code>，由于使用了<code>HashMap</code>申请了内存空间，其空间复杂度为<code>O(n)</code>。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：1. 两数之和&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：数组，哈希表&lt;/li&gt;
&lt;li&gt;解决方案：暴力求解、&lt;code&gt;HashMap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
