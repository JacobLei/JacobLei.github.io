<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jacob2359</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://JacobLei.github.io/"/>
  <updated>2019-06-11T06:09:11.877Z</updated>
  <id>http://JacobLei.github.io/</id>
  
  <author>
    <name>jacob2359</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-79 单词搜索</title>
    <link href="http://JacobLei.github.io/2019/10/11/LeetCode-79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <id>http://JacobLei.github.io/2019/10/11/LeetCode-79-单词搜索/</id>
    <published>2019-10-11T04:44:17.000Z</published>
    <updated>2019-06-11T06:09:11.877Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：79. 单词搜索</li><li>难度：中等</li><li>分类：数组</li><li>解决方案：DFS、回溯算法<a id="more"></a></li></ul><p>今天我们学习第79题<strong>单词搜索</strong>，这个题目是一个典型的DFS，经常出现笔试中，最好要熟练掌握。我们先看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = &quot;ABCCED&quot;, 返回 true.</span><br><span class="line">给定 word = &quot;SEE&quot;, 返回 true.</span><br><span class="line">给定 word = &quot;ABCB&quot;, 返回 false.</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题目是让我们在一个二维网格中通过给定的规则进行搜索word是否存在，是一个典型的深度优先遍历（DFS）的应用。</p><p>对于二维网格中的每一个字符，如果该字符是word对应查找的字符，我们接下来继续判断网格中的该字符的上下左右字符是否为word对应的下一个字符，直到匹配完成。对于示例的详细分析过程如下：<br><img src="/2019/10/11/LeetCode-79-单词搜索/示例详细分析过程.png" title="示例详细分析过程"></p><p>对于上述分析不难，难点在于如何实现对搜索过程中的判断，这里涉及到DFS和回溯算法，对这个知识点不太清楚的小伙伴可以扫描文章下方的二维码，关注『 算法半岛』回复『 数据结构目录』，即可获得相关学习资料。</p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 申请并初始化visited数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从二维网格的左上角开始于word的首字符进行判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, word, <span class="number">0</span>, i, j, visited))  <span class="comment">// 判断函数</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> idx, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当单词判断结束后，直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(idx == word.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 边界条件处理</span></span><br><span class="line">        <span class="comment">// 或字符已经访问处理</span></span><br><span class="line">        <span class="comment">// 或word中的字符与二维网格中的字符不相等 直接返回false</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols </span><br><span class="line">           || visited[i][j]</span><br><span class="line">           || word.toCharArray()[idx] != board[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// word中的字符与二维网格中的字符相等即修改visited对应位置为true</span></span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断word下一个字符与二维网格中已判断的字符的上下左右四个相邻字符是否有一个相等的字符</span></span><br><span class="line">        <span class="comment">// 如果相等，则继续进入深度遍历进行判断</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board, word, idx+<span class="number">1</span>, i-<span class="number">1</span>, j, visited)</span><br><span class="line">                    || dfs(board, word, idx+<span class="number">1</span>, i+<span class="number">1</span>, j, visited)</span><br><span class="line">                    || dfs(board, word, idx+<span class="number">1</span>, i, j-<span class="number">1</span>, visited)</span><br><span class="line">                    || dfs(board, word, idx+<span class="number">1</span>, i, j+<span class="number">1</span>, visited);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果不相等，回溯</span></span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/10/11/LeetCode-79-单词搜索/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A79_WordSearch.java" target="_blank" rel="noopener">LeetCode-79 单词搜索</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/word-search//" target="_blank" rel="noopener">单词搜索</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：79. 单词搜索&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：DFS、回溯算法
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="回溯算法" scheme="http://JacobLei.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="http://JacobLei.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-31 下一个排列</title>
    <link href="http://JacobLei.github.io/2019/06/10/LeetCode-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <id>http://JacobLei.github.io/2019/06/10/LeetCode-31-下一个排列/</id>
    <published>2019-06-10T07:57:44.000Z</published>
    <updated>2019-06-11T04:54:43.748Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：31. 下一个排列</li><li>难度：中等</li><li>分类：数组</li><li>解决方案：<a id="more"></a></li></ul><p>今天我们学习第31题<strong>实现strStr()</strong>，这个题目是一个典型的字符串匹配题目。我们先看看这道题的题目描述。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：31. 下一个排列&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-28 实现strStr()</title>
    <link href="http://JacobLei.github.io/2019/06/09/LeetCode-28-%E5%AE%9E%E7%8E%B0strStr/"/>
    <id>http://JacobLei.github.io/2019/06/09/LeetCode-28-实现strStr/</id>
    <published>2019-06-09T04:57:12.000Z</published>
    <updated>2019-06-09T07:24:32.197Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：28. 实现strStr()</li><li>难度：简单</li><li>分类：字符串</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第28题<strong>实现strStr()</strong>，这个题目是一个典型的字符串匹配题目。我们先看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">题目描述</a></h1><p>实现<code>strStr()</code>函数。</p><p>给定一个<code>haystack</code>字符串和一个<code>needle</code>字符串，在<code>haystack</code>字符串中找出<code>needle</code> 字符串出现的第一个位置 (从0开始)。如果不存在，则返回<code>-1</code>。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure></p><p>说明:</p><p><strong>当<code>needle</code>是空字符串时，我们应当返回什么值呢</strong>？这是一个在面试中很好的问题。</p><p>对于本题而言，当<code>needle</code>是空字符串时我们应当返回 0 。这与C语言的<code>strstr()</code>以及 Java的<code>indexOf()</code>定义相符。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我们可以称<code>haystack</code>字符串为母字符串，<code>needle</code>字符串为子字符串，这个题目是让我们在母字符串中寻找子字符串，如果存在，返回子字符串在母字符串中是第一个字符出现的位置，如果不存在，则返回<code>-1</code>。在题目的<strong>说明</strong>部分指出，子字符串为空字符串时，返回<code>0</code>。对于这样的题目，我们首先想到是暴力求解，一个一个字符去查找。对示例1的具体分析过程如下图所示：<br><img src="/2019/06/09/LeetCode-28-实现strStr/示例1详细分析过程.png" title="示例1详细分析过程"></p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lenHaystack = haystack.length();    <span class="comment">// 母字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> lenNeedle = needle.length();        <span class="comment">// 子字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> leftHaystack = <span class="number">0</span>;       <span class="comment">// 母字符串的左指针，用来标识子字符串在母字符串中的第一个字符</span></span><br><span class="line">        <span class="keyword">int</span> rightHaystack = <span class="number">0</span>;      <span class="comment">// 母字符串的右指针，用来标识子字符串在母字符串中的当前字符</span></span><br><span class="line">        <span class="keyword">int</span> curNeedle = <span class="number">0</span>;          <span class="comment">// 子字符串的当前字符指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当子字符串为空字符串时，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(lenNeedle == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(leftHaystack &lt;= lenHaystack - lenNeedle) &#123;</span><br><span class="line">            <span class="comment">// 如果母字符串中rightHaystack指向的字符与子字符串curNeedle指向的字符相等，移动母字符串中的rightHaystack指针和子字符串中的rightHaystack指针</span></span><br><span class="line">            <span class="keyword">while</span> (haystack.charAt(rightHaystack) == needle.charAt(curNeedle)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curNeedle == lenNeedle - <span class="number">1</span>) &#123;   <span class="comment">// 如果子字符串遍历结束，则直接返回leftHaystack即可</span></span><br><span class="line">                    <span class="keyword">return</span> leftHaystack;</span><br><span class="line">                &#125;</span><br><span class="line">                rightHaystack++;</span><br><span class="line">                curNeedle++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果母字符串中rightHaystack指向的字符与子字符串curNeedle指向的字符不相等</span></span><br><span class="line">            <span class="comment">// 移动母字符串中的leftHaystack指针和rightHaystack指针</span></span><br><span class="line">            <span class="comment">// 并将子字符串中的curNeedle指针初始化</span></span><br><span class="line">            leftHaystack++;</span><br><span class="line">            rightHaystack = leftHaystack;</span><br><span class="line">            curNeedle = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/09/LeetCode-28-实现strStr/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A28_ImplementstrStr.java" target="_blank" rel="noopener">LeetCode-28 实现strStr()</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">实现strStr()</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：28. 实现strStr()&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="字符串" scheme="http://JacobLei.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-27 移除元素</title>
    <link href="http://JacobLei.github.io/2019/06/08/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>http://JacobLei.github.io/2019/06/08/LeetCode-27-移除元素/</id>
    <published>2019-06-08T14:11:04.000Z</published>
    <updated>2019-06-09T02:36:16.704Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：27. 移除元素</li><li>难度：简单</li><li>分类：数组</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第27题<strong>移除元素</strong>，这个题目和昨天的<a href="https://www.jacob2359.com/2019/06/07/LeetCode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" target="_blank" rel="noopener">LeetCode-26 删除排序数组中的重复项</a>原理一样。我们先看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个数组<code>nums</code>和一个值 <code>val</code>，你需要原地移除所有数值等于<code>val</code>的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组并在使用<code>O(1)</code> 额外空间</strong>的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我相信小伙伴们看完这个后都会有思路，这个题目和<a href="https://www.jacob2359.com/2019/06/07/LeetCode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/" target="_blank" rel="noopener">LeetCode-26 删除排序数组中的重复项</a>原理一样，也是使用双指针方法去解决，需要说明一下我们这里说的<strong>指针</strong>的含义，它不是狭义上C语言中的指针，而是一种思想，它是<strong>利用一个值去寻找另一个值</strong>的方法，如下图所示：<br><img src="/2019/06/08/LeetCode-27-移除元素/指针理解.png" title="指针理解"></p><p>因此指针一个值的地址(C语言中的指针)，也可以是数组中的下标(index)。在这个题目中双指针就是两个数组的下标，通过维护数组的下标来改变原来的数组。对示例1的详细分析过程如下所示：<br><img src="/2019/06/08/LeetCode-27-移除元素/示例1详细分析过程.png" title="示例1详细分析过程"></p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化slow指针</span></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始fast指针，并遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fast=<span class="number">0</span>; fast&lt;nums.length; fast++)&#123;</span><br><span class="line">            <span class="comment">// 当前数不为val时，才把该保存在数组中</span></span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val )&#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/08/LeetCode-27-移除元素/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A27_RemoveElement.java" target="_blank" rel="noopener">LeetCode-27 移除元素</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">删除排序数组中的重复项</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：27. 移除元素&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-26 删除排序数组中的重复项</title>
    <link href="http://JacobLei.github.io/2019/06/07/LeetCode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://JacobLei.github.io/2019/06/07/LeetCode-26-删除排序数组中的重复项/</id>
    <published>2019-06-07T12:16:20.000Z</published>
    <updated>2019-06-08T14:32:51.500Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：26. 删除排序数组中的重复项</li><li>难度：简单</li><li>分类：数组</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第26题<strong>删除排序数组中的重复项</strong>，这是一道简单题。像这样数组的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p><strong>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成</strong>。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题目的是删除已经排好序的数组的重复项，题目中的示例已经进行了详细说明。对这个题目的题意理解不难，就是返回数组中不重复项的个数，并在原数组上去掉重复项。细心的小伙伴可能观察到，在测试用例中输入<code>[1,1,2]</code>，返回的是<code>[1,2]</code>，而不是数组中不重复项的个数。这一点在题目中的<strong>说明部分</strong>已经解释了，简单点理解就是<strong>在测试的时候返回的是修改后的没有重复项的数组</strong>。</p><p>对于示例1的详细分析过程如下所示：<br><img src="/2019/06/07/LeetCode-26-删除排序数组中的重复项/示例1详细分析过程.png" title="示例1详细分析过程"></p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">1</span>;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(slow &lt; fast &amp;&amp; fast &lt; nums.length)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当出现重复项的时候，移动fast指针</span></span><br><span class="line">            <span class="keyword">while</span>(nums[slow] == nums[fast])&#123;</span><br><span class="line">                fast++;</span><br><span class="line">                <span class="keyword">if</span>(fast == nums.length)</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 当不是重复项是，原地删除重复项（即将后面的数移动到前面来）</span></span><br><span class="line">            <span class="comment">// ++slow;</span></span><br><span class="line">            <span class="comment">// nums[slow] = nums[fast];</span></span><br><span class="line">            <span class="comment">// fast++;</span></span><br><span class="line">            <span class="comment">// 可以写出下面的表达形式，这里注意++i与i++的区别</span></span><br><span class="line">            nums[++slow] = nums[fast++];</span><br><span class="line">            </span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/07/LeetCode-26-删除排序数组中的重复项/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A26_RemoveDuplicatesfromSortedArray.java" target="_blank" rel="noopener">LeetCode-26 删除排序数组中的重复项</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除排序数组中的重复项</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：26. 删除排序数组中的重复项&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-24 两两交换链表中的节点</title>
    <link href="http://JacobLei.github.io/2019/06/06/LeetCode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://JacobLei.github.io/2019/06/06/LeetCode-24-两两交换链表中的节点/</id>
    <published>2019-06-06T07:20:16.000Z</published>
    <updated>2019-06-06T08:50:27.890Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：24. 两两交换链表中的节点</li><li>难度：中等</li><li>分类：链表</li><li>解决方案：节点的交换<a id="more"></a></li></ul><p>今天我们学习第24题<strong>两两交换链表中的节点</strong>，这是一道中等题。像这样链表的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换</strong>。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题为基础的链表节点操作题，是将链表的节点两两进行交换，而且必须是交换节点不能仅仅只改变链表的值。像这样的题，需要画一个图，来弄清楚指针的位置。对示例的详细分析过程如下图所示：<br><img src="/2019/06/06/LeetCode-24-两两交换链表中的节点/示例详细分析过程.png" title="示例详细分析过程"></p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 申请res结点和pre</span></span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), pre = res;</span><br><span class="line">        res.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 具体分析详见示意图</span></span><br><span class="line">            ListNode node = pre.next.next;</span><br><span class="line">            pre.next.next = node.next;</span><br><span class="line">            node.next = pre.next;</span><br><span class="line">            pre.next = node;</span><br><span class="line">            pre = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/06/LeetCode-24-两两交换链表中的节点/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A24_SwapNodesinPairs.java" target="_blank" rel="noopener">LeetCode-24 两两交换链表中的节点</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表中的节点</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：24. 两两交换链表中的节点&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：链表&lt;/li&gt;
&lt;li&gt;解决方案：节点的交换
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="链表" scheme="http://JacobLei.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-分治算法</title>
    <link href="http://JacobLei.github.io/2019/06/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://JacobLei.github.io/2019/06/05/数据结构与算法-分治算法/</id>
    <published>2019-06-05T08:42:38.000Z</published>
    <updated>2019-06-06T07:18:39.490Z</updated>
    
    <content type="html"><![CDATA[<p>本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。</p><a id="more"></a><h1 id="如何理解分治算法？"><a href="#如何理解分治算法？" class="headerlink" title="如何理解分治算法？"></a>如何理解分治算法？</h1><p><strong>分治算法</strong>主要理解<strong>分而治之</strong>四个字，即<strong>将大问题划分成n个规模较小，并且结构与原问题相似的子问题，然后递归地解决这些子问题，最后结合子问题的结果，得到原问题的解</strong>。具体的步骤为：</p><ul><li>“分”——将一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题</li><li>“治”——将最后子问题可以简单的直接求解</li><li>“合”——将所有子问题的解合并起来就是原问题的解</li></ul><h2 id="分治算法能解决的问题满足的几个条件："><a href="#分治算法能解决的问题满足的几个条件：" class="headerlink" title="分治算法能解决的问题满足的几个条件："></a>分治算法能解决的问题满足的几个条件：</h2><ul><li><p>原问题与分解成的小问题具有相同的模式</p></li><li><p>原问题分解成的子问题可以独立求解，子问题之间没有相关性（这里注意与<a href="https://www.jacob2359.com/2019/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="noopener">动态规划</a>的区别）</p></li><li><p>具有分解终止条件，也就是说，当问题足够小时，可以直接求解</p></li><li><p>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果</p></li></ul><h2 id="分治算法与递归"><a href="#分治算法与递归" class="headerlink" title="分治算法与递归"></a>分治算法与递归</h2><p>分治算法与递归区别<strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及以下三个操作：</p><ul><li>分解：将原问题分解成一系列子问题</li><li>解决：递归地求解各个子问题，若子问题足够小，则直接求解</li><li>合并：将子问题的结果合并成原问题</li></ul><h1 id="分治算法应用分析"><a href="#分治算法应用分析" class="headerlink" title="分治算法应用分析"></a>分治算法应用分析</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是利用<strong>归并</strong>的思想实现的排序方法，主要采用的是<strong>分治</strong>策略进行排序。其详细过程如图所示：</p><img src="/2019/06/05/数据结构与算法-分治算法/归并排序.png" title="归并排序"><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="分治算法" scheme="http://JacobLei.github.io/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-22 括号生成</title>
    <link href="http://JacobLei.github.io/2019/06/04/LeetCode-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <id>http://JacobLei.github.io/2019/06/04/LeetCode-22-括号生成/</id>
    <published>2019-06-04T07:15:14.000Z</published>
    <updated>2019-06-04T08:15:51.014Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：22. 括号生成</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：链表的遍历<a id="more"></a></li></ul><p>今天我们学习第22题<strong>括号生成</strong>，这是一道中等题。像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">题目描述</a></h1><p>给出<code>n</code>代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出<code>n = 3</code>，生成结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题是<strong>递归</strong>方面的题，对于递归不太熟悉的小伙伴可以扫描文章下方的二维码，关注『 算法半岛』回复『 数据结构目录』，即可获得相关学习资料。</p><p>对于递归的问题，我们需要明白以下三点：</p><ul><li><strong>一个问题的解可以分解为几个子问题的解</strong>：对于这个括号生成的题，当<code>n=3</code>时问题的解可以分成<code>n=2</code>时问题的解；</li><li><strong>子问题除了数据规模不同，求解思路完全一样</strong>：对于这个括号生成的题，当<code>n=3</code>时问题的解的解思路和<code>n=2</code>时问题的解的解思路完全一样，只是问题规模减小了；</li><li><strong>必须存在递归终止条件</strong>：对于这个括号生成的题，我们需要使用两个变量<code>left</code>和<code>right</code>来记录可使用的左括号数和右括号数，如当<code>n=3</code>时，初始化<code>left=3</code>和<code>right=3</code>，当<code>left&gt;right</code>时说明可以使用的左括号数大于可以使用的右括号数，即已经使用的右括号数比左括号数多，则会出现无效的括号对数，因此<code>left&gt;right</code>可作为本题的递归终止条件。还有当<code>left&lt;0</code>或则<code>right&lt;0</code>也是递归终止条件。</li></ul><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        helper(n, n, <span class="string">""</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归辅助函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String out, List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span> || left &gt; right)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 当left和right都为0时，保存有效的括号组</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(out);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减小问题的规模</span></span><br><span class="line">        helper(left-<span class="number">1</span>, right, out + <span class="string">"("</span>, res);</span><br><span class="line">        helper(left, right-<span class="number">1</span>, out + <span class="string">")"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/04/LeetCode-22-括号生成/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A22_GenerateParentheses.java" target="_blank" rel="noopener">LeetCode-22 括号生成</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：22. 括号生成&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：链表的遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="字符串" scheme="http://JacobLei.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="递归" scheme="http://JacobLei.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-21 合并两个有序链表</title>
    <link href="http://JacobLei.github.io/2019/06/03/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://JacobLei.github.io/2019/06/03/LeetCode-21-合并两个有序链表/</id>
    <published>2019-06-03T12:56:37.000Z</published>
    <updated>2019-06-04T08:15:23.126Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：21. 合并两个有序链表</li><li>难度：简单</li><li>分类：链表</li><li>解决方案：链表的遍历<a id="more"></a></li></ul><p>今天我们学习第21题<strong>合并两个有序链表</strong>，这是一道简单题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">题目描述</a></h1><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这是一个链表题，这个比较简单，用下面的示意图表示示例的分析过程：<br><img src="/2019/06/03/LeetCode-21-合并两个有序链表/示例详细分析过程.png" title="示例详细分析过程"></p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建head节点和cur指针</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历两个链表，将较小值的节点连接cur节点后</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断哪个链表不为空，如不为空，则直接连接到cur节点后</span></span><br><span class="line">        cur.next = (l1 != <span class="keyword">null</span>) ? l1 : l2;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回head的下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/03/LeetCode-21-合并两个有序链表/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A21_MergeTwoSortedLists.java" target="_blank" rel="noopener">LeetCode-21 合并两个有序链表</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：21. 合并两个有序链表&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：链表&lt;/li&gt;
&lt;li&gt;解决方案：链表的遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="链表" scheme="http://JacobLei.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-20 有效的括号</title>
    <link href="http://JacobLei.github.io/2019/06/02/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://JacobLei.github.io/2019/06/02/LeetCode-20-有效的括号/</id>
    <published>2019-06-02T10:40:15.000Z</published>
    <updated>2019-06-02T13:03:08.892Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：20. 有效的括号</li><li>难度：简单</li><li>分类：栈</li><li>解决方案：入栈出栈</li></ul><a id="more"></a><p>今天我们学习第20题<strong>有效的括号</strong>，这是一道关于栈的简单题，对熟悉栈的基本使用很有帮助。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个只包括 <code>(</code>，<code>)</code>，<code>{</code>，<code>}</code>，<code>[</code>，<code>]</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><p>注意空字符串可被认为是有效字符串。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题是目前为止遇到的第一个<strong>栈</strong>相关题目，对于栈不太熟悉的小伙伴可以扫描文章下方的二维码，关注『 算法半岛』回复『 数据结构目录』，即可获得相关学习资料。</p><p>对于这个题，我们借助一个栈，遍历字符串时，当遇到<code>(</code>、<code>{</code>或<code>[</code>时，将字符入栈；当遇到<code>)</code>、<code>}</code>或<code>]</code>时，判断栈顶是否为其对应的左括号，如果对应得上，弹出栈顶元素，如果栈顶为空或则对应不上，则返回<code>false</code>。对示例5的详细示意图如下所示：</p><img src="/2019/06/02/LeetCode-20-有效的括号/示例5详细示意图.png" title="示例5详细示意图"><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 申请栈</span></span><br><span class="line">         Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将字符串转化为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;chars.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 判断当前字符是否为 '(' 、'[' 或 '&#123;'</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">'('</span> || chars[i] == <span class="string">'['</span> || chars[i] == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果时，则入栈</span></span><br><span class="line">                stack.push(chars[i]);   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果不是，则为')'、']'或'&#125;''，判断栈中是否有对应的左括号</span></span><br><span class="line">                <span class="keyword">if</span> (stack.empty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">char</span> c = stack.pop();</span><br><span class="line">                    <span class="keyword">if</span> ((chars[i] == <span class="string">')'</span> &amp;&amp; c != <span class="string">'('</span>) || (chars[i] == <span class="string">']'</span> &amp;&amp; c != <span class="string">'['</span>) || (chars[i] == <span class="string">'&#125;'</span> &amp;&amp; c != <span class="string">'&#123;'</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只有当栈为空时，才为true</span></span><br><span class="line">        <span class="keyword">return</span> stack.empty() ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/06/02/LeetCode-20-有效的括号/提交结果.png" title="快慢提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A20_ValidParentheses.java" target="_blank" rel="noopener">LeetCode-20 有效的括号</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：20. 有效的括号&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：栈&lt;/li&gt;
&lt;li&gt;解决方案：入栈出栈&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="栈" scheme="http://JacobLei.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-19 删除链表中的倒数第N个节点</title>
    <link href="http://JacobLei.github.io/2019/05/31/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://JacobLei.github.io/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/</id>
    <published>2019-05-31T08:50:22.000Z</published>
    <updated>2019-06-09T02:54:29.455Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：19. 删除链表中的倒数第N个节点</li><li>难度：中等</li><li>分类：链表</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第19题<strong>删除链表中的倒数第N个节点</strong>，这是一道中等题。这个题属于面试中的高频题，一定要能手写出来。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个链表，删除链表的倒数第<code>n</code>个节点，并且返回链表的头结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure></p><p>说明：<strong>给定的<code>n</code>保证是有效的。</strong></p><p>进阶：<strong>你能尝试使用一趟扫描实现吗？</strong></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题是目前为止遇到的第一个链表题，对于链表不太熟悉的小伙伴可以扫描文章下方的二维码，关注『 算法半岛』回复『 数据结构目录』，即可获得相关学习资料。</p><p>这个题让我们删除链表中的倒数第<code>n</code>个节点，并且返回头节点。题目中说明部分提到<strong>给定的<code>n</code>保证是有效的</strong>，因此<code>n</code>的值小于等于链表的长度。最基本的方法，我们可以先遍历一次链表，统计链表的长度<code>len</code>，则删除的节点位置为<code>len-n+1</code>。然后找到删除节点位置的前一个节点(位置为<code>len-n</code>)对节点进行删除即可。注意<strong>如果删除的节点为第一个节点，则直接返回<code>head.next</code>即可</strong>。对示例分析如下图所示：</p><img src="/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/两次遍历方法.png"><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计链表节点的个数</span></span><br><span class="line">        <span class="keyword">while</span>(p.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算删除节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = len - n + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除节点如果为第一个节点，则直接返回head.next</span></span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重置p指针的位置</span></span><br><span class="line">        p = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找需要删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;pos-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除该节点</span></span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/两次遍历提交结果.png" title="两次遍历提交结果"><p>进阶部分提示我们<strong>尝试使用一趟扫描实现</strong>，对于这样的题，我们可以使用双指针(快慢指针)来实现。具体分析过程如下图所示：</p><img src="/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/快慢指针法.png"><p>值得注意的是，<strong>当删除的结点为第一个节点，则<code>fast==null</code>，因此在<code>fast</code>走<code>n</code>步后需要判断<code>fast</code>是否为<code>null</code>，如果为<code>null</code>则直接返回<code>fast.next</code></strong>。</p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 声明快慢指针</span></span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fast指针走n步</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;          </span><br><span class="line">            fast = fast.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断需要删除的节点是否为第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同时移动快慢指针</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/提交结果.png" title="快慢提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A19_RemoveNthNodeFromEndofList.java" target="_blank" rel="noopener">LeetCode-19 删除链表中的倒数第N个节点</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表中的倒数第N个节点</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：19. 删除链表中的倒数第N个节点&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：链表&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="链表" scheme="http://JacobLei.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-18 四数之和</title>
    <link href="http://JacobLei.github.io/2019/05/31/LeetCode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://JacobLei.github.io/2019/05/31/LeetCode-18-四数之和/</id>
    <published>2019-05-31T01:02:34.000Z</published>
    <updated>2019-05-31T02:36:30.255Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：18. 四数之和</li><li>难度：中等</li><li>分类：数组</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第18题<strong>四数之和</strong>，这是一道中等题。像这样数组的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个包含<code>n</code>个整数的数组<code>nums</code>和一个目标值<code>target</code>，判断<code>nums</code> 中是否存在四个元素<code>a</code>，<code>b</code>，<code>c</code>和<code>d</code> ，使得<code>a + b + c + d</code>的值与 <code>target</code>相等？找出所有满足条件且不重复的四元组。</p><p>注意：<strong>答案中不可以包含重复的四元组。</strong></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>在前面，我们做过<a href="https://www.jacob2359.com/2019/05/04/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/" target="_blank" rel="noopener">LeetCode-1 两数之和</a>和<a href="https://www.jacob2359.com/2019/05/28/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" target="_blank" rel="noopener">LeetCode-15 三数之和</a>，这个题目是求四数之和，其基本思路和三数之和差不多，只是在三数之和的基础上增加一个<code>for</code>循环。具体求解过程详见<a href="https://www.jacob2359.com/2019/05/28/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" target="_blank" rel="noopener">LeetCode-15 三数之和</a>。<code>java</code>代码如下所示；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> &amp;&amp; nums.length &lt; <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 固定第一个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">3</span>; ++i)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i+<span class="number">1</span>]&gt;<span class="number">0</span> &amp;&amp; nums[i] &gt;= target)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="comment">// 固定第二个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nums.length-<span class="number">2</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j != i + <span class="number">1</span>) &amp;&amp; nums[j] == nums[j-<span class="number">1</span>]) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用左右指针进行查找</span></span><br><span class="line">                <span class="keyword">int</span> left = j+<span class="number">1</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                        ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                        tmp.add(nums[i]);</span><br><span class="line">                        tmp.add(nums[j]);</span><br><span class="line">                        tmp.add(nums[left]);</span><br><span class="line">                        tmp.add(nums[right]);</span><br><span class="line">                        res.add(tmp);</span><br><span class="line">                        ++left;</span><br><span class="line">                        --right;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left-<span class="number">1</span>])</span><br><span class="line">                            ++left;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>])</span><br><span class="line">                            --right;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">                        --right;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        ++left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/31/LeetCode-18-四数之和/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A18_4Sum.java" target="_blank" rel="noopener">LeetCode-18 四数之和</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">四数之和</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：18. 四数之和&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-17 电话号码的字母组合</title>
    <link href="http://JacobLei.github.io/2019/05/30/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://JacobLei.github.io/2019/05/30/LeetCode-17-电话号码的字母组合/</id>
    <published>2019-05-30T05:24:15.000Z</published>
    <updated>2019-05-30T07:27:20.678Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：17. 电话号码的字母组合</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：字符串遍历<a id="more"></a></li></ul><p>今天我们学习第17题<strong>电话号码的字母组合</strong>，这是一道中等题。像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个仅包含数字<code>2-9</code>的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意<code>1</code>不对应任何字母。<br><img src="/2019/05/30/LeetCode-17-电话号码的字母组合/题目描述.jpg"></p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure></p><p>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题目的题意很好理解，让我们求电话号码的字母组合，从数字2到9中每个数字可以代表若干个字母，然后输一串数字，求出所有可能的组合。对于每个数字及其对应的字母可用数组建立对应关系，如下图所示。</p><img src="/2019/05/30/LeetCode-17-电话号码的字母组合/数字与其对应的字母.png" title="数字与其对应的字母"><p>我们可以通过这样的对应关系来构成组字符串，如对示例分析的示意图如下所示：</p><img src="/2019/05/30/LeetCode-17-电话号码的字母组合/示例详细分析过程.png" title="示例详细分析过程"><p>图中叶子节点中字符串即为字母组合。<br>将上述分析过程转化为<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数字与字母的对应关系</span></span><br><span class="line">        String[] map = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 图中树的根节点</span></span><br><span class="line">        res.add(<span class="string">""</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历输入的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : digits.toCharArray())&#123;</span><br><span class="line">            res = combine(map[c-<span class="string">'0'</span>], res);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据数字组合字母</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">combine</span><span class="params">(String digits, List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : digits.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">                res.add(s+c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/30/LeetCode-17-电话号码的字母组合/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A17_LetterCombinationsofaPhoneNumber.java" target="_blank" rel="noopener">LeetCode-17 电话号码的字母组合</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：17. 电话号码的字母组合&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：字符串遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="字符串" scheme="http://JacobLei.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-16 最接近的三数之和</title>
    <link href="http://JacobLei.github.io/2019/05/28/LeetCode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://JacobLei.github.io/2019/05/28/LeetCode-16-最接近的三数之和/</id>
    <published>2019-05-28T12:42:53.000Z</published>
    <updated>2019-05-28T14:24:15.982Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：16. 最接近的三数之和</li><li>难度：中等</li><li>分类：数组</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第16题<strong>最接近的三数之和</strong>，这是一道中等题。像这样数组的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个包括<code>n</code>个整数的数组<code>nums</code>和一个目标值<code>target</code>。找出<code>nums</code>中的三个整数，使得它们的和与<code>target</code>最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [-1，2，1，-4], 和 target = 1.</span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题和<a href="https://mp.weixin.qq.com/s?__biz=MzU5NTkyMDQyOQ==&amp;mid=2247483835&amp;idx=1&amp;sn=f990a98cc015eb9fbc8bf7ceeabe9982&amp;chksm=fe6bd2f9c91c5bef3aa1305ca933860b9f8afb77b78457432530a20d1ce431bea373fc64713b&amp;token=1428867397&amp;lang=zh_CN#rd" target="_blank" rel="noopener">LeetCode-15 三数之和</a>的解题思路差不多，在第15题中是为了寻找满足<code>a + b + c = 0</code>，而在这道题中首先给出了一个目标值<code>target</code>，然后寻找三个数<code>a + b + c</code>的和与<code>target</code>最接近，即<code>|a + b + c-target|</code>的值最小。对示例分析如下图所示：</p><img src="/2019/05/28/LeetCode-16-最接近的三数之和/示例详细分析过程.png" title="示例详细分析过程"><p>将上述分析过程转化为<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;    <span class="comment">// 表示数组中三个元素的和</span></span><br><span class="line">        <span class="keyword">int</span> dis = Integer.MAX_VALUE;   <span class="comment">// 表示数组中三个元素的和与target的距离，即|sum-target|</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">// 定义左指针和右指针</span></span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="comment">// 数组中三个元素的和与target的差，即sum-target </span></span><br><span class="line">                <span class="keyword">int</span> diff = nums[i] + nums[left] + nums[right] - target;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当sum-target == 0，则说明已经找到与target最近的数了（即target本身）</span></span><br><span class="line">                <span class="keyword">if</span> (diff == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 寻找最小距离</span></span><br><span class="line">                <span class="keyword">if</span>(Math.abs(diff) &lt; dis)&#123;</span><br><span class="line">                    dis = Math.abs(diff);</span><br><span class="line">                    sum = diff + target;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 移动左右指针</span></span><br><span class="line">                <span class="keyword">if</span>(diff &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/28/LeetCode-16-最接近的三数之和/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A16_3SumClosest.java" target="_blank" rel="noopener">LeetCode-16 最接近的三数之和</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：16. 最接近的三数之和&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>《批判性思维工具(Critical Thinking)》-读书笔记(三):批判性思维前四个阶段</title>
    <link href="http://JacobLei.github.io/2019/05/28/%E3%80%8A%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%89-%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%89%8D%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
    <id>http://JacobLei.github.io/2019/05/28/《批判性思维工具-Critical-Thinking-》-读书笔记-三-批判性思维前四个阶段/</id>
    <published>2019-05-28T07:25:35.000Z</published>
    <updated>2019-05-28T08:33:50.975Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>入职前公司指定几本必读书籍帮助我们从学生到职场的转身，积累基础的知识储备，扩宽视野。《批判性思维工具(Critical Thinking)》在必读书籍之首，以下是我的读书笔记。</p></blockquote><a id="more"></a><p>大多数人都没有完全表现出自己思维发展的潜能。我们有巨大的潜力，但是我们的潜力绝大多数仍处于休眠和未开发状态。只要我们还认为当下的思维水平是理所当然的，我们就不会进行提高思维的练习。下图为批判性思维发展的阶段。<br><img src="/2019/05/28/《批判性思维工具-Critical-Thinking-》-读书笔记-三-批判性思维前四个阶段/批判性思维发展的阶段.png" title="批判性思维发展的阶段"></p><p>多数人终生都停留在鲁莽的思考者阶段。想要成为完善的思考者需要每天坚持进行练习。</p><h1 id="阶段1-鲁莽的思考者"><a href="#阶段1-鲁莽的思考者" class="headerlink" title="阶段1　鲁莽的思考者"></a>阶段1　鲁莽的思考者</h1><blockquote><p>人生来就是鲁莽的思考者，其中大多数人终生都停留在鲁莽的思考者阶段，从不对自己的思维进行反思，根本没有意识到思考在我们生活中的重要作用。在鲁莽的思考者阶段，没有思考所需要的概念。</p></blockquote><p>鲁莽的思考者通常会：</p><ul><li>不会质疑自己的信念和决定</li><li>没有思维标准，也不知道这些标准应该是什么</li><li>缺乏良好的思维特质但是却意识不到</li><li>没有意识到自欺行为，有很多不实际的幻想，相信自己信念的合理性</li><li>满怀信心地谈论着这个世界，并且认为真实情况就如我们所看到的一样</li><li>对“好坏”进行判定，赞成某些活动，反对另一些活动</li><li>我们做出决定，对别人做出反馈，有着自己的生活方式，并且不会认真地反省自己的思维及其结果</li></ul><p>鲁莽的思考者通常在<strong>自我中心倾向</strong>主导着我们的思考。由于缺少思维技能，鲁莽的思考者注意不到：</p><ul><li>自己的自我中心和偏见</li><li>自己常常对他人进行归类</li><li>己不合理地忽略很多观点仅仅是因为我们不想改变自己的行为和观点</li></ul><h1 id="阶段2-质疑的思考者"><a href="#阶段2-质疑的思考者" class="headerlink" title="阶段2　质疑的思考者"></a>阶段2　质疑的思考者</h1><blockquote><p>我们不能解决自己没有意识到的问题，不能处理一个不存在的情况。如果不能认识到自己知识的局限性，我们就不能寻求自己没有的知识。如果不知道自己需要哪些技能，我们就不能培养他们。</p></blockquote><p>质疑的思考者开始：</p><ul><li>做出有问题的假设</li><li>使用错误的、不完全的或是误导性的信息</li><li>做出与所掌握证据无关的推论</li><li>没有发现我们思维中的重要意义</li><li>没有发现自己的错误</li><li>形成错误的概念</li><li>从具有偏见的观点中进行推理</li><li>自我中心和偏离理性地思考</li></ul><p>当认识到<strong>思考方式塑造着我们的生活，意识到思维中的问题可能导致生活中的问题</strong>时，我们就进入了质疑的思考者阶段。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;入职前公司指定几本必读书籍帮助我们从学生到职场的转身，积累基础的知识储备，扩宽视野。《批判性思维工具(Critical Thinking)》在必读书籍之首，以下是我的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://JacobLei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="批判性思维工具(Critical Thinking)》" scheme="http://JacobLei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B/"/>
    
    
      <category term="批判性思维工具(Critical Thinking)》" scheme="http://JacobLei.github.io/tags/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B/"/>
    
      <category term="读书笔记" scheme="http://JacobLei.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-15 三数之和</title>
    <link href="http://JacobLei.github.io/2019/05/28/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://JacobLei.github.io/2019/05/28/LeetCode-15-三数之和/</id>
    <published>2019-05-28T05:47:15.000Z</published>
    <updated>2019-05-28T13:02:56.991Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：15. 三数之和</li><li>难度：中等</li><li>分类：数组</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第15题<strong>三数之和</strong>，这是一道中等题。像这样数组的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个包含<code>n</code>个整数的数组<code>nums</code>，判断<code>nums</code>中是否存在三个元素<code>a</code>，<code>b</code>，<code>c</code> ，使得 <code>a + b + c = 0 ？</code>找出所有满足条件且不重复的三元组。</p><p>注意：答案中<strong>不可以包含重复的三元组</strong>。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如, 给定数组nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我们做过<a href="https://mp.weixin.qq.com/s?__biz=MzU5NTkyMDQyOQ==&amp;mid=2247483662&amp;idx=1&amp;sn=51920407843f16c16701416061ade8fb&amp;chksm=fe6bd24cc91c5b5a2e9f54985eefa36f4b9554b992e771237091b5574ad8c83d892d6a8b61e8&amp;token=911136023&amp;lang=zh_CN#rd" target="_blank" rel="noopener">LeetCode-1 两数之和</a>，这个题目与它有联系，但也有蛮大的差异。像这样求和的问题我们首先想到的是暴力求解方法，这个题目用暴力求解的时间复杂度为<code>O(n^3)</code>。我们想一想能不能将时间按复杂度降到<code>O(n^2)</code>？</p><p>先将数组进行排序(排序函数的时间复杂度为<code>O(nlgn)</code>)，然后我们就可以对这个有序数组用双指针的方法从左右两边向中间扫描了：</p><ul><li>对于有序数组的两数之和，我们就是找到左右指针指向的数之和等于<code>target</code>就可以了；</li><li>对于有序数组的三数之和，我们可以先固定一个数(即为<code>target</code>)，然后就是找到左右指针指向的数之和等于<code>target</code>就可以了。</li></ul><p>对题目描述中示例进行分析如下图所示：<br><img src="/2019/05/28/LeetCode-15-三数之和/示例1详细分析过程.png" title="示例1详细分析过程"></p><p>在遍历查找过程中有几点需要值得<strong>注意的</strong>：</p><ul><li>题目要求<strong>答案中不可以包含重复的三元组</strong>，因此需要去重处理</li><li>由于数组已排序，当固定数字大于零(即为<code>target&gt;0</code>)时,则它后面的数都大于零，不需要继续查找</li></ul><p><code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 存储满足条件的三元组</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 给数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意遍历的右边界条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len-<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// 去掉重复值</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于数组已排序，当nums[i]&gt;0,则它后面的数都大于零，不需要继续查找</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在数组中查找两个数与nums[i]的和为0, i+1表示左指针，len-1表示右指针，nums[i]表示固定数target</span></span><br><span class="line">            find(nums, i+<span class="number">1</span>, len-<span class="number">1</span>, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = begin, right = end;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 查找满足条件的三个</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left] + nums[right] + target == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 保存这个三个数</span></span><br><span class="line">                List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                tmp.add(target);</span><br><span class="line">                tmp.add(nums[left]);</span><br><span class="line">                tmp.add(nums[right]);</span><br><span class="line">                res.add(tmp);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 去掉重复的值</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>])</span><br><span class="line">                    right--;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 移动左右指针</span></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] + target &lt; <span class="number">0</span>)&#123;    <span class="comment">// 当这个三个之和小于0，则左指针向右移动</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 当这三个数大于零，则右指针向左移动</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A15_3Sum.java" target="_blank" rel="noopener">LeetCode-15 三数之和</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/ljiabin/article/details/40620579" target="_blank" rel="noopener">15.三数之和</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：15. 三数之和&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>《批判性思维工具(Critical Thinking)》-读书笔记(二):成为公正的思考者</title>
    <link href="http://JacobLei.github.io/2019/05/26/%E3%80%8A%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E6%88%90%E4%B8%BA%E5%85%AC%E6%AD%A3%E7%9A%84%E6%80%9D%E8%80%83%E8%80%85/"/>
    <id>http://JacobLei.github.io/2019/05/26/《批判性思维工具-Critical-Thinking-》-读书笔记-二-成为公正的思考者/</id>
    <published>2019-05-26T08:51:06.000Z</published>
    <updated>2019-05-28T12:49:12.356Z</updated>
    
    <content type="html"><![CDATA[<p>入职前公司指定几本必读书籍帮助我们从学生到职场的转身，积累基础的知识储备，扩宽视野。《批判性思维工具(Critical Thinking)》在必读书籍之首，以下是我的读书笔记。</p><a id="more"></a><p><strong>公正</strong>是一个优秀思考者的前提，然而并不是所有的思维方式都是公正的，我们可能会成为一名不公正的思考者。我们常常自私、狭窄地学习和应用思维技能。本章中通过介绍<strong>公正性</strong>的含义以及<strong>公正性思维的特质</strong>。</p><h1 id="批判性思维的强弱"><a href="#批判性思维的强弱" class="headerlink" title="批判性思维的强弱"></a>批判性思维的强弱</h1><p>从公正性的角度出发，批判性思维会走向两个方向：<strong>自我中心</strong>或<strong>公正</strong>。大多时候，我们为了自身利益，很容易自发地走向自我为中心的角度去思考问题，而需要通过刻意练习才能具备公正的思考方式。如果我们掌握了这种公正性，我们就能避免利用思维技能来服务自身的利益；我们就能以同样的标准对待所有的观点；我们会希望自己和对手都能合理地推理；我们就能对对手和自己采用同样的推理评判标准；我们就能像质疑他人一样质疑反思自己的目的、证据、结论、意义和观点。</p><p>对于公正批判性思考者所包含的思维特质如下图所示：<br><img src="/2019/05/26/《批判性思维工具-Critical-Thinking-》-读书笔记-二-成为公正的思考者/批判性思考者需要努力培养必要的思维特征和品质.png" title="批判性思考者需要努力培养必要的思维特征和品质"></p><p>相反地，自我为中心判性思考者所包含的如下思维特质中的一项或多项：<br><img src="/2019/05/26/《批判性思维工具-Critical-Thinking-》-读书笔记-二-成为公正的思考者/自我为中心的思维品质.png" title="自我为中心的思维品质"></p><h1 id="公正性需要什么"><a href="#公正性需要什么" class="headerlink" title="公正性需要什么"></a>公正性需要什么</h1><p>公正性要求我们努力平等地对待每一种观点。这需要我们认识到我们常常对他人的观点抱有偏见，我们常常会给他人的观点贴上“喜欢”（赞成我们观点的）和“不喜欢”（不赞成我们观点的）两类标签。公正性需要我们没有偏见地对待所有相关的观点，排除个人、亲友、集体和国家的感受和利益的影响。它要求坚持良好的思维标准（如准确性、逻辑清晰、广度等），不受个人和团体利益的影响。</p><p>公正性的反面就是思维的不公。思维不公指的是推卸准确、清晰地表达相左意见的责任。当我们不公地思考的时候，我们总是认为自己是正确的、公正的。因为我们天生都是以自我为中心的，所以我们都会落入不公正的思维陷阱。完全公正的思维状态是我们永远也达不到的理想状态。公正性要求我们同时拥有思维的谦逊、勇气、换位思考、正直性、坚毅、自主性和对推理的信心（用好的推理说服自己）特质。</p><h2 id="思维谦逊：努力发现自己对未知知识忽视的程度"><a href="#思维谦逊：努力发现自己对未知知识忽视的程度" class="headerlink" title="思维谦逊：努力发现自己对未知知识忽视的程度"></a>思维谦逊：努力发现自己对未知知识忽视的程度</h2><blockquote><p>思维谦逊就是要认识到<strong>自己对未知知识的忽视程度</strong>。因此，思维谦逊要求个体清晰地认识到自我中心导致的自欺行为（认为自己比自己实际知道的要多）。这意味着个体要对自己的偏见和观点的局限性有所了解。它要求我们清晰地认识到自己有哪些信息是不知道的，特别是事件能够引起个体强烈情感的时候，更要知道对该事件自己有哪些不清楚的地方。思维谦逊要求我们<strong>不能宣称自己知道我们实际上并不知道的事情</strong>。思维谦虚并不是懦弱、服从，而是摒弃自负。思维谦逊要求我们觉察并且评估自己信念的基础，要求我们找出那些不能被正确的推理所支持的信念。</p></blockquote><p>与思维谦逊相反的就是思维自负，即认为自己知道了实际并不知道的事情。思维自负的人缺乏对自欺行为和观点局限性的认识，他们常常声称了解自己其实并不了解的事情。思维自负的人常常也会成为自己偏见的受害者。当我们谈论思维自负时，并不一定就是指那些外表上看起来自以为是、高傲自大的人。这些思维自负的人外在表现很可能是十分谦虚的。</p><p>思维的自负和公正是不兼容的，因为如果我们对自己判断的事情过分自信，我们就很难做出公正的判断。思维谦逊对于成为公正的批判性思维者十分重要。要成为公正的思考者，就要了解自己缺乏哪些知识，这种了解可以让我们从多方面提高我们的思维。它可以让我们认识到偏见、错误信念和不良思维习惯能够导致学习缺陷。</p><h2 id="思维的勇气：培养自己敢于挑战大众信念的勇气"><a href="#思维的勇气：培养自己敢于挑战大众信念的勇气" class="headerlink" title="思维的勇气：培养自己敢于挑战大众信念的勇气"></a>思维的勇气：培养自己敢于挑战大众信念的勇气</h2><blockquote><p><strong>具有思维勇气就意味着个体能够公正地面对各种意见、信念和观点，即使这会让你感到痛苦</strong>。它可以让你准确公平地评判与你意见相左的信念。思维的勇气一个重要的作用，就是可以帮助你判断在社会大众普遍接受的观点中，哪些是合理的，哪些仅仅是主观喜好的结果。具有思维勇气的人知道有时候社会传输给我们的结论和信念也是错误的。<br>为了确定信息的准确性，一个人不能只是被动地、不加批判地接受所有东西。要具有思维勇气，要了解那些被社会认为是危险和荒谬的观点常常包含着一些真理，而群体普遍认同的观点也可能包含错误。要做到公正地思考，我们必须培养思维的勇气，必须不畏惧不遵从大众观点可能受到的社会严厉惩罚。</p></blockquote><p>与思维的勇气相对的是思维的懦弱，是害怕自己与他人观点不同。如果缺乏思维勇气，我们就不敢对那些我们认为是危险荒谬的意见、信念和观点进行认真思考。如果缺乏思维勇气，当我们面对强烈冲突观点的时候，我们会感到威胁，不愿意去检查审视自己的思维，也就很难做到思维的公正性。</p><p>思维勇气重要的另一个原因，是它能够有力地帮助我们应对他人的反驳。他人有对我们提出质疑的权利，他们持有特定的信念，当我们挑战他们的信念时，他们可能会做出反驳。<strong>很多人通过别人的观点来判断自己，从他人的称赞中来认同自己</strong>。这些人的思想背后隐藏着对被反驳的恐惧，很少有人会去挑战自己所属群体的意识形态和信念系统，这是思维懦弱的第二种形式。这两种形式都使我们不能公正地考虑自己和他人的观点。</p><p><strong>我们不应该以自己的个人信念来定义自己，界定自己最好的方法是根据形成信念的过程来做出关于自己的定义</strong>。这就是我们所谓的批判性思考者。思考下面的解决办法。</p><blockquote><p>我不会认同任何信念的内容。我只认同自己形成信念的过程。我是一个批判性思考者，我愿意检验我的信念，并且愿意放弃那些不能被证据和理性思考支持的信念。我会时刻跟随证据和推理的脚步。我的真实身份是一个批判性思考者、一个终生的学习者、一个通过建立更加合理的信念不停寻求提高自己思考水平的人。</p></blockquote><p>当我们不再将我们自己的身份和信念联系起来的时候，我们的思维就会更有勇气、更加公正。我们不会再为有相斥的信念而感到恐惧，不会再为自己的信念被证明是错误的而感到恐惧。我们可以轻松地承认自己曾经犯过的错误，并乐意去纠正自己：“告诉我你的信念、理由，或许我可以从你的信念中进行学习。我会随时准备放弃那些与事实不相符的信念。”</p><h2 id="思维换位思考：从他人的角度学习理解相反的观点"><a href="#思维换位思考：从他人的角度学习理解相反的观点" class="headerlink" title="思维换位思考：从他人的角度学习理解相反的观点"></a>思维换位思考：从他人的角度学习理解相反的观点</h2><blockquote><p><strong>思维的换位思考就是站在他人的角度思考问题，从而真正地理解他人的观点</strong>。这要求我们准确地再现他人的观点和推理，从他人的前提、假设和观点进行推理。这一特质要求个体积极回忆自己坚持错误的情况，也要求个体有能力辨别在当前情况下也可能会犯类似的错误。</p></blockquote><p>与思维换位思考相对的是<strong>思维的自我中心性</strong>，即以自我为中心来进行思考。当我们从自我中心的角度进行思考的时候，我们就不能理解他人的思想、感受和情感。很不幸，<strong>自我中心倾向是我们思维的自然本性</strong>，我们大部分的注意力都集中在自己身上。我们的痛苦、需要和希望都是最重要的，他人的需要无关紧要。我们不会主动地从反对者的角度考虑问题，也不会主动从那些可能改变我们自己观点的角度思考问题。</p><p>不能够理解他人的观点，又如何能够公正地对待他人呢？<strong>公正的思维需要努力置身于他人（或其他有知觉的动物）情景，思考他人观点</strong>。这需要我们尊重那些孕育出不同观点的背景和环境。人类思维的方式源于人们生活情景，源于不同的背景和情况。如果我们不能从他人的角度出发准确地理解他人的观点，我们就不能公正地评判他们的观点和信念。但是，从他人的观点思考问题不是一件容易的事，这是一项很难获得的技能。</p><p>为了培养思维换位思考的技能，请练习下面的策略：</p><ul><li>在不同意某人观点的时候，换位思考。告诉对方，“接下来10分钟我将从你的观点出发与你谈话，如果你也能从我的观点出发进行谈话。这种方法可以使我们更好地了解对方。”确保你能够准确地表达对方的观点。</li><li>在讨论的过程中，用下面的句子总结对方的谈话：“你是不是想说<strong>_</strong>。对吗？”</li><li>阅读的时候，告诉自己你认为作者想要说什么。这样可以使你能够正确地理解他人的观点，从他人的观点思考问题。只有这样你才有资格来评论他人的观点。</li></ul><h2 id="思维正直：用同样的标准评判他人和自己"><a href="#思维正直：用同样的标准评判他人和自己" class="headerlink" title="思维正直：用同样的标准评判他人和自己"></a>思维正直：用同样的标准评判他人和自己</h2><blockquote><p><strong>思维正直是指尊重严谨的思维，用同样的标准要求自己和他人</strong>。</p></blockquote><p>思维正直的反面就是思维虚伪，是指一种不诚实、自相矛盾的思维状态。因为思维的天性是自我中心的，是虚伪的，它会为我们不合理的思维和行为进行辩解，使之合理化。自我内部需要塑造一个积极的形象，对于自我中心思想来说，诚实的表象是很重要的。因此，我们常常将虚伪隐藏起来，即使我们要求他人的标准更加严格，我们也认为自己是公正的。即使我们声称遵守某些信念，但却常常言行不一。</p><p><strong>当思想和行为一致的时候，我们就是思维正直的</strong>。我们做到了我们承诺的，没有表面说一套实际上却做另一套。</p><p>很明显，如果我们用不一致的标准去评判自己和他人的思维，我们就无法公正地对待他人，虚伪的实质是不公。如果我们不能认识到自己思想和行为之间的不一致性，我们就不能对自己的道德问题进行合理的推理，就会为了自身的利益歪曲其他的观点。</p><h2 id="思维坚毅：不轻易地放弃；战胜挫折和困难"><a href="#思维坚毅：不轻易地放弃；战胜挫折和困难" class="headerlink" title="思维坚毅：不轻易地放弃；战胜挫折和困难"></a>思维坚毅：不轻易地放弃；战胜挫折和困难</h2><blockquote><p><strong>思维坚毅指的是战胜挫折、完成复杂任务的品格</strong>。有些困难十分复杂，不容易解决。但思维坚毅的人面对复杂任务和挫折时不会放弃，他们清楚认真地对复杂问题进行推理比快速得出结论更加重要。思维坚毅要求严格遵守理性标准，而不是根据第一印象做出判断或是快速给出简单化的答案。它还要求对困惑和未解决的问题进行长时间努力的思考，并从中获得深刻的见解。</p></blockquote><p>与思维坚毅相反的是思维的懒惰，思维懒惰的人在应对具有挑战性任务的时候很容易放弃，他们对复杂思维活动带来的痛苦和沮丧容忍度较低。</p><p>高水平的思维活动需要思维坚毅，因为高水平的思维活动都包含一定的思维挑战。没有思维坚毅性，就无法克服这些挑战。数学、化学、物理、文学、艺术及其他任何领域的高质量推理都需要思维的坚毅。</p><p>缺乏思维的坚毅是如何影响思考公正的呢？<strong>在理解他人的观点时，只要他们的观点与我们的不同或是本质上较复杂，都需要思维坚毅</strong>。如果我们不能理解他人的观点，考虑他人使用的信息，理解并分析他人对这些信息的解释、他人的信念，那么我们就不能了解他们的目的以及他们看待世界的观点，就不能公正地对待他们的观点。</p><h2 id="对推理的信心：重视证据和推理，将之视为发现真相的重要工具"><a href="#对推理的信心：重视证据和推理，将之视为发现真相的重要工具" class="headerlink" title="对推理的信心：重视证据和推理，将之视为发现真相的重要工具"></a>对推理的信心：重视证据和推理，将之视为发现真相的重要工具</h2><blockquote><p><strong>对推理的信心是建立在两种信念基础上的，第一种信念就是给人们提供自由推理的环境、鼓励人们靠自己的推理能力得出结论会满足人们高层次的需要。这种信心同时也建立在第二种信念基础上，这种信念就是人们可以学会自己思考；形成有价值的观点；得出合理的结论；清晰、准确、相关、有逻辑地思考；借助良好的推理和明确的证据来说服彼此；并且排除那些人类本性和社会生活中障碍的影响，成为理性的人</strong>。当一个人有了对推理的信心时，他就会按照合理的推理行动。合乎理性这一观点就成为人们一生最有价值的东西。简单来讲，<strong>对推理的信心就是将正确的推理作为接受或拒绝某一观点和立场的基本标准</strong>。</p></blockquote><p>与推理信心相反的是对推理的怀疑。不严谨的思考者会感到合理推理带来的威胁。人在本性上是不擅长分析自己观点，而又对自己的观点坚信不疑的。我们对自己的观点分析得越多，我们就会发现自己观点中存在越多的问题，就会更少地去坚持未经分析过的观点。没有对推理的信心，人们自然地会坚定地相信自己的观点，不管这些观点有多么荒唐。</p><p>对推理的信心和思维公正之间具有直接的联系。一个思维公正的人不可能对推理的重要性置之不理。如果我宣称能够做到思维公正，而我却不考虑与我观点相左的合理推理，这就是一个缺乏对推理的信心、思维不公正的例子。思维公正要求我们考虑以前从未考虑过的推理、考虑合理推理，要求我们根据更合逻辑、更准确、更公正地推理调整自己的观点，而做到这些的前提是对推理拥有信心，当能够进行合理的推理时，我们就能更好地思考。</p><h2 id="思维自主：重视思考的独立性"><a href="#思维自主：重视思考的独立性" class="headerlink" title="思维自主：重视思考的独立性"></a>思维自主：重视思考的独立性</h2><blockquote><p><strong>思维自主意味着坚持用合理的标准进行思考</strong>。这意味着自己要对事物进行思考而不是不加判断地接受别人的观点。思维自主的思考者在决定接受或者拒绝某观点的时候不依赖于他人。只有证据证明他人的观点是合理的时候，他们才会接受他人的观点。</p></blockquote><p>在形成观点的过程中，批判性思考者不是被动地接受他人的观点，而是自己积极主动地对环境和事件进行思考。当然，对于思维自主的理解不能局限在其这一特质本身，我们应该将它理解为与思维其他特质互相联系、互相影响的一个维度。</p><p>与思维自主性相反的是思维遵从和思维依赖。思维自主是很难培养的，是因为无论是在知识领域、政治领域还是经济领域，在很大程度上，人们总是被动地接受社会现实，自主性思考几乎肯定不会得到社会权威认可的结论，只有简单地遵从社会期望的思维和行为模式才能被社会接受。</p><p>因此，<strong>大多数人在思维和行为上都是因循守旧的，像镜子一样接受周围人的价值和信念系统，缺少自己独立思考的能力和动力，成为思维遵从的思考者</strong>。只要人们不加批判地接受他人的文化价值观，只要人们没有经过自己分析就遵从别人的信念，人们的思维就不是自由的。</p><p>人们不可能在思维遵从的情况下做到思考公正，因为独立思考是多角度看待问题的前提条件。当我们思维遵从的时候，<strong>我们仅仅能在“接受”的观点中进行思考</strong>；而要做到思考公正就是要拒绝不加判断的接受，没有亲自对这些观点的优缺点进行思考就不能接受这些观点。没有思维自主性的人在思考其他观点时，要么是非常容易被这些观点动摇（因为我们没有能够看穿操纵与宣教），要么会歪曲这些观点（因为这些观点与我们从前形成的信念系统不一致）。</p><h1 id="认识思维特质之间的相互关联性"><a href="#认识思维特质之间的相互关联性" class="headerlink" title="认识思维特质之间的相互关联性"></a>认识思维特质之间的相互关联性</h1><p>批判性思维所有必要的思维特质是相互关联的。思考一下思维谦逊：为了能够意识到自己知识的局限性，我们需要思维勇气来面对我们自己的偏见和无知。为了能够发现我们的偏见，我们常常需要注重那些反对观点并进行合理推理。为了达到这些目的，我们必须要有思维的坚毅性，因为学着理解我们的偏见需要时间和努力。除非我们有对推理的信心来相信我们不会犯错误，不会被相反观点所误导，否则这种努力不会显得公正。</p><p>此外，虽然思考其他观点不会损害我们的利益，但是这并不足以激发我们去仔细思考这些观点。我们必须做到思维公正，必须认识到公正地对待反对观点的责任，必须倾听那些反对观点来确保我们没有忽视和偏见。而要做到这一点，我们又回到了最初的出发点：思维谦逊。</p><p>下表总结了惯常思维和批判性思维的区别：<br><img src="/2019/05/26/《批判性思维工具-Critical-Thinking-》-读书笔记-二-成为公正的思考者/惯常思维和批判性思维的区别.png" title="惯常思维和批判性思维的区别"></p><p>下表总结了培养优秀的思维特征需要经常问自己的问题：<br><img src="/2019/05/26/《批判性思维工具-Critical-Thinking-》-读书笔记-二-成为公正的思考者/培养优秀的思维特征需要经常问自己的问题.png" title="培养优秀的思维特征需要经常问自己的问题"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong>真正杰出的思考者并不是孤立思维特质的产物</strong>。没有这些优秀思维特质的人，会不可避免地犯错而自己却时常觉察不到。这些人的思维特质是不严谨的，当他们无意识地去相信自己想要相信的观点、相信那些可以令自己舒服的观点、相信那些可以符合自身利益的观点、相信那些满足自己自私需求的观点时，这些人就不是一个理性的批判性思考者了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;入职前公司指定几本必读书籍帮助我们从学生到职场的转身，积累基础的知识储备，扩宽视野。《批判性思维工具(Critical Thinking)》在必读书籍之首，以下是我的读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://JacobLei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="批判性思维工具(Critical Thinking)》" scheme="http://JacobLei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B/"/>
    
    
      <category term="批判性思维工具(Critical Thinking)》" scheme="http://JacobLei.github.io/tags/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B/"/>
    
      <category term="读书笔记" scheme="http://JacobLei.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《批判性思维工具(Critical Thinking)》-读书笔记(一)</title>
    <link href="http://JacobLei.github.io/2019/05/26/%E3%80%8A%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <id>http://JacobLei.github.io/2019/05/26/《批判性思维工具-Critical-Thinking-》-读书笔记-一/</id>
    <published>2019-05-26T05:48:33.000Z</published>
    <updated>2019-05-26T07:17:36.344Z</updated>
    
    <content type="html"><![CDATA[<p>入职前公司指定几本必读书籍帮助我们从学生到职场的转身，积累基础的知识储备，扩宽视野。《批判性思维工具(Critical Thinking)》在必读书籍之首，以下是我的读书笔记。</p><a id="more"></a><p>在本书的前言中描述道：<strong>思维方式决定着行为方式。思维决定行为，感受和需求。</strong>这就是说不同的思维方式会导致不同的行为、感受和需求，这一点我相信大多数人都会产生共鸣。对于同一件事不同的个体（人）会有不同的思维方式，从而对该事情会有不同的认知，而该事情的结果反作用于个体，产生了不同的影响，最终导致个体的差异越来越明显。如一个人的思维方式过于悲观，他则会错失生活中很多快乐的事情，而生活大部分处于悲观的状态，也会影响他的思维方式处于越来越悲观。<br>而<strong>大多数人的思维方式都是潜意识的</strong>，大部分悲观的人不会承认自己是悲观的思维一样，他们也不会承认他们自己用一种消极悲观的方式来思考自我和总结自我。<br>该书主要讲解如何突破个体的固有思维，去通过练习学习那些幸福、成功人士的思维方式，通过阅读和实践本书，将会成为一个掌握自己命运的批判性思考者，但<strong>最终决定个体的思维方式是否能够改善的方式还是个体本身提高的意愿</strong>。<br>接着该书总结了一些成功思考者的特性：</p><ul><li><strong>优秀的思考者总是在思考他们的思维过程</strong>。优秀的思考者认为思维并不是自动的。他们不认为优秀的思维方式是天生的，他们关注自己的思维过程，不断地对其进行反省和调整。</li><li><strong>优秀的思考者都会有明确的目标</strong>。优秀的思考者从不盲目，他们知道自己的目标所在。他们清楚自己想要什么，拥有明确的目标并知道这些目标之间的优先顺序。他们不断地检查和调整自己的行动使其服从于目标。</li><li><strong>优秀的思考者使用一些思维“工具”来提升他们思维的质量</strong>。优秀的思考者知道如何清晰地表述自己的思维方式、如何检查思维方式的准确性和精确性。他们知道如何专注于目的相关的问题上。优秀的思考者知道如何全方位深度地看待问题，使思维方式更加具有逻辑性。</li><li><strong>优秀的思考者能够将他们的思维与感受、需求相分离</strong>。优秀的思考者清楚想法自身不能转化为现实，他们知道人们会不理性地感到愤怒、害怕或者缺乏安全感，但他们不会允许无端的情感左右他们的决策。他们能洞察自己的心思，这使得他们可以审查自己思维运作的过程，从而可以仔细地控制思维过程。</li><li><strong>优秀的思考者常常分解、剖析事情</strong>。优秀的思考者常常“分析”他们的思维方式。他们不相信心智可以自动对思维方式进行分析。我们必须有意识地学习分析思维方式这个方法。</li><li><strong>优秀的思考者经常评估自己的思维方式——找出他们思维方式的优缺点</strong>。优秀的思考者不相信心智会对自己自动地进行评估。他们认识到心智对自己的评估方法有天生的缺陷。</li></ul><p>这本书作为一个整体，展示了对生活中的问题和困难进行正确思考的思维方法和技巧，帮助我们解决学习中、生活中和职业道路上遇到的困难。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;入职前公司指定几本必读书籍帮助我们从学生到职场的转身，积累基础的知识储备，扩宽视野。《批判性思维工具(Critical Thinking)》在必读书籍之首，以下是我的读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://JacobLei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="批判性思维工具(Critical Thinking)》" scheme="http://JacobLei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B/"/>
    
    
      <category term="批判性思维工具(Critical Thinking)》" scheme="http://JacobLei.github.io/tags/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B/"/>
    
      <category term="读书笔记" scheme="http://JacobLei.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-14 最长公共前缀</title>
    <link href="http://JacobLei.github.io/2019/05/26/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://JacobLei.github.io/2019/05/26/LeetCode-14-最长公共前缀/</id>
    <published>2019-05-26T04:18:39.000Z</published>
    <updated>2019-05-28T12:49:07.223Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：14. 最长公共前缀</li><li>难度：简单</li><li>分类：字符串</li><li>解决方案：字符串遍历<a id="more"></a></li></ul><p>今天我们学习第14题<strong>最长公共前缀</strong>，这是一道简单题。像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">题目描述</a></h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串<code>&quot;&quot;</code>。<br>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题目让我们求字符串数组中的最长公共前缀，我们可以使用第0行的字符串作为基准，与其他剩余的字符串比较来找出最长的公共前缀，示例1分析方法如下图所示：<br><img src="/2019/05/26/LeetCode-14-最长公共前缀/暴力求解示意图分析.png" title="暴力求解示意图分析"></p><p>将上述分析方法转化为<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span>  res.toString();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; strs[<span class="number">0</span>].length(); col++)&#123;</span><br><span class="line">            <span class="comment">// 第0行的第col个字符</span></span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(col); </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 基准字符串中的字符与其他字符串中的字符进行对比</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; strs.length; row++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(col &gt;= strs[row].length() || strs[row].charAt(col) != c)</span><br><span class="line">                    <span class="keyword">return</span>  res.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/26/LeetCode-14-最长公共前缀/暴力求解提交结果.png" title="暴力求解提交结果"><p>仔细想想，如果字符串数组按照字符顺序排好序后（可以使用相关语言的排序函数进行排序，排好序后数组中共同字母多的字符串会被放到一起，而共同字符最少的字符串则会被放到首尾两端），我们不需要比较所有的字符串，而只需要比较首字符串和尾字符串即可，用这种排序方法对示例1分析的示意图如所下图所示：<br><img src="/2019/05/26/LeetCode-14-最长公共前缀/排序示意图分析.png" title="排序示意图分析"></p><p>将上述分析方法转化为<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span>  res.toString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将字符串数组排序</span></span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 取数组中的首尾字符串，并将其转为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] firstRow = strs[<span class="number">0</span>].toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] lastRow = strs[strs.length-<span class="number">1</span>].toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找公共前缀时只需要查找最短长度的字符串</span></span><br><span class="line">        <span class="keyword">int</span> len = firstRow.length &lt; lastRow.length ? firstRow.length : lastRow.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较首位两个字符串，取最长公共前缀</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(firstRow[i] != lastRow[i])</span><br><span class="line">                <span class="keyword">return</span> res.toString();</span><br><span class="line">            res.append(firstRow[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/26/LeetCode-14-最长公共前缀/字符串数组排序后提交结果.png" title="字符串数组排序后提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A14_LongestCommonPrefix.java" target="_blank" rel="noopener">LeetCode-14 最长公共前缀</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">14.最长公共前缀</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：14. 最长公共前缀&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：字符串遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="字符串" scheme="http://JacobLei.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-13 罗马数字转整数</title>
    <link href="http://JacobLei.github.io/2019/05/26/LeetCode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>http://JacobLei.github.io/2019/05/26/LeetCode-13-罗马数字转整数/</id>
    <published>2019-05-26T02:27:15.000Z</published>
    <updated>2019-05-26T03:39:58.882Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：13. 罗马数字转整数</li><li>难度：简单</li><li>分类：字符串、数学</li><li>解决方案：字符串遍历<a id="more"></a></li></ul><p>今天我们学习第13题<strong>罗马数字转整数</strong>，这是一道简单题，这是我们昨天学习的<a href="https://www.jacob2359.com/2019/05/25/LeetCode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/#more" target="_blank" rel="noopener">eetCode-12 整数转罗马数字</a>的逆过程。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">题目描述</a></h1><p>罗马数字包含以下七种字符：<code>I</code>，<code>V</code>，<code>X</code>， <code>L</code>，<code>C</code>，<code>D</code>和<code>M</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>例如，罗马数字<code>2</code>写做<code>II</code>，即为两个并列的<code>1</code>。<code>12</code>写做<code>XII</code>，即为<code>X + II</code>。<code>27</code> 写做<code>XXVII</code>, 即为<code>XX + V + II</code>。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如<code>4</code>不写做 <code>IIII</code>，而是<code>IV</code>。数字<code>1</code>在数字<code>5</code>的左边，所表示的数等于大数<code>5</code>减小数<code>1</code> 得到的数值<code>4</code>。同样地，数字<code>9</code>表示为<code>IX</code>。这个特殊的规则只适用于以下六种情况:</p><ul><li><code>I</code> 可以放在 <code>V (5)</code> 和 <code>X (10)</code> 的左边，来表示 <code>4</code> 和 <code>9</code>。</li><li><code>X</code> 可以放在 <code>L (50)</code> 和 <code>C (100)</code> 的左边，来表示 <code>40</code> 和 <code>90</code>。 </li><li><code>C</code> 可以放在 <code>D (500)</code> 和 <code>M (1000)</code> 的左边，来表示 <code>400</code> 和 <code>900</code>。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>题目要求我们将一个罗马数转为整数数，并给出了罗马数与整数的对应规则，如下图所示。</p><img src="/2019/05/26/LeetCode-13-罗马数字转整数/罗马数与整数的对应规则.png" title="罗马数与整数的对应规则"><p>根据题目可以归纳出罗马数的基本组成规则：</p><ul><li>相同的数字连写，所表示的数等于这些数字相加得到的数，如：<code>II=2</code></li><li>小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数， 如：<code>XII=12</code></li><li>小的数字，（限于<code>Ⅰ</code>、<code>X</code> 和<code>C</code>)在大的数字的左边，所表示的数等于大数减小数得到的数，如：<code>Ⅳ= 4</code></li></ul><p>根据上面规则可以知道，对于一个给定的罗马数来说，我们可以从左到右遍历这个字符串并统计<code>I</code>，<code>V</code>，<code>X</code>， <code>L</code>，<code>C</code>，<code>D</code>和<code>M</code>这七个字符出现的次数。统计时需要注意：</p><ul><li>对于<code>I</code>字符如果后面为<code>V</code>或者<code>X</code>则<code>I</code>出现的次数减一，否则<code>I</code>字符出现次数加一；</li><li>对于<code>X</code>字符如果后面为<code>L</code>或者<code>C</code>则<code>X</code>出现的次数减一，否则<code>X</code>字符出现次数加一；</li><li>对于<code>C</code>字符如果后面为<code>D</code>或者<code>M</code>则<code>C</code>出现的次数减一，否则<code>C</code>字符出现次数加一；</li><li>对于剩余的字符，出现一次则加一。</li></ul><p>对示例5进行详细分析，过程如下图所示：<br><img src="/2019/05/26/LeetCode-13-罗马数字转整数/示例5详细过程.png" title="示例5详细过程"></p><p><code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化七种字符出现的次数为0</span></span><br><span class="line">        <span class="keyword">int</span> I = <span class="number">0</span>, V = <span class="number">0</span>, X = <span class="number">0</span>, L = <span class="number">0</span>, C = <span class="number">0</span>, D = <span class="number">0</span>, M = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历字符串，统计每种字符串出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'I'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;s.length() &amp;&amp; (s.charAt(i+<span class="number">1</span>) == <span class="string">'V'</span> || s.charAt(i+<span class="number">1</span>) == <span class="string">'X'</span>))</span><br><span class="line">                    I--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    I++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'V'</span>)&#123;</span><br><span class="line">                V++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'X'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;s.length() &amp;&amp; (s.charAt(i+<span class="number">1</span>) == <span class="string">'L'</span> || s.charAt(i+<span class="number">1</span>) == <span class="string">'C'</span>))</span><br><span class="line">                    X--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    X++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'L'</span>)&#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'C'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;s.length() &amp;&amp; (s.charAt(i+<span class="number">1</span>) == <span class="string">'D'</span> || s.charAt(i+<span class="number">1</span>) == <span class="string">'M'</span>))</span><br><span class="line">                    C--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    C++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'D'</span>)&#123;</span><br><span class="line">                D++;   </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'M'</span>)&#123;</span><br><span class="line">                M++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> I + V*<span class="number">5</span> + X*<span class="number">10</span> + L*<span class="number">50</span> + C*<span class="number">100</span> + D*<span class="number">500</span> + M*<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/26/LeetCode-13-罗马数字转整数/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A13_RomantoInteger.java" target="_blank" rel="noopener">LeetCode-13 罗马数字转整数</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13.罗马数字转整数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：13. 罗马数字转整数&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：字符串、数学&lt;/li&gt;
&lt;li&gt;解决方案：字符串遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="字符串" scheme="http://JacobLei.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="数学" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
