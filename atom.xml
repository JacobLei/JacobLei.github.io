<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jacob2359</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://JacobLei.github.io/"/>
  <updated>2019-05-31T13:37:31.858Z</updated>
  <id>http://JacobLei.github.io/</id>
  
  <author>
    <name>jacob2359</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-19 删除链表中的倒数第N个节点</title>
    <link href="http://JacobLei.github.io/2019/05/31/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://JacobLei.github.io/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/</id>
    <published>2019-05-31T08:50:22.000Z</published>
    <updated>2019-05-31T13:37:31.858Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：19. 删除链表中的倒数第N个节点</li><li>难度：中等</li><li>分类：链表</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第19题<strong>删除链表中的倒数第N个节点</strong>，这是一道中等题。这个题属于面试中的高频题，一定要能手写出来。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个链表，删除链表的倒数第<code>n</code>个节点，并且返回链表的头结点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure></p><p>说明：<strong>给定的<code>n</code>保证是有效的。</strong></p><p>进阶：<strong>你能尝试使用一趟扫描实现吗？</strong></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题是目前为止遇到的第一个链表题，对于链表不太熟悉的小伙伴可以扫描文章下方的二维码，关注『 算法半岛』回复『 数据结构目录』，即可获得相关学习资料。</p><p>这个题让我们删除链表中的倒数第<code>n</code>个节点，并且返回头节点。题目中说明部分提到<strong>给定的<code>n</code>保证是有效的</strong>，因此<code>n</code>的值小于等于链表的长度。最基本的方法，我们可以先遍历一次链表，统计链表的长度<code>len</code>，则删除的节点位置为<code>len-n+1</code>。然后找到删除节点位置的前一个节点(位置为<code>len-n</code>)对节点进行删除即可。注意<strong>如果删除的节点为第一个节点，则直接返回<code>head.next</code>即可</strong>。对示例分析如下图所示：</p><img src="/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/两次遍历方法.png"><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计链表节点的个数</span></span><br><span class="line">        <span class="keyword">while</span>(p.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算删除节点的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = len - n + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除节点如果为第一个节点，则直接返回head.next</span></span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重置p指针的位置</span></span><br><span class="line">        p = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找需要删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;pos-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除该节点</span></span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/两次遍历提交结果.png" title="两次遍历提交结果"><p>进阶部分提示我们<strong>尝试使用一趟扫描实现</strong>，对于这样的题，我们可以使用双指针(快慢指针)来实现。具体分析过程如下图所示：</p><img src="/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/快慢指针法.png"><p>值得注意的是，<strong>当删除的结点为第一个节点，则<code>fast==null</code>，因此在<code>fast</code>走<code>n</code>步后需要判断<code>fast</code>是否为<code>null</code>，如果为<code>null</code>则直接返回<code>fast.next</code></strong>。</p><p>上述分析所对应的<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 声明快慢指针</span></span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fast指针走n步</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;          </span><br><span class="line">            fast = fast.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断需要删除的节点是否为第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同时移动快慢指针</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/31/LeetCode-19-删除链表中的倒数第N个节点/提交结果.png" title="快慢提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A19_RemoveNthNodeFromEndofList.java" target="_blank" rel="noopener">LeetCode-19 删除链表中的倒数第N个节点</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">删除链表中的倒数第N个节点</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：19. 删除链表中的倒数第N个节点&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：链表&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="链表" scheme="http://JacobLei.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-18 四数之和</title>
    <link href="http://JacobLei.github.io/2019/05/31/LeetCode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://JacobLei.github.io/2019/05/31/LeetCode-18-四数之和/</id>
    <published>2019-05-31T01:02:34.000Z</published>
    <updated>2019-05-31T02:36:30.255Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：18. 四数之和</li><li>难度：中等</li><li>分类：数组</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第18题<strong>四数之和</strong>，这是一道中等题。像这样数组的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个包含<code>n</code>个整数的数组<code>nums</code>和一个目标值<code>target</code>，判断<code>nums</code> 中是否存在四个元素<code>a</code>，<code>b</code>，<code>c</code>和<code>d</code> ，使得<code>a + b + c + d</code>的值与 <code>target</code>相等？找出所有满足条件且不重复的四元组。</p><p>注意：<strong>答案中不可以包含重复的四元组。</strong></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>在前面，我们做过<a href="https://www.jacob2359.com/2019/05/04/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/" target="_blank" rel="noopener">LeetCode-1 两数之和</a>和<a href="https://www.jacob2359.com/2019/05/28/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" target="_blank" rel="noopener">LeetCode-15 三数之和</a>，这个题目是求四数之和，其基本思路和三数之和差不多，只是在三数之和的基础上增加一个<code>for</code>循环。具体求解过程详见<a href="https://www.jacob2359.com/2019/05/28/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" target="_blank" rel="noopener">LeetCode-15 三数之和</a>。<code>java</code>代码如下所示；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> &amp;&amp; nums.length &lt; <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 固定第一个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">3</span>; ++i)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i+<span class="number">1</span>]&gt;<span class="number">0</span> &amp;&amp; nums[i] &gt;= target)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="comment">// 固定第二个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nums.length-<span class="number">2</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j != i + <span class="number">1</span>) &amp;&amp; nums[j] == nums[j-<span class="number">1</span>]) </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用左右指针进行查找</span></span><br><span class="line">                <span class="keyword">int</span> left = j+<span class="number">1</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                        ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                        tmp.add(nums[i]);</span><br><span class="line">                        tmp.add(nums[j]);</span><br><span class="line">                        tmp.add(nums[left]);</span><br><span class="line">                        tmp.add(nums[right]);</span><br><span class="line">                        res.add(tmp);</span><br><span class="line">                        ++left;</span><br><span class="line">                        --right;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left-<span class="number">1</span>])</span><br><span class="line">                            ++left;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>])</span><br><span class="line">                            --right;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">                        --right;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        ++left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/31/LeetCode-18-四数之和/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A18_4Sum.java" target="_blank" rel="noopener">LeetCode-18 四数之和</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">四数之和</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：18. 四数之和&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-17 电话号码的字母组合</title>
    <link href="http://JacobLei.github.io/2019/05/30/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://JacobLei.github.io/2019/05/30/LeetCode-17-电话号码的字母组合/</id>
    <published>2019-05-30T05:24:15.000Z</published>
    <updated>2019-05-30T07:27:20.678Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：17. 电话号码的字母组合</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：字符串遍历<a id="more"></a></li></ul><p>今天我们学习第17题<strong>电话号码的字母组合</strong>，这是一道中等题。像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个仅包含数字<code>2-9</code>的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意<code>1</code>不对应任何字母。<br><img src="/2019/05/30/LeetCode-17-电话号码的字母组合/题目描述.jpg"></p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure></p><p>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题目的题意很好理解，让我们求电话号码的字母组合，从数字2到9中每个数字可以代表若干个字母，然后输一串数字，求出所有可能的组合。对于每个数字及其对应的字母可用数组建立对应关系，如下图所示。</p><img src="/2019/05/30/LeetCode-17-电话号码的字母组合/数字与其对应的字母.png" title="数字与其对应的字母"><p>我们可以通过这样的对应关系来构成组字符串，如对示例分析的示意图如下所示：</p><img src="/2019/05/30/LeetCode-17-电话号码的字母组合/示例详细分析过程.png" title="示例详细分析过程"><p>图中叶子节点中字符串即为字母组合。<br>将上述分析过程转化为<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数字与字母的对应关系</span></span><br><span class="line">        String[] map = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 图中树的根节点</span></span><br><span class="line">        res.add(<span class="string">""</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历输入的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : digits.toCharArray())&#123;</span><br><span class="line">            res = combine(map[c-<span class="string">'0'</span>], res);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据数字组合字母</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">combine</span><span class="params">(String digits, List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : digits.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">                res.add(s+c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/30/LeetCode-17-电话号码的字母组合/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A17_LetterCombinationsofaPhoneNumber.java" target="_blank" rel="noopener">LeetCode-17 电话号码的字母组合</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：17. 电话号码的字母组合&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：字符串遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="字符串" scheme="http://JacobLei.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-16 最接近的三数之和</title>
    <link href="http://JacobLei.github.io/2019/05/28/LeetCode-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://JacobLei.github.io/2019/05/28/LeetCode-16-最接近的三数之和/</id>
    <published>2019-05-28T12:42:53.000Z</published>
    <updated>2019-05-28T14:24:15.982Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：16. 最接近的三数之和</li><li>难度：中等</li><li>分类：数组</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第16题<strong>最接近的三数之和</strong>，这是一道中等题。像这样数组的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个包括<code>n</code>个整数的数组<code>nums</code>和一个目标值<code>target</code>。找出<code>nums</code>中的三个整数，使得它们的和与<code>target</code>最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [-1，2，1，-4], 和 target = 1.</span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题和<a href="https://mp.weixin.qq.com/s?__biz=MzU5NTkyMDQyOQ==&amp;mid=2247483835&amp;idx=1&amp;sn=f990a98cc015eb9fbc8bf7ceeabe9982&amp;chksm=fe6bd2f9c91c5bef3aa1305ca933860b9f8afb77b78457432530a20d1ce431bea373fc64713b&amp;token=1428867397&amp;lang=zh_CN#rd" target="_blank" rel="noopener">LeetCode-15 三数之和</a>的解题思路差不多，在第15题中是为了寻找满足<code>a + b + c = 0</code>，而在这道题中首先给出了一个目标值<code>target</code>，然后寻找三个数<code>a + b + c</code>的和与<code>target</code>最接近，即<code>|a + b + c-target|</code>的值最小。对示例分析如下图所示：</p><img src="/2019/05/28/LeetCode-16-最接近的三数之和/示例详细分析过程.png" title="示例详细分析过程"><p>将上述分析过程转化为<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;    <span class="comment">// 表示数组中三个元素的和</span></span><br><span class="line">        <span class="keyword">int</span> dis = Integer.MAX_VALUE;   <span class="comment">// 表示数组中三个元素的和与target的距离，即|sum-target|</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">// 定义左指针和右指针</span></span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="comment">// 数组中三个元素的和与target的差，即sum-target </span></span><br><span class="line">                <span class="keyword">int</span> diff = nums[i] + nums[left] + nums[right] - target;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当sum-target == 0，则说明已经找到与target最近的数了（即target本身）</span></span><br><span class="line">                <span class="keyword">if</span> (diff == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 寻找最小距离</span></span><br><span class="line">                <span class="keyword">if</span>(Math.abs(diff) &lt; dis)&#123;</span><br><span class="line">                    dis = Math.abs(diff);</span><br><span class="line">                    sum = diff + target;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 移动左右指针</span></span><br><span class="line">                <span class="keyword">if</span>(diff &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/28/LeetCode-16-最接近的三数之和/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A16_3SumClosest.java" target="_blank" rel="noopener">LeetCode-16 最接近的三数之和</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：16. 最接近的三数之和&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>《批判性思维工具(Critical Thinking)》-读书笔记(三):批判性思维前四个阶段</title>
    <link href="http://JacobLei.github.io/2019/05/28/%E3%80%8A%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%89-%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%89%8D%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
    <id>http://JacobLei.github.io/2019/05/28/《批判性思维工具-Critical-Thinking-》-读书笔记-三-批判性思维前四个阶段/</id>
    <published>2019-05-28T07:25:35.000Z</published>
    <updated>2019-05-28T08:33:50.975Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>入职前公司指定几本必读书籍帮助我们从学生到职场的转身，积累基础的知识储备，扩宽视野。《批判性思维工具(Critical Thinking)》在必读书籍之首，以下是我的读书笔记。</p></blockquote><a id="more"></a><p>大多数人都没有完全表现出自己思维发展的潜能。我们有巨大的潜力，但是我们的潜力绝大多数仍处于休眠和未开发状态。只要我们还认为当下的思维水平是理所当然的，我们就不会进行提高思维的练习。下图为批判性思维发展的阶段。<br><img src="/2019/05/28/《批判性思维工具-Critical-Thinking-》-读书笔记-三-批判性思维前四个阶段/批判性思维发展的阶段.png" title="批判性思维发展的阶段"></p><p>多数人终生都停留在鲁莽的思考者阶段。想要成为完善的思考者需要每天坚持进行练习。</p><h1 id="阶段1-鲁莽的思考者"><a href="#阶段1-鲁莽的思考者" class="headerlink" title="阶段1　鲁莽的思考者"></a>阶段1　鲁莽的思考者</h1><blockquote><p>人生来就是鲁莽的思考者，其中大多数人终生都停留在鲁莽的思考者阶段，从不对自己的思维进行反思，根本没有意识到思考在我们生活中的重要作用。在鲁莽的思考者阶段，没有思考所需要的概念。</p></blockquote><p>鲁莽的思考者通常会：</p><ul><li>不会质疑自己的信念和决定</li><li>没有思维标准，也不知道这些标准应该是什么</li><li>缺乏良好的思维特质但是却意识不到</li><li>没有意识到自欺行为，有很多不实际的幻想，相信自己信念的合理性</li><li>满怀信心地谈论着这个世界，并且认为真实情况就如我们所看到的一样</li><li>对“好坏”进行判定，赞成某些活动，反对另一些活动</li><li>我们做出决定，对别人做出反馈，有着自己的生活方式，并且不会认真地反省自己的思维及其结果</li></ul><p>鲁莽的思考者通常在<strong>自我中心倾向</strong>主导着我们的思考。由于缺少思维技能，鲁莽的思考者注意不到：</p><ul><li>自己的自我中心和偏见</li><li>自己常常对他人进行归类</li><li>己不合理地忽略很多观点仅仅是因为我们不想改变自己的行为和观点</li></ul><h1 id="阶段2-质疑的思考者"><a href="#阶段2-质疑的思考者" class="headerlink" title="阶段2　质疑的思考者"></a>阶段2　质疑的思考者</h1><blockquote><p>我们不能解决自己没有意识到的问题，不能处理一个不存在的情况。如果不能认识到自己知识的局限性，我们就不能寻求自己没有的知识。如果不知道自己需要哪些技能，我们就不能培养他们。</p></blockquote><p>质疑的思考者开始：</p><ul><li>做出有问题的假设</li><li>使用错误的、不完全的或是误导性的信息</li><li>做出与所掌握证据无关的推论</li><li>没有发现我们思维中的重要意义</li><li>没有发现自己的错误</li><li>形成错误的概念</li><li>从具有偏见的观点中进行推理</li><li>自我中心和偏离理性地思考</li></ul><p>当认识到<strong>思考方式塑造着我们的生活，意识到思维中的问题可能导致生活中的问题</strong>时，我们就进入了质疑的思考者阶段。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;入职前公司指定几本必读书籍帮助我们从学生到职场的转身，积累基础的知识储备，扩宽视野。《批判性思维工具(Critical Thinking)》在必读书籍之首，以下是我的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://JacobLei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="批判性思维工具(Critical Thinking)》" scheme="http://JacobLei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B/"/>
    
    
      <category term="批判性思维工具(Critical Thinking)》" scheme="http://JacobLei.github.io/tags/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B/"/>
    
      <category term="读书笔记" scheme="http://JacobLei.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-15 三数之和</title>
    <link href="http://JacobLei.github.io/2019/05/28/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://JacobLei.github.io/2019/05/28/LeetCode-15-三数之和/</id>
    <published>2019-05-28T05:47:15.000Z</published>
    <updated>2019-05-28T13:02:56.991Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：15. 三数之和</li><li>难度：中等</li><li>分类：数组</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第15题<strong>三数之和</strong>，这是一道中等题。像这样数组的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个包含<code>n</code>个整数的数组<code>nums</code>，判断<code>nums</code>中是否存在三个元素<code>a</code>，<code>b</code>，<code>c</code> ，使得 <code>a + b + c = 0 ？</code>找出所有满足条件且不重复的三元组。</p><p>注意：答案中<strong>不可以包含重复的三元组</strong>。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如, 给定数组nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我们做过<a href="https://mp.weixin.qq.com/s?__biz=MzU5NTkyMDQyOQ==&amp;mid=2247483662&amp;idx=1&amp;sn=51920407843f16c16701416061ade8fb&amp;chksm=fe6bd24cc91c5b5a2e9f54985eefa36f4b9554b992e771237091b5574ad8c83d892d6a8b61e8&amp;token=911136023&amp;lang=zh_CN#rd" target="_blank" rel="noopener">LeetCode-1 两数之和</a>，这个题目与它有联系，但也有蛮大的差异。像这样求和的问题我们首先想到的是暴力求解方法，这个题目用暴力求解的时间复杂度为<code>O(n^3)</code>。我们想一想能不能将时间按复杂度降到<code>O(n^2)</code>？</p><p>先将数组进行排序(排序函数的时间复杂度为<code>O(nlgn)</code>)，然后我们就可以对这个有序数组用双指针的方法从左右两边向中间扫描了：</p><ul><li>对于有序数组的两数之和，我们就是找到左右指针指向的数之和等于<code>target</code>就可以了；</li><li>对于有序数组的三数之和，我们可以先固定一个数(即为<code>target</code>)，然后就是找到左右指针指向的数之和等于<code>target</code>就可以了。</li></ul><p>对题目描述中示例进行分析如下图所示：<br><img src="/2019/05/28/LeetCode-15-三数之和/示例1详细分析过程.png" title="示例1详细分析过程"></p><p>在遍历查找过程中有几点需要值得<strong>注意的</strong>：</p><ul><li>题目要求<strong>答案中不可以包含重复的三元组</strong>，因此需要去重处理</li><li>由于数组已排序，当固定数字大于零(即为<code>target&gt;0</code>)时,则它后面的数都大于零，不需要继续查找</li></ul><p><code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 存储满足条件的三元组</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 给数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意遍历的右边界条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len-<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// 去掉重复值</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于数组已排序，当nums[i]&gt;0,则它后面的数都大于零，不需要继续查找</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在数组中查找两个数与nums[i]的和为0, i+1表示左指针，len-1表示右指针，nums[i]表示固定数target</span></span><br><span class="line">            find(nums, i+<span class="number">1</span>, len-<span class="number">1</span>, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = begin, right = end;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 查找满足条件的三个</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left] + nums[right] + target == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 保存这个三个数</span></span><br><span class="line">                List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                tmp.add(target);</span><br><span class="line">                tmp.add(nums[left]);</span><br><span class="line">                tmp.add(nums[right]);</span><br><span class="line">                res.add(tmp);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 去掉重复的值</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>])</span><br><span class="line">                    right--;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 移动左右指针</span></span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left] + nums[right] + target &lt; <span class="number">0</span>)&#123;    <span class="comment">// 当这个三个之和小于0，则左指针向右移动</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 当这三个数大于零，则右指针向左移动</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A15_3Sum.java" target="_blank" rel="noopener">LeetCode-15 三数之和</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/ljiabin/article/details/40620579" target="_blank" rel="noopener">15.三数之和</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：15. 三数之和&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>《批判性思维工具(Critical Thinking)》-读书笔记(二):成为公正的思考者</title>
    <link href="http://JacobLei.github.io/2019/05/26/%E3%80%8A%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E6%88%90%E4%B8%BA%E5%85%AC%E6%AD%A3%E7%9A%84%E6%80%9D%E8%80%83%E8%80%85/"/>
    <id>http://JacobLei.github.io/2019/05/26/《批判性思维工具-Critical-Thinking-》-读书笔记-二-成为公正的思考者/</id>
    <published>2019-05-26T08:51:06.000Z</published>
    <updated>2019-05-28T12:49:12.356Z</updated>
    
    <content type="html"><![CDATA[<p>入职前公司指定几本必读书籍帮助我们从学生到职场的转身，积累基础的知识储备，扩宽视野。《批判性思维工具(Critical Thinking)》在必读书籍之首，以下是我的读书笔记。</p><a id="more"></a><p><strong>公正</strong>是一个优秀思考者的前提，然而并不是所有的思维方式都是公正的，我们可能会成为一名不公正的思考者。我们常常自私、狭窄地学习和应用思维技能。本章中通过介绍<strong>公正性</strong>的含义以及<strong>公正性思维的特质</strong>。</p><h1 id="批判性思维的强弱"><a href="#批判性思维的强弱" class="headerlink" title="批判性思维的强弱"></a>批判性思维的强弱</h1><p>从公正性的角度出发，批判性思维会走向两个方向：<strong>自我中心</strong>或<strong>公正</strong>。大多时候，我们为了自身利益，很容易自发地走向自我为中心的角度去思考问题，而需要通过刻意练习才能具备公正的思考方式。如果我们掌握了这种公正性，我们就能避免利用思维技能来服务自身的利益；我们就能以同样的标准对待所有的观点；我们会希望自己和对手都能合理地推理；我们就能对对手和自己采用同样的推理评判标准；我们就能像质疑他人一样质疑反思自己的目的、证据、结论、意义和观点。</p><p>对于公正批判性思考者所包含的思维特质如下图所示：<br><img src="/2019/05/26/《批判性思维工具-Critical-Thinking-》-读书笔记-二-成为公正的思考者/批判性思考者需要努力培养必要的思维特征和品质.png" title="批判性思考者需要努力培养必要的思维特征和品质"></p><p>相反地，自我为中心判性思考者所包含的如下思维特质中的一项或多项：<br><img src="/2019/05/26/《批判性思维工具-Critical-Thinking-》-读书笔记-二-成为公正的思考者/自我为中心的思维品质.png" title="自我为中心的思维品质"></p><h1 id="公正性需要什么"><a href="#公正性需要什么" class="headerlink" title="公正性需要什么"></a>公正性需要什么</h1><p>公正性要求我们努力平等地对待每一种观点。这需要我们认识到我们常常对他人的观点抱有偏见，我们常常会给他人的观点贴上“喜欢”（赞成我们观点的）和“不喜欢”（不赞成我们观点的）两类标签。公正性需要我们没有偏见地对待所有相关的观点，排除个人、亲友、集体和国家的感受和利益的影响。它要求坚持良好的思维标准（如准确性、逻辑清晰、广度等），不受个人和团体利益的影响。</p><p>公正性的反面就是思维的不公。思维不公指的是推卸准确、清晰地表达相左意见的责任。当我们不公地思考的时候，我们总是认为自己是正确的、公正的。因为我们天生都是以自我为中心的，所以我们都会落入不公正的思维陷阱。完全公正的思维状态是我们永远也达不到的理想状态。公正性要求我们同时拥有思维的谦逊、勇气、换位思考、正直性、坚毅、自主性和对推理的信心（用好的推理说服自己）特质。</p><h2 id="思维谦逊：努力发现自己对未知知识忽视的程度"><a href="#思维谦逊：努力发现自己对未知知识忽视的程度" class="headerlink" title="思维谦逊：努力发现自己对未知知识忽视的程度"></a>思维谦逊：努力发现自己对未知知识忽视的程度</h2><blockquote><p>思维谦逊就是要认识到<strong>自己对未知知识的忽视程度</strong>。因此，思维谦逊要求个体清晰地认识到自我中心导致的自欺行为（认为自己比自己实际知道的要多）。这意味着个体要对自己的偏见和观点的局限性有所了解。它要求我们清晰地认识到自己有哪些信息是不知道的，特别是事件能够引起个体强烈情感的时候，更要知道对该事件自己有哪些不清楚的地方。思维谦逊要求我们<strong>不能宣称自己知道我们实际上并不知道的事情</strong>。思维谦虚并不是懦弱、服从，而是摒弃自负。思维谦逊要求我们觉察并且评估自己信念的基础，要求我们找出那些不能被正确的推理所支持的信念。</p></blockquote><p>与思维谦逊相反的就是思维自负，即认为自己知道了实际并不知道的事情。思维自负的人缺乏对自欺行为和观点局限性的认识，他们常常声称了解自己其实并不了解的事情。思维自负的人常常也会成为自己偏见的受害者。当我们谈论思维自负时，并不一定就是指那些外表上看起来自以为是、高傲自大的人。这些思维自负的人外在表现很可能是十分谦虚的。</p><p>思维的自负和公正是不兼容的，因为如果我们对自己判断的事情过分自信，我们就很难做出公正的判断。思维谦逊对于成为公正的批判性思维者十分重要。要成为公正的思考者，就要了解自己缺乏哪些知识，这种了解可以让我们从多方面提高我们的思维。它可以让我们认识到偏见、错误信念和不良思维习惯能够导致学习缺陷。</p><h2 id="思维的勇气：培养自己敢于挑战大众信念的勇气"><a href="#思维的勇气：培养自己敢于挑战大众信念的勇气" class="headerlink" title="思维的勇气：培养自己敢于挑战大众信念的勇气"></a>思维的勇气：培养自己敢于挑战大众信念的勇气</h2><blockquote><p><strong>具有思维勇气就意味着个体能够公正地面对各种意见、信念和观点，即使这会让你感到痛苦</strong>。它可以让你准确公平地评判与你意见相左的信念。思维的勇气一个重要的作用，就是可以帮助你判断在社会大众普遍接受的观点中，哪些是合理的，哪些仅仅是主观喜好的结果。具有思维勇气的人知道有时候社会传输给我们的结论和信念也是错误的。<br>为了确定信息的准确性，一个人不能只是被动地、不加批判地接受所有东西。要具有思维勇气，要了解那些被社会认为是危险和荒谬的观点常常包含着一些真理，而群体普遍认同的观点也可能包含错误。要做到公正地思考，我们必须培养思维的勇气，必须不畏惧不遵从大众观点可能受到的社会严厉惩罚。</p></blockquote><p>与思维的勇气相对的是思维的懦弱，是害怕自己与他人观点不同。如果缺乏思维勇气，我们就不敢对那些我们认为是危险荒谬的意见、信念和观点进行认真思考。如果缺乏思维勇气，当我们面对强烈冲突观点的时候，我们会感到威胁，不愿意去检查审视自己的思维，也就很难做到思维的公正性。</p><p>思维勇气重要的另一个原因，是它能够有力地帮助我们应对他人的反驳。他人有对我们提出质疑的权利，他们持有特定的信念，当我们挑战他们的信念时，他们可能会做出反驳。<strong>很多人通过别人的观点来判断自己，从他人的称赞中来认同自己</strong>。这些人的思想背后隐藏着对被反驳的恐惧，很少有人会去挑战自己所属群体的意识形态和信念系统，这是思维懦弱的第二种形式。这两种形式都使我们不能公正地考虑自己和他人的观点。</p><p><strong>我们不应该以自己的个人信念来定义自己，界定自己最好的方法是根据形成信念的过程来做出关于自己的定义</strong>。这就是我们所谓的批判性思考者。思考下面的解决办法。</p><blockquote><p>我不会认同任何信念的内容。我只认同自己形成信念的过程。我是一个批判性思考者，我愿意检验我的信念，并且愿意放弃那些不能被证据和理性思考支持的信念。我会时刻跟随证据和推理的脚步。我的真实身份是一个批判性思考者、一个终生的学习者、一个通过建立更加合理的信念不停寻求提高自己思考水平的人。</p></blockquote><p>当我们不再将我们自己的身份和信念联系起来的时候，我们的思维就会更有勇气、更加公正。我们不会再为有相斥的信念而感到恐惧，不会再为自己的信念被证明是错误的而感到恐惧。我们可以轻松地承认自己曾经犯过的错误，并乐意去纠正自己：“告诉我你的信念、理由，或许我可以从你的信念中进行学习。我会随时准备放弃那些与事实不相符的信念。”</p><h2 id="思维换位思考：从他人的角度学习理解相反的观点"><a href="#思维换位思考：从他人的角度学习理解相反的观点" class="headerlink" title="思维换位思考：从他人的角度学习理解相反的观点"></a>思维换位思考：从他人的角度学习理解相反的观点</h2><blockquote><p><strong>思维的换位思考就是站在他人的角度思考问题，从而真正地理解他人的观点</strong>。这要求我们准确地再现他人的观点和推理，从他人的前提、假设和观点进行推理。这一特质要求个体积极回忆自己坚持错误的情况，也要求个体有能力辨别在当前情况下也可能会犯类似的错误。</p></blockquote><p>与思维换位思考相对的是<strong>思维的自我中心性</strong>，即以自我为中心来进行思考。当我们从自我中心的角度进行思考的时候，我们就不能理解他人的思想、感受和情感。很不幸，<strong>自我中心倾向是我们思维的自然本性</strong>，我们大部分的注意力都集中在自己身上。我们的痛苦、需要和希望都是最重要的，他人的需要无关紧要。我们不会主动地从反对者的角度考虑问题，也不会主动从那些可能改变我们自己观点的角度思考问题。</p><p>不能够理解他人的观点，又如何能够公正地对待他人呢？<strong>公正的思维需要努力置身于他人（或其他有知觉的动物）情景，思考他人观点</strong>。这需要我们尊重那些孕育出不同观点的背景和环境。人类思维的方式源于人们生活情景，源于不同的背景和情况。如果我们不能从他人的角度出发准确地理解他人的观点，我们就不能公正地评判他们的观点和信念。但是，从他人的观点思考问题不是一件容易的事，这是一项很难获得的技能。</p><p>为了培养思维换位思考的技能，请练习下面的策略：</p><ul><li>在不同意某人观点的时候，换位思考。告诉对方，“接下来10分钟我将从你的观点出发与你谈话，如果你也能从我的观点出发进行谈话。这种方法可以使我们更好地了解对方。”确保你能够准确地表达对方的观点。</li><li>在讨论的过程中，用下面的句子总结对方的谈话：“你是不是想说<strong>_</strong>。对吗？”</li><li>阅读的时候，告诉自己你认为作者想要说什么。这样可以使你能够正确地理解他人的观点，从他人的观点思考问题。只有这样你才有资格来评论他人的观点。</li></ul><h2 id="思维正直：用同样的标准评判他人和自己"><a href="#思维正直：用同样的标准评判他人和自己" class="headerlink" title="思维正直：用同样的标准评判他人和自己"></a>思维正直：用同样的标准评判他人和自己</h2><blockquote><p><strong>思维正直是指尊重严谨的思维，用同样的标准要求自己和他人</strong>。</p></blockquote><p>思维正直的反面就是思维虚伪，是指一种不诚实、自相矛盾的思维状态。因为思维的天性是自我中心的，是虚伪的，它会为我们不合理的思维和行为进行辩解，使之合理化。自我内部需要塑造一个积极的形象，对于自我中心思想来说，诚实的表象是很重要的。因此，我们常常将虚伪隐藏起来，即使我们要求他人的标准更加严格，我们也认为自己是公正的。即使我们声称遵守某些信念，但却常常言行不一。</p><p><strong>当思想和行为一致的时候，我们就是思维正直的</strong>。我们做到了我们承诺的，没有表面说一套实际上却做另一套。</p><p>很明显，如果我们用不一致的标准去评判自己和他人的思维，我们就无法公正地对待他人，虚伪的实质是不公。如果我们不能认识到自己思想和行为之间的不一致性，我们就不能对自己的道德问题进行合理的推理，就会为了自身的利益歪曲其他的观点。</p><h2 id="思维坚毅：不轻易地放弃；战胜挫折和困难"><a href="#思维坚毅：不轻易地放弃；战胜挫折和困难" class="headerlink" title="思维坚毅：不轻易地放弃；战胜挫折和困难"></a>思维坚毅：不轻易地放弃；战胜挫折和困难</h2><blockquote><p><strong>思维坚毅指的是战胜挫折、完成复杂任务的品格</strong>。有些困难十分复杂，不容易解决。但思维坚毅的人面对复杂任务和挫折时不会放弃，他们清楚认真地对复杂问题进行推理比快速得出结论更加重要。思维坚毅要求严格遵守理性标准，而不是根据第一印象做出判断或是快速给出简单化的答案。它还要求对困惑和未解决的问题进行长时间努力的思考，并从中获得深刻的见解。</p></blockquote><p>与思维坚毅相反的是思维的懒惰，思维懒惰的人在应对具有挑战性任务的时候很容易放弃，他们对复杂思维活动带来的痛苦和沮丧容忍度较低。</p><p>高水平的思维活动需要思维坚毅，因为高水平的思维活动都包含一定的思维挑战。没有思维坚毅性，就无法克服这些挑战。数学、化学、物理、文学、艺术及其他任何领域的高质量推理都需要思维的坚毅。</p><p>缺乏思维的坚毅是如何影响思考公正的呢？<strong>在理解他人的观点时，只要他们的观点与我们的不同或是本质上较复杂，都需要思维坚毅</strong>。如果我们不能理解他人的观点，考虑他人使用的信息，理解并分析他人对这些信息的解释、他人的信念，那么我们就不能了解他们的目的以及他们看待世界的观点，就不能公正地对待他们的观点。</p><h2 id="对推理的信心：重视证据和推理，将之视为发现真相的重要工具"><a href="#对推理的信心：重视证据和推理，将之视为发现真相的重要工具" class="headerlink" title="对推理的信心：重视证据和推理，将之视为发现真相的重要工具"></a>对推理的信心：重视证据和推理，将之视为发现真相的重要工具</h2><blockquote><p><strong>对推理的信心是建立在两种信念基础上的，第一种信念就是给人们提供自由推理的环境、鼓励人们靠自己的推理能力得出结论会满足人们高层次的需要。这种信心同时也建立在第二种信念基础上，这种信念就是人们可以学会自己思考；形成有价值的观点；得出合理的结论；清晰、准确、相关、有逻辑地思考；借助良好的推理和明确的证据来说服彼此；并且排除那些人类本性和社会生活中障碍的影响，成为理性的人</strong>。当一个人有了对推理的信心时，他就会按照合理的推理行动。合乎理性这一观点就成为人们一生最有价值的东西。简单来讲，<strong>对推理的信心就是将正确的推理作为接受或拒绝某一观点和立场的基本标准</strong>。</p></blockquote><p>与推理信心相反的是对推理的怀疑。不严谨的思考者会感到合理推理带来的威胁。人在本性上是不擅长分析自己观点，而又对自己的观点坚信不疑的。我们对自己的观点分析得越多，我们就会发现自己观点中存在越多的问题，就会更少地去坚持未经分析过的观点。没有对推理的信心，人们自然地会坚定地相信自己的观点，不管这些观点有多么荒唐。</p><p>对推理的信心和思维公正之间具有直接的联系。一个思维公正的人不可能对推理的重要性置之不理。如果我宣称能够做到思维公正，而我却不考虑与我观点相左的合理推理，这就是一个缺乏对推理的信心、思维不公正的例子。思维公正要求我们考虑以前从未考虑过的推理、考虑合理推理，要求我们根据更合逻辑、更准确、更公正地推理调整自己的观点，而做到这些的前提是对推理拥有信心，当能够进行合理的推理时，我们就能更好地思考。</p><h2 id="思维自主：重视思考的独立性"><a href="#思维自主：重视思考的独立性" class="headerlink" title="思维自主：重视思考的独立性"></a>思维自主：重视思考的独立性</h2><blockquote><p><strong>思维自主意味着坚持用合理的标准进行思考</strong>。这意味着自己要对事物进行思考而不是不加判断地接受别人的观点。思维自主的思考者在决定接受或者拒绝某观点的时候不依赖于他人。只有证据证明他人的观点是合理的时候，他们才会接受他人的观点。</p></blockquote><p>在形成观点的过程中，批判性思考者不是被动地接受他人的观点，而是自己积极主动地对环境和事件进行思考。当然，对于思维自主的理解不能局限在其这一特质本身，我们应该将它理解为与思维其他特质互相联系、互相影响的一个维度。</p><p>与思维自主性相反的是思维遵从和思维依赖。思维自主是很难培养的，是因为无论是在知识领域、政治领域还是经济领域，在很大程度上，人们总是被动地接受社会现实，自主性思考几乎肯定不会得到社会权威认可的结论，只有简单地遵从社会期望的思维和行为模式才能被社会接受。</p><p>因此，<strong>大多数人在思维和行为上都是因循守旧的，像镜子一样接受周围人的价值和信念系统，缺少自己独立思考的能力和动力，成为思维遵从的思考者</strong>。只要人们不加批判地接受他人的文化价值观，只要人们没有经过自己分析就遵从别人的信念，人们的思维就不是自由的。</p><p>人们不可能在思维遵从的情况下做到思考公正，因为独立思考是多角度看待问题的前提条件。当我们思维遵从的时候，<strong>我们仅仅能在“接受”的观点中进行思考</strong>；而要做到思考公正就是要拒绝不加判断的接受，没有亲自对这些观点的优缺点进行思考就不能接受这些观点。没有思维自主性的人在思考其他观点时，要么是非常容易被这些观点动摇（因为我们没有能够看穿操纵与宣教），要么会歪曲这些观点（因为这些观点与我们从前形成的信念系统不一致）。</p><h1 id="认识思维特质之间的相互关联性"><a href="#认识思维特质之间的相互关联性" class="headerlink" title="认识思维特质之间的相互关联性"></a>认识思维特质之间的相互关联性</h1><p>批判性思维所有必要的思维特质是相互关联的。思考一下思维谦逊：为了能够意识到自己知识的局限性，我们需要思维勇气来面对我们自己的偏见和无知。为了能够发现我们的偏见，我们常常需要注重那些反对观点并进行合理推理。为了达到这些目的，我们必须要有思维的坚毅性，因为学着理解我们的偏见需要时间和努力。除非我们有对推理的信心来相信我们不会犯错误，不会被相反观点所误导，否则这种努力不会显得公正。</p><p>此外，虽然思考其他观点不会损害我们的利益，但是这并不足以激发我们去仔细思考这些观点。我们必须做到思维公正，必须认识到公正地对待反对观点的责任，必须倾听那些反对观点来确保我们没有忽视和偏见。而要做到这一点，我们又回到了最初的出发点：思维谦逊。</p><p>下表总结了惯常思维和批判性思维的区别：<br><img src="/2019/05/26/《批判性思维工具-Critical-Thinking-》-读书笔记-二-成为公正的思考者/惯常思维和批判性思维的区别.png" title="惯常思维和批判性思维的区别"></p><p>下表总结了培养优秀的思维特征需要经常问自己的问题：<br><img src="/2019/05/26/《批判性思维工具-Critical-Thinking-》-读书笔记-二-成为公正的思考者/培养优秀的思维特征需要经常问自己的问题.png" title="培养优秀的思维特征需要经常问自己的问题"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong>真正杰出的思考者并不是孤立思维特质的产物</strong>。没有这些优秀思维特质的人，会不可避免地犯错而自己却时常觉察不到。这些人的思维特质是不严谨的，当他们无意识地去相信自己想要相信的观点、相信那些可以令自己舒服的观点、相信那些可以符合自身利益的观点、相信那些满足自己自私需求的观点时，这些人就不是一个理性的批判性思考者了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;入职前公司指定几本必读书籍帮助我们从学生到职场的转身，积累基础的知识储备，扩宽视野。《批判性思维工具(Critical Thinking)》在必读书籍之首，以下是我的读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://JacobLei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="批判性思维工具(Critical Thinking)》" scheme="http://JacobLei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B/"/>
    
    
      <category term="批判性思维工具(Critical Thinking)》" scheme="http://JacobLei.github.io/tags/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B/"/>
    
      <category term="读书笔记" scheme="http://JacobLei.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《批判性思维工具(Critical Thinking)》-读书笔记(一)</title>
    <link href="http://JacobLei.github.io/2019/05/26/%E3%80%8A%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <id>http://JacobLei.github.io/2019/05/26/《批判性思维工具-Critical-Thinking-》-读书笔记-一/</id>
    <published>2019-05-26T05:48:33.000Z</published>
    <updated>2019-05-26T07:17:36.344Z</updated>
    
    <content type="html"><![CDATA[<p>入职前公司指定几本必读书籍帮助我们从学生到职场的转身，积累基础的知识储备，扩宽视野。《批判性思维工具(Critical Thinking)》在必读书籍之首，以下是我的读书笔记。</p><a id="more"></a><p>在本书的前言中描述道：<strong>思维方式决定着行为方式。思维决定行为，感受和需求。</strong>这就是说不同的思维方式会导致不同的行为、感受和需求，这一点我相信大多数人都会产生共鸣。对于同一件事不同的个体（人）会有不同的思维方式，从而对该事情会有不同的认知，而该事情的结果反作用于个体，产生了不同的影响，最终导致个体的差异越来越明显。如一个人的思维方式过于悲观，他则会错失生活中很多快乐的事情，而生活大部分处于悲观的状态，也会影响他的思维方式处于越来越悲观。<br>而<strong>大多数人的思维方式都是潜意识的</strong>，大部分悲观的人不会承认自己是悲观的思维一样，他们也不会承认他们自己用一种消极悲观的方式来思考自我和总结自我。<br>该书主要讲解如何突破个体的固有思维，去通过练习学习那些幸福、成功人士的思维方式，通过阅读和实践本书，将会成为一个掌握自己命运的批判性思考者，但<strong>最终决定个体的思维方式是否能够改善的方式还是个体本身提高的意愿</strong>。<br>接着该书总结了一些成功思考者的特性：</p><ul><li><strong>优秀的思考者总是在思考他们的思维过程</strong>。优秀的思考者认为思维并不是自动的。他们不认为优秀的思维方式是天生的，他们关注自己的思维过程，不断地对其进行反省和调整。</li><li><strong>优秀的思考者都会有明确的目标</strong>。优秀的思考者从不盲目，他们知道自己的目标所在。他们清楚自己想要什么，拥有明确的目标并知道这些目标之间的优先顺序。他们不断地检查和调整自己的行动使其服从于目标。</li><li><strong>优秀的思考者使用一些思维“工具”来提升他们思维的质量</strong>。优秀的思考者知道如何清晰地表述自己的思维方式、如何检查思维方式的准确性和精确性。他们知道如何专注于目的相关的问题上。优秀的思考者知道如何全方位深度地看待问题，使思维方式更加具有逻辑性。</li><li><strong>优秀的思考者能够将他们的思维与感受、需求相分离</strong>。优秀的思考者清楚想法自身不能转化为现实，他们知道人们会不理性地感到愤怒、害怕或者缺乏安全感，但他们不会允许无端的情感左右他们的决策。他们能洞察自己的心思，这使得他们可以审查自己思维运作的过程，从而可以仔细地控制思维过程。</li><li><strong>优秀的思考者常常分解、剖析事情</strong>。优秀的思考者常常“分析”他们的思维方式。他们不相信心智可以自动对思维方式进行分析。我们必须有意识地学习分析思维方式这个方法。</li><li><strong>优秀的思考者经常评估自己的思维方式——找出他们思维方式的优缺点</strong>。优秀的思考者不相信心智会对自己自动地进行评估。他们认识到心智对自己的评估方法有天生的缺陷。</li></ul><p>这本书作为一个整体，展示了对生活中的问题和困难进行正确思考的思维方法和技巧，帮助我们解决学习中、生活中和职业道路上遇到的困难。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;入职前公司指定几本必读书籍帮助我们从学生到职场的转身，积累基础的知识储备，扩宽视野。《批判性思维工具(Critical Thinking)》在必读书籍之首，以下是我的读书笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://JacobLei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="批判性思维工具(Critical Thinking)》" scheme="http://JacobLei.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B/"/>
    
    
      <category term="批判性思维工具(Critical Thinking)》" scheme="http://JacobLei.github.io/tags/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7-Critical-Thinking-%E3%80%8B/"/>
    
      <category term="读书笔记" scheme="http://JacobLei.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-14 最长公共前缀</title>
    <link href="http://JacobLei.github.io/2019/05/26/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://JacobLei.github.io/2019/05/26/LeetCode-14-最长公共前缀/</id>
    <published>2019-05-26T04:18:39.000Z</published>
    <updated>2019-05-28T12:49:07.223Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：14. 最长公共前缀</li><li>难度：简单</li><li>分类：字符串</li><li>解决方案：字符串遍历<a id="more"></a></li></ul><p>今天我们学习第14题<strong>最长公共前缀</strong>，这是一道简单题。像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">题目描述</a></h1><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串<code>&quot;&quot;</code>。<br>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题目让我们求字符串数组中的最长公共前缀，我们可以使用第0行的字符串作为基准，与其他剩余的字符串比较来找出最长的公共前缀，示例1分析方法如下图所示：<br><img src="/2019/05/26/LeetCode-14-最长公共前缀/暴力求解示意图分析.png" title="暴力求解示意图分析"></p><p>将上述分析方法转化为<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span>  res.toString();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; strs[<span class="number">0</span>].length(); col++)&#123;</span><br><span class="line">            <span class="comment">// 第0行的第col个字符</span></span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(col); </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 基准字符串中的字符与其他字符串中的字符进行对比</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; strs.length; row++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(col &gt;= strs[row].length() || strs[row].charAt(col) != c)</span><br><span class="line">                    <span class="keyword">return</span>  res.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/26/LeetCode-14-最长公共前缀/暴力求解提交结果.png" title="暴力求解提交结果"><p>仔细想想，如果字符串数组按照字符顺序排好序后（可以使用相关语言的排序函数进行排序，排好序后数组中共同字母多的字符串会被放到一起，而共同字符最少的字符串则会被放到首尾两端），我们不需要比较所有的字符串，而只需要比较首字符串和尾字符串即可，用这种排序方法对示例1分析的示意图如所下图所示：<br><img src="/2019/05/26/LeetCode-14-最长公共前缀/排序示意图分析.png" title="排序示意图分析"></p><p>将上述分析方法转化为<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span>  res.toString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将字符串数组排序</span></span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 取数组中的首尾字符串，并将其转为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] firstRow = strs[<span class="number">0</span>].toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] lastRow = strs[strs.length-<span class="number">1</span>].toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找公共前缀时只需要查找最短长度的字符串</span></span><br><span class="line">        <span class="keyword">int</span> len = firstRow.length &lt; lastRow.length ? firstRow.length : lastRow.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较首位两个字符串，取最长公共前缀</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(firstRow[i] != lastRow[i])</span><br><span class="line">                <span class="keyword">return</span> res.toString();</span><br><span class="line">            res.append(firstRow[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/26/LeetCode-14-最长公共前缀/字符串数组排序后提交结果.png" title="字符串数组排序后提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A14_LongestCommonPrefix.java" target="_blank" rel="noopener">LeetCode-14 最长公共前缀</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">14.最长公共前缀</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：14. 最长公共前缀&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：字符串遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="字符串" scheme="http://JacobLei.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-13 罗马数字转整数</title>
    <link href="http://JacobLei.github.io/2019/05/26/LeetCode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>http://JacobLei.github.io/2019/05/26/LeetCode-13-罗马数字转整数/</id>
    <published>2019-05-26T02:27:15.000Z</published>
    <updated>2019-05-26T03:39:58.882Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：13. 罗马数字转整数</li><li>难度：简单</li><li>分类：字符串、数学</li><li>解决方案：字符串遍历<a id="more"></a></li></ul><p>今天我们学习第13题<strong>罗马数字转整数</strong>，这是一道简单题，这是我们昨天学习的<a href="https://www.jacob2359.com/2019/05/25/LeetCode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/#more" target="_blank" rel="noopener">eetCode-12 整数转罗马数字</a>的逆过程。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">题目描述</a></h1><p>罗马数字包含以下七种字符：<code>I</code>，<code>V</code>，<code>X</code>， <code>L</code>，<code>C</code>，<code>D</code>和<code>M</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>例如，罗马数字<code>2</code>写做<code>II</code>，即为两个并列的<code>1</code>。<code>12</code>写做<code>XII</code>，即为<code>X + II</code>。<code>27</code> 写做<code>XXVII</code>, 即为<code>XX + V + II</code>。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如<code>4</code>不写做 <code>IIII</code>，而是<code>IV</code>。数字<code>1</code>在数字<code>5</code>的左边，所表示的数等于大数<code>5</code>减小数<code>1</code> 得到的数值<code>4</code>。同样地，数字<code>9</code>表示为<code>IX</code>。这个特殊的规则只适用于以下六种情况:</p><ul><li><code>I</code> 可以放在 <code>V (5)</code> 和 <code>X (10)</code> 的左边，来表示 <code>4</code> 和 <code>9</code>。</li><li><code>X</code> 可以放在 <code>L (50)</code> 和 <code>C (100)</code> 的左边，来表示 <code>40</code> 和 <code>90</code>。 </li><li><code>C</code> 可以放在 <code>D (500)</code> 和 <code>M (1000)</code> 的左边，来表示 <code>400</code> 和 <code>900</code>。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>题目要求我们将一个罗马数转为整数数，并给出了罗马数与整数的对应规则，如下图所示。</p><img src="/2019/05/26/LeetCode-13-罗马数字转整数/罗马数与整数的对应规则.png" title="罗马数与整数的对应规则"><p>根据题目可以归纳出罗马数的基本组成规则：</p><ul><li>相同的数字连写，所表示的数等于这些数字相加得到的数，如：<code>II=2</code></li><li>小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数， 如：<code>XII=12</code></li><li>小的数字，（限于<code>Ⅰ</code>、<code>X</code> 和<code>C</code>)在大的数字的左边，所表示的数等于大数减小数得到的数，如：<code>Ⅳ= 4</code></li></ul><p>根据上面规则可以知道，对于一个给定的罗马数来说，我们可以从左到右遍历这个字符串并统计<code>I</code>，<code>V</code>，<code>X</code>， <code>L</code>，<code>C</code>，<code>D</code>和<code>M</code>这七个字符出现的次数。统计时需要注意：</p><ul><li>对于<code>I</code>字符如果后面为<code>V</code>或者<code>X</code>则<code>I</code>出现的次数减一，否则<code>I</code>字符出现次数加一；</li><li>对于<code>X</code>字符如果后面为<code>L</code>或者<code>C</code>则<code>X</code>出现的次数减一，否则<code>X</code>字符出现次数加一；</li><li>对于<code>C</code>字符如果后面为<code>D</code>或者<code>M</code>则<code>C</code>出现的次数减一，否则<code>C</code>字符出现次数加一；</li><li>对于剩余的字符，出现一次则加一。</li></ul><p>对示例5进行详细分析，过程如下图所示：<br><img src="/2019/05/26/LeetCode-13-罗马数字转整数/示例5详细过程.png" title="示例5详细过程"></p><p><code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化七种字符出现的次数为0</span></span><br><span class="line">        <span class="keyword">int</span> I = <span class="number">0</span>, V = <span class="number">0</span>, X = <span class="number">0</span>, L = <span class="number">0</span>, C = <span class="number">0</span>, D = <span class="number">0</span>, M = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历字符串，统计每种字符串出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'I'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;s.length() &amp;&amp; (s.charAt(i+<span class="number">1</span>) == <span class="string">'V'</span> || s.charAt(i+<span class="number">1</span>) == <span class="string">'X'</span>))</span><br><span class="line">                    I--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    I++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'V'</span>)&#123;</span><br><span class="line">                V++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'X'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;s.length() &amp;&amp; (s.charAt(i+<span class="number">1</span>) == <span class="string">'L'</span> || s.charAt(i+<span class="number">1</span>) == <span class="string">'C'</span>))</span><br><span class="line">                    X--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    X++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'L'</span>)&#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'C'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;s.length() &amp;&amp; (s.charAt(i+<span class="number">1</span>) == <span class="string">'D'</span> || s.charAt(i+<span class="number">1</span>) == <span class="string">'M'</span>))</span><br><span class="line">                    C--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    C++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'D'</span>)&#123;</span><br><span class="line">                D++;   </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'M'</span>)&#123;</span><br><span class="line">                M++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> I + V*<span class="number">5</span> + X*<span class="number">10</span> + L*<span class="number">50</span> + C*<span class="number">100</span> + D*<span class="number">500</span> + M*<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/26/LeetCode-13-罗马数字转整数/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A13_RomantoInteger.java" target="_blank" rel="noopener">LeetCode-13 罗马数字转整数</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13.罗马数字转整数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：13. 罗马数字转整数&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：字符串、数学&lt;/li&gt;
&lt;li&gt;解决方案：字符串遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数学" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="字符串" scheme="http://JacobLei.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-12 整数转罗马数字</title>
    <link href="http://JacobLei.github.io/2019/05/25/LeetCode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://JacobLei.github.io/2019/05/25/LeetCode-12-整数转罗马数字/</id>
    <published>2019-05-25T02:08:54.000Z</published>
    <updated>2019-05-26T03:33:03.437Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：12. 整数转罗马数字</li><li>难度：中等</li><li>分类：数学、字符串</li><li>解决方案：整数比较<a id="more"></a></li></ul><p>今天我们学习第12题<strong>整数转罗马数字</strong>，这是一道中等题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">题目描述</a></h1><p>罗马数字包含以下七种字符：<code>I</code>，<code>V</code>，<code>X</code>， <code>L</code>，<code>C</code>，<code>D</code>和<code>M</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure></p><p>例如，罗马数字<code>2</code>写做<code>II</code>，即为两个并列的<code>1</code>。<code>12</code>写做<code>XII</code>，即为<code>X + II</code>。<code>27</code> 写做<code>XXVII</code>, 即为<code>XX + V + II</code>。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如<code>4</code>不写做 <code>IIII</code>，而是<code>IV</code>。数字<code>1</code>在数字<code>5</code>的左边，所表示的数等于大数<code>5</code>减小数<code>1</code> 得到的数值<code>4</code>。同样地，数字<code>9</code>表示为<code>IX</code>。这个特殊的规则只适用于以下六种情况:</p><ul><li><code>I</code> 可以放在 <code>V (5)</code> 和 <code>X (10)</code> 的左边，来表示 <code>4</code> 和 <code>9</code>。</li><li><code>X</code> 可以放在 <code>L (50)</code> 和 <code>C (100)</code> 的左边，来表示 <code>40</code> 和 <code>90</code>。 </li><li><code>C</code> 可以放在 <code>D (500)</code> 和 <code>M (1000)</code> 的左边，来表示 <code>400</code> 和 <code>900</code>。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure></p><p>示例 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure></p><p>示例 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>题目要求我们将一个整数转为罗马数，并给出了罗马数与整数的对应规则，如下图所示。</p><img src="/2019/05/25/LeetCode-12-整数转罗马数字/罗马数与整数的对应规则.png" title="罗马数与整数的对应规则"><p>根据题目可以归纳出罗马数的基本组成规则：</p><ul><li>相同的数字连写，所表示的数等于这些数字相加得到的数，如：<code>II=2</code></li><li>小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数， 如：<code>XII=12</code></li><li>小的数字，（限于<code>Ⅰ</code>、<code>X</code> 和<code>C</code>)在大的数字的左边，所表示的数等于大数减小数得到的数，如：<code>Ⅳ= 4</code></li></ul><p>根据罗马数与整数的对应规则和题目中给出的六种特殊情况，我们将这些数从大到小排序，如下图所示：</p><img src="/2019/05/25/LeetCode-12-整数转罗马数字/罗马数与整数从大到小排序.png" title="罗马数与整数从大到小排序"><p>我们将这些数分为一个一个区间，当我们输入一个整数时，如输入58，我们判断该整数在哪一个区间中，如下图所示：</p><img src="/2019/05/25/LeetCode-12-整数转罗马数字/58所在区间.png" title="整数58所在区间"><p><code>58∈[50,90)</code>，因此最高位的罗马数取50所对应罗马数<code>L</code>。计算剩下的数，即58-50=8，继续判断该数属于哪一个区间，如下图所示：</p><img src="/2019/05/25/LeetCode-12-整数转罗马数字/8所在区间.png" title="整数8所在区间"><p><code>8∈[5,9)</code>，因此该位的罗马数取5所对应罗马数<code>V</code>。计算剩下的数，即8-5=3，继续判断该数属于哪一个区间，如下图所示：</p><img src="/2019/05/25/LeetCode-12-整数转罗马数字/3所在区间.png" title="整数3所在区间"><p><code>3∈[1,4)</code>，因此该位的罗马数取1所对应罗马数<code>I</code>。计算剩下的数，即3-1=2，继续判断该数属于哪一个区间，如下图所示：</p><img src="/2019/05/25/LeetCode-12-整数转罗马数字/3所在区间.png" title="整数2所在区间"><p><code>2∈[1,4)</code>，因此该位的罗马数取1所对应罗马数<code>I</code>。计算剩下的数，即2-1=1，继续判断该数属于哪一个区间，如下图所示：</p><img src="/2019/05/25/LeetCode-12-整数转罗马数字/3所在区间.png" title="整数1所在区间"><p><code>1∈[1,4)</code>，因此该位的罗马数取1所对应罗马数<code>I</code>。</p><p>综上分析，58所对应的罗马数为<code>LVIII</code>。</p><p>有了上面的分析过程，我们对整数转为罗马数的转换方式了如指掌，接下来就是用代码实现上面的分析过程。<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里使用StringBuilder保存转换后的罗马数， 注意：这里有一个java面试的考点：Java中String、StringBuilder以及StringBuffer的比较</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 用数组保存整数区间及其对应的罗马数区间</span></span><br><span class="line">        <span class="keyword">int</span>[] n = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String[] str = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 判断该整数属于哪一个区间</span></span><br><span class="line">            <span class="keyword">while</span>(num &gt;= n[i])&#123;</span><br><span class="line">                <span class="comment">// 找到区间数后，计算剩余数</span></span><br><span class="line">                num -= n[i];</span><br><span class="line">                <span class="comment">// 添加区间数对应的罗马数</span></span><br><span class="line">                res.append(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/25/LeetCode-12-整数转罗马数字/提交结果.png" title="提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A12_IntegertoRoman.java" target="_blank" rel="noopener">LeetCode-12 整数转罗马数字</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">12.整数转罗马数字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：12. 整数转罗马数字&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数学、字符串&lt;/li&gt;
&lt;li&gt;解决方案：整数比较
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数学" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="字符串" scheme="http://JacobLei.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-11 盛最多水的容器</title>
    <link href="http://JacobLei.github.io/2019/05/24/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://JacobLei.github.io/2019/05/24/LeetCode-11-盛最多水的容器/</id>
    <published>2019-05-24T08:34:27.000Z</published>
    <updated>2019-05-24T10:31:49.770Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：11. 盛最多水的容器</li><li>难度：中等</li><li>分类：数组</li><li>解决方案：双指针<a id="more"></a></li></ul><p>今天我们学习第11题<strong>盛最多水的容器</strong>，这是一个数组的中等题，这个题目难度不大，记得在秋招面试中遇见过。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">题目描述</a></h1><p>给定<code>n</code>个非负整数<code>a1，a2，...，an</code>，每个数代表坐标中的一个点<code>(i, ai)</code>。在坐标内画<code>n</code>条垂直线，垂直线<code>i</code>的两个端点分别为<code>(i, ai)</code>和<code>(i, 0)</code>。找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且<code>n</code>的值至少为 2。</p><img src="/2019/05/24/LeetCode-11-盛最多水的容器/题目.jpg" title="题目示意图"><p>图中垂直线代表输入数组<code>[1,8,6,2,5,4,8,3,7]</code>。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>结合这个题目通过给出的示意图来理解比较容易，输入数组中的数据代表水池的高度，数组中数据之间距离表示水池的宽度，它们的乘积则为可以容纳的水（即面积）。我们可以使用双指针来解决此问题，左指针为数组起始位置，右指针为数组终止位置，然后计算此时左右指针包含的面积（注意，计算面积时的高度为左右指针指向的数据取较小的那一个），然后移动指针，移动规则为移动指针指向数据较小的指针（左指针向右移动，右指针向左移动）。当左右指针指向同一个数据时，则退出循环，最大的面积即为所求的值。<br><code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// res为所求面积，初始化为0， left为左指针， right为右指针</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>, right = height.length-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 保留最大面积</span></span><br><span class="line">            res = Math.max(res, Math.min(height[left], height[right]) * (right-left));</span><br><span class="line">            <span class="comment">// 比较左右指针指向的数据，移动较小数据的指针</span></span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;height[right])</span><br><span class="line">                ++left;    <span class="comment">// 左指针向右移动</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --right;    <span class="comment">// 右指针向左移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/24/LeetCode-11-盛最多水的容器/提交结果.png" title="图2.提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A11_ContainerWithMostWater.java" target="_blank" rel="noopener">LeetCode-11 盛最多水的容器</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11.字符串转换整数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：11. 盛最多水的容器&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：数组&lt;/li&gt;
&lt;li&gt;解决方案：双指针
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="数组" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="http://JacobLei.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-动态规划</title>
    <link href="http://JacobLei.github.io/2019/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://JacobLei.github.io/2019/05/23/数据结构与算法-动态规划/</id>
    <published>2019-05-23T07:25:59.000Z</published>
    <updated>2019-05-24T01:55:31.599Z</updated>
    
    <content type="html"><![CDATA[<p>本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。</p><a id="more"></a><h1 id="动态规划思想"><a href="#动态规划思想" class="headerlink" title="动态规划思想"></a>动态规划思想</h1><ul><li>将问题分解为多个阶段，每个阶段对应一个决策。记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合来推导下一个阶段的状态集合，动态地往前推进。</li><li>用空间换时间       </li></ul><h1 id="简单0-1背包问题"><a href="#简单0-1背包问题" class="headerlink" title="简单0-1背包问题"></a>简单0-1背包问题</h1><p>动态规划最经典问题：0-1背包问题，但是经典的0-1背包问题给每个物品赋予两种属性（重量、价值），往往初次看此问题时难度较大。为了便于理解，先从经典的0-1背包问题提取一种属性进行分析（重量），题目如下：<br><strong>简单0-1背包问题</strong>：已知n个物品，每种物品对应有一个重量<code>weight</code>，给定一个背包可以装入物品的最大重量为<code>maxWeight</code>，求满足最大重量限制的情况下，背包中物品总重量的最大值是多少？<br>首先通过一个例子来分析简单0-1背包问题。假设总共有5种物品，即<code>n=5</code>，每个物品的重量为<code>weights=[ 2，2，4，6，3]</code>，最大重量<code>maxWeight=9</code>。如下表所示，表中的行表示第几个物品，表中的列表示物品的重量，记为<code>curWeight</code>，由于背包的最大重量<code>maxWeight=9</code>，因此，该背包总共有0~9种重量的可能。</p><ul><li><p>初始状态如下表所示： </p><img src="/2019/05/23/数据结构与算法-动态规划/简单01背包问题初始状态.png" title="简单0-1背包问题初始状态"></li><li><p>当第0号物品决策完之后，即将0号物品不放入背包或将0号物品放入背包，如果不放入背包，即<code>curWeight=0</code>，如果放入背包，即<code>curWeight=2</code>，改变表中的对应状态：</p><img src="/2019/05/23/数据结构与算法-动态规划/简单01背包问题第0号物品决策后的状态.png" title="简单0-1背包问题第0号物品决策后的状态"></li><li><p>当第1号物品决策完之后，即将1号物品不放入背包或将1号物品放入背包，如果不放入背包，基于<code>n=0</code>时的状态集合，该背包中的重量有两种可能，即<code>curWeight=0</code>或<code>curWeight=2</code>，如果放入背包，基于<code>n=0</code>时的状态集合，该背包中的重量有两种可能，即<code>curWeight=2</code>或<code>curWight=4</code>，综上，1号物品决策完之后，背包中的重量总共有三种可能，即<code>curWeight=0</code>、<code>curWeight=2</code>或<code>curWight=4</code>。改变表中的对应状态：</p><img src="/2019/05/23/数据结构与算法-动态规划/简单01背包问题第1号物品决策后的状态.png" title="简单0-1背包问题第1号物品决策后的状态"></li><li><p>当第2号物品决策完之后，表中状态如下所示：</p><img src="/2019/05/23/数据结构与算法-动态规划/简单01背包问题第2号物品决策后的状态.png" title="简单0-1背包问题第2号物品决策后的状态"></li><li><p>当第3号物品决策完之后，表中状态如下所示：</p><img src="/2019/05/23/数据结构与算法-动态规划/简单01背包问题第3号物品决策后的状态.png" title="简单0-1背包问题第3号物品决策后的状态"></li><li><p>当第4号物品决策完之后，表中状态如下所示：</p><img src="/2019/05/23/数据结构与算法-动态规划/简单01背包问题第4号物品决策后的状态.png" title="简单0-1背包问题第4号物品决策后的状态"></li><li><p>根据上表可知，当前背包下物品总重量的最大值为9.</p></li></ul><p>通过上述分析，再看看将上述过程转化为<code>java</code>代码，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 背包中物品总重量的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> weight 每个物品的重量数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 物品的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxWight 背包可承受的最大重量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 背包中物品总重量的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxWeightInPackage</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span> n, <span class="keyword">int</span> maxWight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    Boolean[][] state = <span class="keyword">new</span> Boolean[n][maxWight+<span class="number">1</span>]; <span class="comment">// 先申请状态数组，即上面的表格的初始化状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对第0行进行特殊处理，手动标记</span></span><br><span class="line">    state[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;             <span class="comment">//  将第0号物品不放入背包</span></span><br><span class="line">    state[<span class="number">0</span>][weight[<span class="number">0</span>]] = <span class="keyword">true</span>;     <span class="comment">// 将第0号物品放入背包</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次对剩下的物品进行决策</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="comment">// 将第i号物品不放入背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=maxWight; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> ( state[i-<span class="number">1</span>][j] != <span class="keyword">null</span> &amp;&amp; state[i-<span class="number">1</span>][j] == <span class="keyword">true</span>)&#123;</span><br><span class="line">                state[i][j] = state[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将第i号物品放入背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;= (maxWight-weight[i]); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(state[i-<span class="number">1</span>][j] != <span class="keyword">null</span> &amp;&amp; state[i-<span class="number">1</span>][j] == <span class="keyword">true</span>)</span><br><span class="line">                state[i][j+weight[i]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在最后一行从后向前遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=maxWight; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(state[n-<span class="number">1</span>][i] != <span class="keyword">null</span> &amp;&amp; state[n-<span class="number">1</span>][i] == <span class="keyword">true</span>)&#123;</span><br><span class="line">            res = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述实例可知，对于每个物品都有两种决策方案，要么放入背包，要么不放入背包。将整个过程分解成n个部分，对于每个部分都有两种决策方案，当每个物品决策完之后（放入背包或不放入背包）背包中的重量有多种情况，也就是说达到多种不同的情况。把每一层重复的状态合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。当所有部分决策完之后，即可得到最终的状态集合，从状态集合中可以得到该背包中最大的重量。<br>实际上，这就是动态规划解决问题的基本思路。<strong>将问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的部分），然后通过当前的状态集合来推到下一阶段的状态集合，动态地往前推进。</strong><br>从上述代码可知，该问题的时间复杂度为<code>O(n*weight)</code>，其中<code>n</code>为物品的个数，<code>maxWeight</code>为背包可承载的最大重量，该问题的空间复杂度为<code>O(n*weight)</code>，其中<code>n</code>为物品的个数，<code>maxWeight</code>为背包可承载的最大重量</p><p>优化：事实上，只需要申请<code>weight+1</code>的一维数组即可解决这个问题。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxWeightInPackage2</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span> n, <span class="keyword">int</span> maxWight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    Boolean[] state = <span class="keyword">new</span> Boolean[maxWight+<span class="number">1</span>]; <span class="comment">// 先申请状态数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对第0行进行特殊处理，手动标记</span></span><br><span class="line">    state[<span class="number">0</span>] = <span class="keyword">true</span>;             <span class="comment">//  将第0号物品不放入背包</span></span><br><span class="line">    state[weight[<span class="number">0</span>]] = <span class="keyword">true</span>;     <span class="comment">// 将第0号物品放入背包</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次对剩下的物品进行决策</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=maxWight-weight[i]; j&gt;=<span class="number">0</span>; j--)&#123;  <span class="comment">// 把第i个物品放入背包中</span></span><br><span class="line">            <span class="keyword">if</span> (state[j] != <span class="keyword">null</span> &amp;&amp; state[j] == <span class="keyword">true</span>)</span><br><span class="line">                state[j+weight[i]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在最后一行从后向前遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=maxWight; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(state[i] != <span class="keyword">null</span> &amp;&amp; state[i] == <span class="keyword">true</span>)&#123;</span><br><span class="line">            res = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单0-1背包问题问题分析完成后，接下来将价值属性也添加进入，升级为高级0-1背包问题。</p><h1 id="2-高级0-1背包问题"><a href="#2-高级0-1背包问题" class="headerlink" title="2. 高级0-1背包问题"></a>2. 高级0-1背包问题</h1><p><strong>高级0-1背包问题</strong>：已知n个物品，每种物品对应有重量<code>weight</code>和价值<code>value</code>两个属性，给定一个背包可以装入物品的最大重量为<code>maxWeight</code>，求满足最大重量限制的情况下，背包中装入物品的总价值最大是多少？<br>实例：总共有5种物品，即<code>n=5</code>，每个物品的重量为<code>weights=[ 2，2，4，6，3]</code>，对应价值为<code>values=[3, 4, 8, 9, 6]</code>，最大重量<code>maxWeight=9</code>，求背包中可装如物品的总价值最大是多少？</p><pre><code>* 如下表所示，表中行表示的第几个物品，表中的列表示物品的重量，由于背包的最大重量maxWeight=9，因此，该背包总共有0~9种重量的可能，表中的数据项表示价值，记为curValue，初始状态下curValue=-1。初始状态如下表所示:{% asset_img 升级01背包问题初始状态.png 升级01背包问题初始状态 %}* 当第0号物品决策完之后，即不放入背包或放入背包，如果不放入背包，则在curWeight=0的列curValue=0，如果放入背包，即在curWeight=2的列curValue=3，改变表中的对应状态：{% asset_img 升级01背包问题第0号物品决策后的状态.png 升级01背包问题第0号物品决策后的状态 %}* 对于第1号物品：    * 将物品(curWeight=2, curValue=4)**不放入**背包时：根据n=0的状态集合可以得到n=1的状态集合，如下所示：    {% asset_img 升级01背包问题第1号物品不放入背包.png 升级01背包问题第1号物品不放入背包 %}    * 将物品(curWeight=2, curValue=4)**放入**背包时：根据n=0的状态集合可以得到n=1的状态集合，如下所示：    {% asset_img 升级01背包问题第1号物品放入背包.png 升级01背包问题第1号物品放入背包 %}    * 对于n=1时的第2列，选取当前状态的最大值为该列的状态值，即此时的4为n=1时的第2列的状态值。* 综上，对于1号物品决策完后，表中状态如下所示：{% asset_img 升级01背包问题第1号物品决策后的状态.png 升级01背包问题第1号物品决策后的状态 %}* 当第2号物品决策完之后，表中状态如下所示：{% asset_img 升级01背包问题第2号物品决策后的状态.png 升级01背包问题第2号物品决策后的状态 %}* 当第3号物品决策完之后，表中状态如下所示：{% asset_img 升级01背包问题第3号物品决策后的状态.png 升级01背包问题第3号物品决策后的状态 %}* 当第4号物品决策完之后，表中状态如下所示：{% asset_img 升级01背包问题第4号物品决策后的状态.png 升级01背包问题第4号物品决策后的状态 %}* 根据上表可知，当前背包中装入物品的总价值最大为18。</code></pre><p>将上述分析过程转化为<code>java</code>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  求背包中装入物品的的最大总价值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> weights 每个物品的重量数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values 每个物品的价值数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 物品的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxWeight 背包可承受的最大重量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 背包中物品的最大总价值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxWeightInpackage</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values, <span class="keyword">int</span> n, <span class="keyword">int</span> maxWeight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[][]  states = <span class="keyword">new</span> <span class="keyword">int</span>[n][maxWeight+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化states</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxWeight; j++) &#123;</span><br><span class="line">            states[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对第0行进行特殊处理，手动标记</span></span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;                   <span class="comment">//  将第0号物品不放入背包</span></span><br><span class="line">    states[<span class="number">0</span>][weights[<span class="number">0</span>]] = values[<span class="number">0</span>];    <span class="comment">//  将第0号物品放入背包</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次对剩下的物品进行决策</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 将第i号物品不放入背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxWeight; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] != -<span class="number">1</span>)&#123;</span><br><span class="line">                states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将第i号物品放入背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=(maxWeight-weights[i]) ; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] != -<span class="number">1</span>)&#123;</span><br><span class="line">                states[i][j+weights[i]] = Math.max((states[i-<span class="number">1</span>][j] + values[i]),(states[i][j+weights[i]]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出背包中的总价值最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxWeight; i++) &#123;</span><br><span class="line">        res = Math.max(res, states[n-<span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述代码可知，该问题的时间复杂度为<code>O(n*weight)</code>，其中<code>n</code>为物品的个数，<code>maxWeight</code>为背包可承载的最大重量，该问题的空间复杂度为<code>O(n*weight)</code>，其中<code>n</code>为物品的个数，<code>maxWeight</code>为背包可承载的最大重量<br>优化：事实上，只需要申请<code>weight+1</code>的一维数组即可解决这个问题。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  求背包中装入物品的的最大总价值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> weights 每个物品的重量数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values 每个物品的价值数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 物品的个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxWeight 背包可承受的最大重量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 背包中物品的最大总价值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxWeightInpackage2</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values, <span class="keyword">int</span> n, <span class="keyword">int</span> maxWeight)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] states = <span class="keyword">new</span> <span class="keyword">int</span>[maxWeight+<span class="number">1</span>];    <span class="comment">// 申请状态数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=maxWeight ; i++) &#123;  <span class="comment">// 初始化状态数组</span></span><br><span class="line">        states[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对第0行进行特殊处理，手动标记</span></span><br><span class="line">    states[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    states[weights[<span class="number">0</span>]] = values[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次对剩下的物品进行决策</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=maxWeight-weights[i]; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(states[j] != -<span class="number">1</span>)&#123;</span><br><span class="line">                states[j+weights[i]] = Math.max(states[j] + values[i], states[j+weights[i]]);   <span class="comment">// 更新states[j+weights[i]]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在最后一行从后向前遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxWeight; i++) &#123;</span><br><span class="line">        res = Math.max(res, states[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过0-1背包问题初步了解了动态规划解决问题的过程后，我们接下来学习有关动态规划的理论知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://JacobLei.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-10 正则表达式匹配（未完成版）</title>
    <link href="http://JacobLei.github.io/2019/05/23/LeetCode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://JacobLei.github.io/2019/05/23/LeetCode-10-正则表达式匹配/</id>
    <published>2019-05-23T06:52:39.000Z</published>
    <updated>2019-05-24T08:36:39.770Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：10. 正则表达式匹配</li><li>难度：困难</li><li>分类：字符串</li><li>解决方案：动态规划<a id="more"></a></li></ul><p>今天我们学习第10题<strong>正则表达式匹配</strong>，这是一个字符串的困难题，确实比前面的几道字符的题目难度大很多，若是第一次没看懂千万不要放弃，多看几次，边理解边画图，静下心来一定可以解决的。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">题目描述</a></h1><p>给定一个字符串<code>s</code>和一个字符模式<code>p</code>。实现支持<code>.</code>和<code>*</code>的正则表达式匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos; 匹配任意单个字符。</span><br><span class="line">&apos;*&apos; 匹配零个或多个前面的元素。</span><br></pre></td></tr></table></figure></p><p>匹配应该覆盖整个字符串<code>s</code> ，而不是部分字符串。<br>说明:</p><ul><li><code>s</code>可能为空，且只包含从<code>a-z</code>的小写字母。</li><li><code>s</code>可能为空，且只包含从<code>a-z</code>的小写字母，以及字符<code>.</code>和<code>*</code>。</li></ul><p>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure></p><p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &apos;*&apos; 代表可匹配零个或多个前面的元素, 即可以匹配 &apos;a&apos; 。因此, 重复 &apos;a&apos; 一次, 字符串可变为 &quot;aa&quot;。</span><br></pre></td></tr></table></figure></p><p>示例3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个(&apos;*&apos;)任意字符(&apos;.&apos;)。</span><br></pre></td></tr></table></figure></p><p>示例4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &apos;c&apos; 可以不被重复, &apos;a&apos; 可以被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure></p><p>示例5：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>对于题目描述的理解难度不是很大，这就是我们常常使用的正则表达式匹配方法。首先我们假设字符模式<code>p</code>中没有<code>.</code>和<code>*</code>的情况，这种情况下判断字符模式<code>p</code>和字符串<code>s</code>是否匹配的方法是逐一比较即可。如果两个字符串有一个位置上的字符不相等，则这两个字符串不匹配；如果两个字符串所有位置上的字符都相等，则这两个字符串匹配。接下来我们考虑字符模式<code>p</code>有<code>.</code>和<code>*</code>的情况：</p><ul><li>由题意可知，<code>.</code>匹配任意单个字符。如果字符模式<code>p</code>中的某一位置上的字符为<code>.</code>，则字符串<code>s</code>对应位置不论是任何字符都相等，继续匹配下一个字符；</li><li><code>*</code>匹配零个或多个前面的元素。即<code>*</code>的存在使字符模式<code>p</code>变成了多个可能的字符串。因此，必须将<code>*</code>能够表示的所有情况与字符串<code>s</code>相比较，如果存在一种匹配的情况，那么这两个字符串匹配，反之，这两个字符串不匹配。<ul><li>当字符模式<code>p</code>中存在<code>*</code>时，<code>*</code>和其前一个字符（令该字符为<code>x</code>）有如下三种可能的匹配情况：<ul><li>空字符：<code>&quot;&quot;</code></li><li>单一字符：<code>x</code></li><li>多个字符：<code>xx</code>或<code>xxx</code>等等</li></ul></li></ul></li></ul><p>理解完题意后，我们再来举一个实例进一步分析，我们就用题目中的示例4作为实例。如下图所示，其中纵向为字符串<code>s</code>，横向为字符模式<code>p</code>。</p><img src="/2019/05/23/LeetCode-10-正则表达式匹配/实例示意图.png" title="图1.实例示意图"><p>我们可以用字符模式<code>p</code>与字符串<code>s</code>一一比较，如图字符模式中<code>p[0]=c</code>与字符串中<code>s[0]=a</code>比较，发现他们不相等，这时如果字符模式<code>p</code>中的下一个字符不为<code>*</code>的话，则字符模式<code>p</code>与字符串<code>s</code>匹配不成功，返回<code>false</code>；而图中实例字符模式<code>p</code>的下一个字符为<code>*</code>，因此字符模式<code>p</code>中的<code>c*</code>匹配字符串<code>s</code>中的<code>&quot;&quot;</code>，接下来字符模式中<code>p[2]=a</code>与字符串中<code>s[0]=a</code>匹配，匹配成功，接下来字符模式中<code>p[3]=*</code>与字符串中<code>s[1]=a</code>匹配，匹配成功，接下来字符模式中<code>p[4]=b</code>与字符串中<code>s[2]=b</code>匹配，匹配成功。因此字符模式<code>p</code>与字符串<code>s</code>能匹配成功。如下图所示：</p><img src="/2019/05/23/LeetCode-10-正则表达式匹配/实例匹配成功.png" title="图2.实例匹配成功"><p>分析到这里后，我们可以联想到动态规划的状态转化图像。如果对动态规划不太了解的小伙伴可以查看<a href="https://www.jacob2359.com/2019/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#more" target="_blank" rel="noopener">《数据结构与算法-动态规划》(点击跳转)</a>来学习。下面我们来分析上面这个实例的初始状态及转换后的状态。</p><ul><li>初始状态如下图所示，我们申请了<code>s.length+1</code>行和<code>p.length+1</code>列用来存储字符匹配的状态，我们用<code>dp</code>表示状态方程，<code>dp</code>的第0行和<code>dp</code>的第0列为特殊的行和列，其中<code>dp</code>的第0行用来处理字符模式<code>p</code>的<code>*</code>匹配空字符字等情况，如实例中的字符模式<code>p</code>中的<code>c*</code>匹配字符串<code>s</code>中的<code>&quot;&quot;</code>；<code>dp</code>的第0列除了<code>dp[0][0]</code>外状态都为<code>false</code>；而<code>dp[0][0]</code>的状态初始化为<code>true</code>。</li></ul><img src="/2019/05/23/LeetCode-10-正则表达式匹配/状态方程dp内存空间初始状态.png" title="图3.状态方程dp内存空间初始状态"><ul><li>接下来分析<code>dp</code>的第0行和<code>dp</code>的第0列，由于<code>dp</code>的第0列除了<code>dp[0][0]</code>外状态都为<code>false</code>，这里主要讨论<code>dp</code>第0行状态变换，当字符串中的字符不为<code>*</code>时，其对应状态为<code>false</code>，当字符串中的字符为<code>*</code>时，其对应状态为与其前面第2个状态有关。如示例中，当字符模式<code>p[0]=c</code>时，其对应的状态方式<code>dp[0][1]=false</code>,当字符模式<code>p[1]=*</code>时，其对应的状态方式<code>dp[0][2]=dp[0][0]=true</code>。其他的同理。转换完后的状态方程如下图所示：</li></ul><img src="/2019/05/23/LeetCode-10-正则表达式匹配/第0行和第0列状态方程转换.png" title="图4.第0行和第0列状态方程转换"><h1 id="感觉这一还是没有理解透彻，先码在这里，弄懂后继续码"><a href="#感觉这一还是没有理解透彻，先码在这里，弄懂后继续码" class="headerlink" title="感觉这一还是没有理解透彻，先码在这里，弄懂后继续码"></a>感觉这一还是没有理解透彻，先码在这里，弄懂后继续码</h1>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：10. 正则表达式匹配&lt;/li&gt;
&lt;li&gt;难度：困难&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：动态规划
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
      <category term="动态规划" scheme="http://JacobLei.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode答疑+打卡微信群</title>
    <link href="http://JacobLei.github.io/2019/05/23/LeetCode%E7%AD%94%E7%96%91-%E6%89%93%E5%8D%A1%E5%BE%AE%E4%BF%A1%E7%BE%A4/"/>
    <id>http://JacobLei.github.io/2019/05/23/LeetCode答疑-打卡微信群/</id>
    <published>2019-05-23T02:54:51.000Z</published>
    <updated>2019-05-23T06:51:38.821Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode答疑群和LeetCode打卡群进群方式</p><a id="more"></a><h1 id="LeetCode答疑群"><a href="#LeetCode答疑群" class="headerlink" title="LeetCode答疑群"></a>LeetCode答疑群</h1><p>为了方便小伙伴们在刷LeetCode（或其他算法题）时遇到任何疑问时方便答疑，建立一个LeetCode答疑群，有任何关于LeetCode（或其他算法题）的相关问题都可以在答疑群中留言，当博主或其他小伙伴看到问题留言时，如果对问题有思路，则会回复。答疑群目的是为了小伙伴们一起学习，共同进步。</p><ul><li>提问方式：【问题LeetCode编号】+ 问题描述</li><li>回答方式：【回答LeetCode编号】+ 答案描述</li><li>进群方式：扫描下方二维码，添加博主的微信号【申请时请留言：<strong>加入LeetCode答疑群+姓名</strong>】，然后博主将你拉入微信群。</li></ul><img src="/2019/05/23/LeetCode答疑-打卡微信群/博主微信二维码.jpg" title="博主微信二维码"><h1 id="LeetCode打卡群"><a href="#LeetCode打卡群" class="headerlink" title="LeetCode打卡群"></a>LeetCode打卡群</h1><p>如果有小伙伴觉得自己刷题自控能力不够，但又想每周刷三道题，或者想和更多的小伙伴们一起刷题，博主建立了一个LeetCode打卡群。打卡群主要是为了小伙伴们通过打卡机制来提高自己的自控能力，保证一周最少能刷三道LeetCode题。</p><ul><li>打卡方式：<ul><li>打卡周的前一个周日晚上8点群主将在群里中收集小伙伴的打卡目标，小伙伴们回复自己的【打卡目标】。如：打卡第一周目标：LeetCode第5、6、7题；或者按照主题打卡定目标，如打卡第一周目标：栈主题+2道简单题+1道困难题。回复目标可以自定义方式（要突出这一周的刷题个数，最少三道），主要是给自己定一个一周的小目标。</li><li>小伙伴们回复完【打卡目标】开始到打卡周的周日晚上7点30截至，在群里发送：<strong>【打卡第m周第n题+LeetCode编号】+ 解题答案 + 通过报告截图</strong> 即打卡完成</li></ul></li><li>奖励/惩罚方式：<ul><li>加入打卡群前提：入群时本人需要缴纳10元的保证金</li><li>惩罚：当在本周打卡截至时间前未完成打卡目标，则10元的保证金作为惩罚将由博主发到打卡群中，群中的小伙伴抢红包</li><li>奖励：现阶段奖励为能够有机会抢到未完成打卡目标的小伙伴的保证金红包，后续等博主资金充裕后会定相关规则，送获奖者书籍</li></ul></li><li>注意事项：<ul><li>由于打卡群涉及到需要收取保证金问题，必须提前声明一下<strong>打卡的保证金为自愿交纳</strong>。入群时先交给博主管理，博主会统计小伙伴的目标和打卡情况，然后周日7点30后会联系相应<strong>未打卡完成</strong>的小伙伴，告诉其保证金需要作为惩罚红包发送到群里。</li><li>未打卡完成的小伙伴由于其保证金作为惩罚红包发给打卡群中，如果想继续参加打卡活动，则需要重新联系博主交纳保证金；如果不想继续参加，也可联系博主，将其退出打卡群，如果未联系博主，则博主在一天后会将其退出打卡群</li><li>打卡完成的小伙伴如果想继续参加打卡活动，则不需要重新交纳保证金，上次交纳的保证金顺延到本次；如果不想继续参加，则联系博主退还保证金</li><li>由于博主一个人运营打卡群，担心人多管理不过来，设定打卡群的人数上限为30人</li><li>每次打卡活动10人（包含博主）及以上则启动打卡活动，若人数不够10人，则会暂停</li></ul></li><li>进群方式：扫描文下方二维码，添加博主的微信号【申请时请留言：<strong>加入LeetCode打卡群+姓名</strong>】，然后博主将你拉入微信群，进群后需要交纳10保证金，保证金的具体使用参看<strong>注意事项</strong>。</li></ul><img src="/2019/05/23/LeetCode答疑-打卡微信群/博主微信二维码.jpg" title="博主微信二维码">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode答疑群和LeetCode打卡群进群方式&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-9 回文数</title>
    <link href="http://JacobLei.github.io/2019/05/22/LeetCode-9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://JacobLei.github.io/2019/05/22/LeetCode-9-回文数/</id>
    <published>2019-05-22T05:17:40.000Z</published>
    <updated>2019-05-24T01:23:43.192Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：9. 回文数</li><li>难度：简单</li><li>分类：字符串、数学</li><li>解决方案：双指针、整数取余<a id="more"></a></li></ul><p>今天我们学习第9题<strong>回文数</strong>，这是一个关于数学的简单题，这个题目比较简单，最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">题目描述</a></h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure></p><p>进阶:<strong>你能不将整数转为字符串来解决这个问题吗？</strong></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>看完这个题目，对于回文数我们应该不陌生。我们在<a href="https://www.jacob2359.com/2019/05/13/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/#more" target="_blank" rel="noopener">LeetCode-5 最长回文子串</a>中介绍过<strong>回文串</strong>，即从左向右读和从右向左读的结果是一样的字符串。本题是判断一个整数是否为一个回文数，最简单的做法是先将这个整数转化为字符串，然后使用双指针的方式判断这个字符串是否为回文串。<br>具体<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转化为字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[] str = String.valueOf(x).toCharArray();</span><br><span class="line">    <span class="comment">// 创建左右指针</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = str.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历字符串</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="comment">// 如果左指针指向的字符与右指针指向的字符不同时，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (str[left] != str[right])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        left++;<span class="comment">// 左指针向右移动</span></span><br><span class="line">        right--;<span class="comment">// 右指针向左移动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/22/LeetCode-9-回文数/回文字符串提交结果.png" title="图1.回文字符串提交结果"><p>将整数转化为字符串后这个题目的思路就很清晰了。注意看<strong>进阶</strong>部分的提示：<strong>你能不将整数转为字符串来解决这个问题吗？</strong> 因此我们需要换一种思路来解决这个题目。<br>我们想一想整数如果是负数，则直接返回<code>false</code>，如示例2中可以知道一个负数不可能为回文数。由于整数不可能为0开头（除整数0外），因此整数的个位数为0也直接返回<code>false</code>，如示例3所示。排除完这两种特殊情况后，我们该如何判断剩下的整数是不是回文数呢？要判断一个数是否为回文数，则需要判断前半段和后半段是否对称，我们将后半段部分的数字翻转一下，然后判断翻转后的数字是否与前半部分的数字是否相等即可。我们可以将整数对10取余得到整数的个位数。由于数字位数为奇数个和偶数个的情况不一样，我们通过两个实例分析，如下图2所示。</p><img src="/2019/05/22/LeetCode-9-回文数/整数翻转实例.png" title="图2.整数翻转实例"><p>通过分析之后，具体代码就不难实现了。<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排除负数和以0结尾的整数（除0以外）</span></span><br><span class="line">    <span class="keyword">if</span> ((x &lt; <span class="number">0</span>) || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span> ))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> reverNum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 翻转整数过程</span></span><br><span class="line">    <span class="keyword">while</span> (x &gt; reverNum)&#123;</span><br><span class="line">        reverNum = reverNum * <span class="number">10</span> + x % <span class="number">10</span>;  <span class="comment">// 计算翻转数字</span></span><br><span class="line">        x /= <span class="number">10</span>;                            <span class="comment">// 计算剩余数字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reverNum == x || reverNum / <span class="number">10</span> == x; <span class="comment">// reverNum == x为整数位数偶数个时的判断条件；reverNum / 10 == x为整数位数奇数个时的判断条件</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/22/LeetCode-9-回文数/回文数提交结果.png" title="图3.回文数提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A9_PalindromeNumber.java" target="_blank" rel="noopener">LeetCode-9 回文数</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9.回文数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：9. 回文数&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：字符串、数学&lt;/li&gt;
&lt;li&gt;解决方案：双指针、整数取余
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法-递归</title>
    <link href="http://JacobLei.github.io/2019/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/"/>
    <id>http://JacobLei.github.io/2019/05/21/数据结构与算法-递归/</id>
    <published>2019-05-21T07:37:02.000Z</published>
    <updated>2019-05-23T07:26:47.731Z</updated>
    
    <content type="html"><![CDATA[<p>本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。</p><a id="more"></a><h1 id="如何理解递归？"><a href="#如何理解递归？" class="headerlink" title="如何理解递归？"></a>如何理解递归？</h1><p>在学习数据结构与算法的过程中一般都会遇到一个坎——递归。今天我们就来分析分析递归。<br>首先我们通过一个生活中的例子入手。假如你现在正在排队买票，前面有很多人，怎么才能知道你现在是第几号呢？这个时候就可以用递归了，你知道问你前面的人是多少号，在他的号数上加一即为你的号数。但是，前面的人也不知道自己是多少号啊，所以他再问他前面的人，这样一个一个的向前面问，直到问道队头的人，他说他现在是1号，然后这样就可以一个一个向后把数字传回来，直到你前面的人告诉你他是多少号，这样你就知道了你的位置了。<br>这个例子就是一个标准的递归求解问题的分解过程，一个一个向前问的过程就是”递”，一个一个向后传回来的过程就是”归”。基本上所有的递归问题都可以用公式表示出来。如上述例子的递归推导公式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + 1，其中f(1) = 1</span><br></pre></td></tr></table></figure></p><p><code>f(n)</code>表示你现状所在的位置（多少号），<code>f(n-1)</code>表示你前面一个人所在的位置（多少号），<code>f(1) = 1</code>表示第一个人直到自己为1号。有了这个递推公式，我们就可以很轻松的将它改写为递归代码，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="递归需要满足的条件"><a href="#递归需要满足的条件" class="headerlink" title="递归需要满足的条件"></a>递归需要满足的条件</h1><p>从上述例子可以可以总结如下三个条件：</p><ol><li><p><strong>一个问题的解可以分解为几个子问题的解</strong><br>什么是子问题？子问题就是数据规模更小的问题。如前面介绍的例子，想要直到自己在哪个位置，可以分解为<strong>前面的人知道他在哪个位置</strong>这样一个子问题。</p></li><li><p><strong>子问题除了数据规模不同，求解思路完全一样</strong><br>如前面介绍的例子，你求解自己在哪个位置的思路，和前面一个人求解他自己在哪个位置的思路是完全一样的。</p></li><li><p><strong>必须存在一个递归终止条件</strong><br>把问题分解为子问题，然后把子问题分解为子子问题，一层一层分解下去，需要终止条件结束这种循环。如前面的例子，队头的人不需要问其他人就知道自己为1号，也就是这里的<code>f(1) = 1</code>，这就是终止条件。</p></li></ol><h1 id="如何编写递归代码"><a href="#如何编写递归代码" class="headerlink" title="如何编写递归代码"></a>如何编写递归代码</h1><p>理解递归的过程和递归需要满足的条件后，我们接下来想想如何才能写出递归代码来呢？对于递归代码的编写，最重要的是<strong>写出递归公式，找到递归终止条件</strong>。<br>下面我们看一看LeetCode上一个原题<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70.爬楼梯【题目链接】</a>。对于第一步的走法把所有走法分为两类，一类是第一步走了1个台阶，另一类是第一步走了2个台阶。所以对于n个台阶的走法就是等于先走1个台阶后剩下的n-1个台阶的走法+先走2个台阶后剩下的n-2个台阶的走法。递归公式表示如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>接下来我们关心的就是递归终止条件了。当只有一个台阶时，只有一种走法，就不需要递归。因此<code>f(1) = 1</code>。这个递归终止条件足够吗？我们可以使用<code>n=2</code>，和<code>n=3</code>这样比较小的数来试验一下。<br>当<code>n=2</code>时，<code>f(2) = f(1) + f(0)</code>，由于只有<code>f(1) = 1</code>这一个递归终止条件，无法将<code>f(2)</code>求解出来。所以除了<code>f(1) = 1</code>这一个递归终止条件外，我们可以把剩余两个台阶时作为递归终止条件，即<code>f(2) = 2</code>作为递归终止条件。这样知道递归终止条件和递归公式后，我们就可以轻松写出递归代码了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>总结：写递归代码的关键就是<strong>如何将大问题分解为小问题的规律，并基于此规律写出递归公式，并总结处递归终止条件，最后将递归公式和递归终止条件翻译成代码</strong>。</p></blockquote><h1 id="避开思维误区"><a href="#避开思维误区" class="headerlink" title="避开思维误区"></a>避开思维误区</h1><p>对于排队买票的例子，递归调用只有一个分支，也就是说”一个问题只需要分解为一个子问题”，这时我们很容易弄清楚”递”的过程和”归”的过程，所以理解起来难度不大。但是，当我们面临一个问题有多个子问题的情况时，递归就没有那么好理解了。<br>就如爬楼梯的例子，我们人脑几乎没有办法将整个”递”的过程和”归”的过程每一步想得清清楚楚。计算机擅长做重复的事情，所以递归正是这样，而我们人脑更喜欢平铺直叙的思维方式，当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后一层一层返回，试图想弄清楚计算机每一步都是怎么执行的，这样很容易被绕进去。<br>对于递归代码，这种试图想清楚整个递和归过程的做法实际上是进入了一个<strong>思维误区</strong>。我们该如何去思考递归呢？<br>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。因此，<strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</strong>。</p><h1 id="递归代码的注意事项"><a href="#递归代码的注意事项" class="headerlink" title="递归代码的注意事项"></a>递归代码的注意事项</h1><h2 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h2><p>由于在函数调用时会使用栈来保存临时变量，每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。<strong>如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险</strong>。<br>那么该如何避免堆栈溢出呢？<br>我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。对于排队买票的例子，我们可以改造成下面这样子，就可以避免堆栈溢出了。为了代码简洁，有些边界条件没有考虑，比如 x&lt;=0。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示递归的深度</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(depth &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">throw</span> exception;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。</p><h2 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h2><p>我们在分析一下爬楼梯的例子，如果我们把整个递归过程分解一下的话，那就是这样的：<br><img src="/2019/05/21/数据结构与算法-递归/爬楼梯递归过程分解图.jpg" title="爬楼梯递归过程分解图"></p><p>从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。</p><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。<br>我们改写爬楼梯的代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasSolvedList 为一个Map，其中key为n，value为f(n)</span></span><br><span class="line">    <span class="keyword">if</span>(hasSolvedList.containsKey(n))&#123;</span><br><span class="line">    <span class="keyword">return</span> hasSolvedList.get(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    hasSolvedList.put(n, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了堆栈溢出、重复计算这两个常见的问题。递归代码还有很多别的问题。</p><p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是<code>O(1)</code>，而是<code>O(n)</code>。</p><h1 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h1><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。<br>那我们是否可以把递归代码改写为非递归代码呢？比如刚才那个排队买票的例子，我们抛开场景，只看<code>f(x) =f(x-1)+1</code> 这个递推公式。我们这样改写看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    res += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，爬楼梯的例子改为非递归的代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">    res = pre + prepre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有的递归代码都可以迭代的方式。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为王争老师在『极客时间』中的课程《数据结构与算法之美》的学习笔记，想要学习原文的同学购买相关课程学习。如有侵权请联系作者删除。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://JacobLei.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://JacobLei.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-8 字符串转换整数</title>
    <link href="http://JacobLei.github.io/2019/05/21/LeetCode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"/>
    <id>http://JacobLei.github.io/2019/05/21/LeetCode-8-字符串转换整数/</id>
    <published>2019-05-21T04:42:29.000Z</published>
    <updated>2019-05-21T10:33:51.804Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：8. 字符串转换整数</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：字符串遍历<a id="more"></a></li></ul><p>今天我们学习第8题<strong>字符串转换整数</strong>，这是一个字符串的中等题，像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">题目描述</a></h1><p>请你来实现一个<code>atoi</code>函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：<br>假设我们的环境只能存储32位大小的有符号整数，那么其数值范围为<code>[−2^31,  2^31 − 1]</code>。如果数值超过这个范围，请返回 <code>INT_MAX(2^31 − 1)</code>或<code>INT_MIN(−2^31)</code> 。</p><p>示例1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure></p><p>示例2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure></p><p>示例3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure></p><p>示例4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure></p><p>示例5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−2^31) 。</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个字符串转换整数的题比较常规，题目和示例中已经详细说明了转换过程及转换的情况，具体归纳如下：</p><ul><li>如果字符串开头为空格，则跳过所有的空格字符，直到寻找到第一个非空格的字符为止，如果全部都是空格，则返回0；</li><li>如果第一个非空格字符为符号字符(<code>+/-</code>)，则使用符号标记<code>sign</code>标记，当为<code>+</code>时，<code>sign=1</code>；当为<code>-</code>时，<code>sign=-1</code>；</li><li>去掉开头的空格字符和符号字符后，如果接下来的字符不为数字字符，则返回0；</li><li>去掉开头的空格字符和符号字符后，如果接下来的字符为数字字符，则将其转化为整数并保存，直到出现不为数字字符或字符串遍历结束；</li><li>特别注意的是，数字转换的时候<strong>需要考虑整数是否溢出</strong>.</li></ul><p>有了上述的分析后，具体<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len = ch.length, index = <span class="number">0</span>, sign = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 注意：这里不能为int类型，需要long类型，目的是为了检查结果是否溢出</span></span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 去掉开头的空格部分</span></span><br><span class="line">        <span class="keyword">while</span>(index&lt;len &amp;&amp; ch[index] == <span class="string">' '</span>) index++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否为符号位，当为+时，sign=1；当为-时，sign=-1</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; len &amp;&amp; (ch[index] == <span class="string">'+'</span> || ch[index] == <span class="string">'-'</span>))&#123;</span><br><span class="line">            sign = (ch[index] == <span class="string">'+'</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历字符数组</span></span><br><span class="line">        <span class="keyword">while</span>(index &lt; len)&#123;</span><br><span class="line">            <span class="comment">// 判断是否位数字</span></span><br><span class="line">            <span class="keyword">if</span>(ch[index] &gt;= <span class="string">'0'</span> &amp;&amp; ch[index] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                sum = sum*<span class="number">10</span> + ch[index] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">// 判断结果是否溢出</span></span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="number">1</span> &amp;&amp; sum &gt; Integer.MAX_VALUE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sign == -<span class="number">1</span> &amp;&amp; (-<span class="number">1</span>*sum) &lt; Integer.MIN_VALUE)&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 如果不是数字，则直接返回</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)sum * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/21/LeetCode-8-字符串转换整数/提交结果.png" title="图1.提交结果"><p>整个算法流程的时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code>。</p><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A8_StringtoInteger.java" target="_blank" rel="noopener">LeetCode-8 字符串转换整数</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8.字符串转换整数</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：8. 字符串转换整数&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：字符串遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-7 整数反转</title>
    <link href="http://JacobLei.github.io/2019/05/20/LeetCode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://JacobLei.github.io/2019/05/20/LeetCode-7-整数反转/</id>
    <published>2019-05-20T11:47:59.000Z</published>
    <updated>2019-05-20T12:38:15.133Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：7. 整数反转</li><li>难度：简单</li><li>分类：数学</li><li>解决方案：整数取模<a id="more"></a></li></ul><p>今天我们学习第7题<strong>整数反转</strong>，这是个简单的数学题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">题目描述</a></h1><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure></p><p>示例2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure></p><p>示例3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p><p>注意:<br><strong>假设我们的环境只能存储得下32位的有符号整数，则其数值范围为[−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回0。</strong></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>相信小伙伴们看完这个题目后就会有思路，就是通过取模把最低位取到，然后拼接即可。对于整数<code>-123</code>的转换过程如图1所示：</p><img src="/2019/05/20/LeetCode-7-整数反转/转换过程.png" title="图1.转换过程"><p>值得注意的是如果整数反转后溢出了怎么办？由题意可知，溢出后返回0，因此我们需要判断结果是否溢出。</p><p>具体<code>java</code>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意这里为long类型，防止int类型的则行数反转后溢出</span></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反转整数</span></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 获取到最低位</span></span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 在原数字上移除最低位</span></span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断是否溢出，若溢出则返回0</span></span><br><span class="line">            <span class="keyword">if</span>(res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/20/LeetCode-7-整数反转/提交结果.png" title="图2.提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A7_ReverseInteger.java" target="_blank" rel="noopener">LeetCode-7 整数反转</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7.整数反转</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：7. 整数反转&lt;/li&gt;
&lt;li&gt;难度：简单&lt;/li&gt;
&lt;li&gt;分类：数学&lt;/li&gt;
&lt;li&gt;解决方案：整数取模
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-6 Z字形变换</title>
    <link href="http://JacobLei.github.io/2019/05/19/LeetCode-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://JacobLei.github.io/2019/05/19/LeetCode-6-Z字形变换/</id>
    <published>2019-05-19T08:39:24.000Z</published>
    <updated>2019-05-20T12:29:33.922Z</updated>
    
    <content type="html"><![CDATA[<ul><li>题目：6. Z字形变换</li><li>难度：中等</li><li>分类：字符串</li><li>解决方案：字符串遍历<a id="more"></a></li></ul><p>今天我们学习第6题<strong>Z字形变换</strong>，这是一个字符串的中等题，像这样字符串的题目经常作为面试题来考察面试者算法能力和写代码能力，因此最好能手写出该题。下面我们看看这道题的题目描述。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">题目描述</a></h1><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为<code>&quot;LEETCODEISHIRING&quot;</code>行数为3时，排列如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure></p><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。<br>请你实现这个将字符串进行指定行数变换的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure></p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个题目的难度不太大，主要是对题目的理解，只有理解题目中的<strong>Z字形</strong>是如何生成后才能做出来。注意，这里的Z字形其实是<strong>将Z逆时针旋转90°后形成的</strong>，如图1所示。</p><img src="/2019/05/19/LeetCode-6-Z字形变换/Z字形旋转过程.png" title="图1.Z字形旋转过程"><p>题目中的示例字符串不容易看出规律，我们假设一个字符串为<code>&quot;ABCDEFGHIJKLMN&quot;</code>，然后看看是如何形成Z字形的，具体过程如图2所示。</p><img src="/2019/05/19/LeetCode-6-Z字形变换/解题思路.png" title="图2.解题思路"><p>由图2可知黑色字符表示Z字形垂直部分，红色字符表示Z字形斜右方向部分。不难看出垂直部分字符的个数为<code>numRows</code>，斜右方向部分子数的个数为<code>numRows-2</code>(除首行和最后一行以外，其余的行数个数)。理解这个形成过程后，我们只需要把这个形成过用代码实现即可。</p><p>具体<code>java</code>代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="comment">// 构建二维数组（这里使用的StringBuilder是Java面试时的一个考点，可以查看String、StringBuffer和StringBuilder的区别）</span></span><br><span class="line">        StringBuilder[] sb = <span class="keyword">new</span> StringBuilder[numRows];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numRows; i++)&#123;</span><br><span class="line">            sb[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, len = arr.length;</span><br><span class="line">        <span class="comment">// 遍历原始数组，构建Z字形二维数组</span></span><br><span class="line">        <span class="keyword">while</span>(index &lt; len)&#123;</span><br><span class="line">            <span class="comment">// 垂直添加元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numRows &amp;&amp; index &lt; len; i++)&#123;</span><br><span class="line">                sb[i].append(arr[index++]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 斜右向添加元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=numRows-<span class="number">2</span>; i&gt;=<span class="number">1</span> &amp;&amp; index &lt; len; i--)&#123;</span><br><span class="line">                sb[i].append(arr[index++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将除第0行以外的行有序拼接到第0行后面</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;numRows; i++)&#123;</span><br><span class="line">            sb[<span class="number">0</span>].append(sb[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2019/05/19/LeetCode-6-Z字形变换/提交结果.png" title="图3.提交结果"><h1 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h1><p><a href="https://github.com/JacobLei/leetcode/blob/master/src/main/java/A6_ZigZagConversion.java" target="_blank" rel="noopener">LeetCode-6 Z字形变换</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode.com/problems/zigzag-conversion/discuss/3403/Easy-to-understand-Java-solution" target="_blank" rel="noopener">6.Z字形变换</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;题目：6. Z字形变换&lt;/li&gt;
&lt;li&gt;难度：中等&lt;/li&gt;
&lt;li&gt;分类：字符串&lt;/li&gt;
&lt;li&gt;解决方案：字符串遍历
    
    </summary>
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://JacobLei.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
